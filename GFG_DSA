############################################################################
2. Mathematics
############################################################################


GCD or HCF of two Numbers
---------------------------

-> Euclidean Algorithm

Let 'b' be smaller than 'a'
	gcd(a,b) = gcd(a-b,b)


Algorithm 1:
	
	int gcd(int a, int b)
	{
		while(a!=b)
		{
			if(a>b)
				a = a-b;
			else
				b = b-a;
		}

		return a;	// return b;
	}



Algorithm 2(Optimized):
	
	int gcd(int a, int b)
	{
		if(b==0)
			return a;
		else
			return gcd(b, a%b);
	}

	
	Time Complexity: O(log(min(a,b)))







LCM of Two Numbers
--------------------

a*b = gcd(a,b) * lcm(a,b)

lcm(a,b) = (a*b)/gcd(a,b)

Algorithm:
	
	int gcd(int a, int b)
	{
		if(b == 0)
			return a;
		return gcd(b, a%b);
	}

	int lcm(int a, int b)
	{
		return (a*b)/gcd(a,b);
	}


	Time Complexity: O(log(min(a,b)))









Check for Prime:
-----------------------

-> 1 is neither prime number nor a composite number

-> 2 is the only prime number which is even



Idea: Divisors always appear in pairs.

	30: (1,30), (2,15), (3,10), (5,6)
	
	65: (1,65), (5,13)

	25: (1,25), (5,5)


If (x, y) is a pair
	
	x * y = n

And if x <= y
	
	x * x <= n
	
	x <= squareRoot(n)




Algorithm 1:
	
	bool isPrime(int n)
	{
		if(n == 1)
			return false;
		
		for(int i=2; i*i <= n; i++)
		{
			if(n % i == 0)
				return false;
		}
		
		return true;
	}


	Time Complexity: O(squareRoot(n))



Algorithm 2 (More Optimized): 	// Almost 3 times faster than above Algorithm
	
	bool isPrime(int n)
	{
		if(n == 1) 
			return false;
		if(n == 2 || n == 3)
			return true;
		if(n%2 == 0 || n%3 == 0)
			return false;

		for(int i=5; i*i <= n; i = i+6)
		{
			if(n%i == 0 || n%(i+2) == 0)
				return false;
		} 

		return true;
	}










Prime Factors
------------------

Algorithm 1 (Naive Solution):

	void primeFactors(int n)
	{
		for(int i=2; i<n; i++)
		{
			if(isPrime(i))
			{
				int x = i;
				
				while(n%x == 0)
				{
					print(i);
					x = x*i;
				}
			}
		}
	}


	Time Complexity: O(n^2log(n))



Algorithm 2 (Optimized Solution):

	void primeFactors(int n)
	{
		if(n <= 1)
			return;

		for(int i=2; i*i <= n; i++)
		{
			while(n%i == 0)
			{
				print(i);
				n = n/i;
			}
		}
		
		if(n > 1)
			print(n);

	}




Algorithm 3 (More Optimized Solution):

	void primeFactors(int n)
	{
		if(n <= 1)
			return;

		while(n%2 == 0)
		{
			print(2);
			n = n/2;
		}

		while(n%3 == 0)
		{
			print(3);
			n = n/3;
		}

		for(int i=5; i*i <= n; i = i+6)
		{
			while(n%i == 0)
			{
				print(i);
				n = n/i;
			}

			while(n%(i+2) == 0)
			{
				print(i+2);
				n = n/(i+2);
			}
		}

		if(n > 3)
			print(3);

	}


	Time Complexity: O(sqrt(n)) 
		
		-> Worst case scenario is when the number n, is prime number









All Divisors of a Number
------------------------------

Idea: Divisors of a Number, always appears in pairs


Algorithm 1 (Print all divisors but not in order):

	void printDivisors(int n)
	{
		for(int i=1; i*i <= n; i++)
		{
			if(n%i == 0)
			{
				print(i);
				
				if(i != n/i)
				{
					print(n/i);
				}
			}
		}
	}


	Time Complexity: O(sqrt(n))



Algorithm 2 (Prints all divisors in sorted order):

	void printDivisorsInSortedOrder(int n)
	{
		int i;
		
		for(i=1; i*i < n; i++)
		{
			if(n%i == 0)
				print(i);
		}

		for(; i >= 1; i--)
		{
			if(n%i == 0)
				print(n/i);
		}
	}


	Time Complexity: O(sqrt(n))










Sieve of Eratosthenes
---------------------------------

To find all the prime numbers less than or equal to the given number

I/P: n = 10
o/p: 2,3,5,7

I/P: n = 23
o/p: 2,3,5,7,11,13,17,19,23


Algorithm 1 (Simple Implementation of Sieve of Eratosthenes):

	void sieve_of_eratosthenes(int n)
	{
		vector<bool> isPrime(n+1, true);
		
		for(int i=2; i*i <= n; i++)
		{
			if(isPrime[i])
			{
				for(int j=2*i; j<=n; j = j+i)
				{
					isPrime[j] = false;
				}
			}
		}

		for(int i=2; i<=n; i++)
		{
			if(isPrime[i])
			{
				cout<<i<<" ";
			}
		}
	}


Algorithm 2 (Optimized Implementation of Sieve of Eratosthenes):

	void sieve_of_eratosthenes(int n)
	{
		vector<bool> isPrime(n+1, true);
		
		for(int i=2; i*i <= n; i++)
		{
			if(isPrime[i])
			{
				for(int j=i*i; j<=n; j = j+i)
				{
					isPrime[j] = false;
				}
			}
		}

		for(int i=2; i<=n; i++)
		{
			if(isPrime[i])
			{
				cout<<i<<" ";
			}
		}
	}


Algorithm 3 (Shorter Implementation of the Optimized Sieve):

	void sieve_of_eratosthenes(int n)
	{
		vector<bool> isPrime(n+1, true);
		
		for(int i=2; i<=n; i++)
		{
			if(isPrime[i])
			{
				cout<<i<<" ";

				for(int j = i*i; j <= n; j = j+1)
				{
					isPrime[j] = false;
				}
			}
		}
	}

	Time Complexity: O(nlog(log(n)))










Computing Power
---------------------

Idea behing optimized Algorithm:
	
	power(x, n) = 		if(n%2 == 0)
							power(x, n/2) * power(x, n/2)
						else
							power(x, n-1) * x


Algorithm 1 (Using Recursion): 
	
	int pow(int x, int n)
	{
		if(n == 0)
			return 1;

		int temp = pow(x, n/2);
		
		temp = temp * temp;
		
		if(n%2 == 0)
			return temp;
		else
			return temp * x;
	}


	Time Complexity: O(log(n))
	Space Complexity: O(log(n))


Iterative Power
-------------------

Idea: 
	1. Every number can be written as sum of powers of 2 (set bits in binary representation)

			3^10 = 3^8 * 3^2				||		10: 1010

			3^19 = 3^16 * 3^2 * 3^1			|| 		19: 10011		

	2. We can traverse through all bits of a number (from LSB to MSB) in O(log(n)) time.
			
			while(n > 0)
			{
				if(n%2 == 0)
					// Bit is 1
				else
					// Bit is 0
				n = n/2;
			}


Algorithm 2 (Using Iterative Function):

	int power(int x, int n)
	{
		int res = 1; 

		while(n > 0)
		{
			if(n%2 != 0)
				res = res*x;

			x = x*x;
			n = n/2;
		}

		return res;
	}	


	Time Complexity: O(log(n))
	Space Complexity: O(1)



Algorithm 3 (Further Optimization using Bitwise operators):

	int power(int x, int n)
	{
		int res = 1; 

		while(n > 0)
		{
			if(n & 1)	// Bitwise AND
				res = res*x;

			x = x*x;
			n = n>>1;
		}

		return res;
	}	


	Time Complexity: O(log(n))
	Space Complexity: O(1)



Algorithm 4 (Avoiding Overflow problem using Modulo Arithmetic):

	int power(int x, int n, int Modulo)
	{
		int res = 1; 

		while(n > 0)
		{
			if(n & 1)	// Bitwise AND
				res = (res*x) % Modulo;

			x = (x*x) % Modulo;
			n = n>>1;
		}

		return res;
	}	






















































#################################################################################
3. Bit Magic
#################################################################################



-> There are 6 bit-wise operators in C++
	1. Bitwise AND (&)
	2. Bitwise OR (|)
	3. Bitwise XOR (^)
		-> It produces output as 1, if two input bits are different
	4. Left Shift Operator (<<)
		-> Multiplies the number by powers of 2
		-> If we assume that the leading 'y' bits are 0, then result of "x << y" is 
			equivalent to "x * (2^y)"
	5. Right Shift Operator (>>)
		-> Divides the number by powers of 2
		-> If we assume that the leading 'y' bits are 0, then result of "x << y" is 
			equivalent to floor value of "x / (2^y)"
	6. Bitwise Not (~)
	


-> int data-type size is not fixed in C++ reference. The compilers are free to choose the size of 
	int data-type. So, it can be "32 bit" Or "64 bit" Or "16 bit".


-> Negative integers (Signed integers) are stored in 2's complement form because 
	1. Not to have 2 representations of 0
	2. Range reduces by 1 if we will not use 2's complement form to store negative values.



-> 2's complement of "x" in 'n' bit representation  =  (2^n) - x


-> It is generally recommended, not to use Left Shift and Right Shift operators on negative numbers.
 

-> Java represents int data-types as "32 bit".


-> In Java, negative numbers are stored in 2's complement representation.
		--> Representation of -x = (2^32) - x





To check if K-th bit of a Number is set
------------------------------------------------

	1. Algorithm 1 (Using Left Shift)
	
			void IsKthBitSet(int n, int k)
			{
				if(n & (1 << (k-1)) != 0)
				{
					print("yes");
				}
				else
				{
					print("No");
				}
			}


	2. Algorithm 2 (Using Right Shift)
		
			void IsKthBitSet(int n, int k)
			{
				if((n>>(k-1 )) & 1 != 0)
				{
					print("yes");
				}
				else
				{
					print("No");
				}
			}






Programe to Count Set Bits in a Number
----------------------------------------------------

Algorithm 1 (Naive Solution):

	int CountSetBits(int n)
	{
		int count = 0;

		while(n > 0)
		{
			if(n%2 != 0)
				count++;
			n = n/2;
		}

		return count++;
	}


Optimising the Algorithm 1

	int CountSetBits(int n)
	{
		int count = 0;

		while(n > 0)
		{
			if(n&1 == 1)
				count++;
			n = n>>1;
		}

		return count++;
	}



Further Optimising the Algorithm 1

	int CountSetBits(int n)
	{
		int count = 0;

		while(n > 0)
		{
			count += (n&1);
			n = n>>1;
		}

		return count++;
	}


	Time Complexity: O(Total Bits in n)




Algorithm 2 (Brian Kerningam's Algorithm):

	int CountSetBits(int n)
	{
		int count = 0;

		while(n>0)
		{
			n = (n & (n-1));	// *** 
			count++;
		}

		return count;
	}

	
	Time Complexity: O(Set Bit Count) 



*** When you subtract 1 from a Number, all the bits which are 0 after the 
	last set bit(from the right) they become 1, and the last set bit becomes 0 from 1.




Algorithm 3 (Lookup Table Method for 32-bit numbers)

	int table[256];

	void initialize()
	{
		table[0] = 0;

		for(int i=1; i<256; i++)
		{
			table[i] = (i & 1) + table[i/2];
		}

	}

	
	int CountSetBits(int n)
	{
		int count = table[n & Oxff];

		n = n>>8;
		count = count + table[n & Oxff];

		n = n>>8;
		count = count + table[n & Oxff];

		n = n>>8;
		count = count + table[n & Oxff];

		return count;
	}


	Time Complexity: O(1)





Check if a given number is power of Two(2)
---------------------------------------------------------

Algorithm 1 (Naive Solution)

	bool isPowOf2(int n)
	{
		while(n != 1)
		{
			if(n%2 != 0)
			{
				return false;
			}

			n = n/2;
		}

		return true;
	}



Algorithm 2 (Use Brian Kerningam's Algorithm to count the number of Set Bits):


	int CountSetBits(int n)
	{
		int count = 0;

		while(n>0)
		{
			n = (n & (n-1));	// *** 
			count++;
		}

		return count;
	}



	bool isPowOf2(int n)
	{
		int count = CountSetBits(n);

		if(count == 1)
			return true;
		else
			return false;
	}


	Time Complexity: O(Number of Set Bits) = O(1)



Algorithm 3: 

	bool isPowOf2(int n)
	{
		if(n == 0)
			return false;

		return (n & (n-1) == 0);

		// Above statements can also be written in one line as
		// return (n != 0) && (n & (n-1) == 0);
	}






To find the only number in the Array which occurs odd number of times
------------------------------------------------------------------------------


Properties of XOR Operation
	1. x ^ 0 		= 		x

	2. x ^ y 		= 		y ^ x

	3. x ^ (y ^ z) 	= 		(x ^ y) ^ z

	4. x ^ x 		= 		0



Algorithm 1 (Using property x ^ 0 = x)

	int OddOccuringNumber(int[] A, int sz)
	{
		int x = 0;

		for(int i=0; i<sz; i++)
		{
			x = x ^ A[i];
		}

		return x;
	}


	Time Complexity  :  O(n)
	Space Complexity :  O(1)




Q. Given an array of n Numbers that has values in range [1...n+1].
	Every number appear exactly once. Hence one number is missing.
	Find the missing Number.


Algorithm

	int missingNumber(int A[], int n)
	{
		int x = 0;
		int y = 0;

		for(int i=0; i<n; i++)
		{
			x = x ^ A[i];
		}

		for(int i=1; i<=n+1; i++)
		{
			y = y ^ i;
		}

		// Returning the missing Number
		return x ^ y;
	}





Finding Two Odd Occurring Numbers in an Array
--------------------------------------------------------------

Algorithm

	vector<int> TwoOddOccurringNumbers(int[] A, int sz)
	{

		vector<int> res;

		int XOR = 0;
		int res1 = 0;
		int res2 = 0;

		for(int i=0; i<sz; i++)
		{
			XOR = XOR ^ A[i];
		}

		int sn = XOR & ~(XOR - 1);		// Right Most Set Bit

		for(int i=0; i<sz; i++)
		{
			if((A[i] & sn) != 0)
				res1 = res1 ^ A[i];
			else
				res2 = res2 ^ A[i];
		}

		res.push_back(res1);
		res.push_back(res2);

		return res;

	}





Generating Power Set of a Given Set using Bitwise Operators 
--------------------------------------------------------------------

	-> If there are n characters in a string then there are 2^n sub-sets 


Algorithm:

	void printPowerSet(string str)
	{
		int n = str.length();
		int powerSetSize = pow(2, n);

		for (int counter=0; counter < powerSetSize; counter++)
		{
			for(int j=0; j<n; j++)
			{
				if(counter & (1<<j) != 0)
					print(str[j]);
			}
			print("\n");
		}
	}


	Time Complexity: (2^n) * n
































































###################################################################
4. Recursion
###################################################################


Applications of Recursion
------------------------------------

1. Many algorithm techniques are based on Recursion
	-> Dynamic Programming
	-> Backtracking
	-> Divide and Conquer (Binary Search, Quick Sort, Merge Sort)

2. Many problems are inherently Recursive
	-> Tower of Hanoi
	-> DFS based traversals
		i)  DFS of Graph
		ii) Inorder/Preorder/Postorder traversal of tree



-> Tail call elimination / Tail Recursion





Tail Recursion
-------------------------------------

-> Functions with Tail Recursion takes less time on modern compilers.


Tail Call Elimination
	-> Modern compilers use this technique to remove Tail Recursion
		and optimize the program execution.


-> Quick Sort Algorithm is "Tail Recursive".


-> Merge Sort algorithm is not "Tail Recursive".


-> It's good to have Tail Recursive functions because they are optimized 
	by Modern compilers and they take less time and less Auxiliary Space
	compared to their equivalent Non-Tail Recursive functions.



-> Sum of 1st N, natural numbers = (n*(n+1)) / 2






Palindrome Check Using Recursion
-----------------------------------------------------

Function 1:

	bool isPalindrome(string &str, int start, int end)
	{
		if(start >= end)
			return true;

		return (str[start] == str[end]) && isPalindrome(str, start+1, end-1);
	}


Function 2: 

	bool checkPalindrome(string str, int start, int end)
	{   
	    if(str[start] != str[end-1])
	        return false;
	    else if(start > end)
	    {
	        return true;
	    }
	    return checkPalindrome(str, start+1, end-1);
	    
	}






Sum of Digits Using Recursion
------------------------------------------

int sumOfDigits(int n)
{
	if(n <= 9)
		return n;	// This step reduces one function call, thus saving one stack 

	return (n%10) + sumOfDigits(n/10);
}





Rope Cutting Problem
------------------------------------------

Recursive Function:

	int maxNumOfPieces(int ropeLength, int length1, int length2, int length3)
	{
	    if(ropeLength == 0) return 0;
	    
	    if(ropeLength < 0) return -1;
	    
	    int res1 = maxNumOfPieces(ropeLength-length1, length1, length2, length3);
	    int res2 = maxNumOfPieces(ropeLength-length2, length1, length2, length3);
	    int res3 = maxNumOfPieces(ropeLength-length3, length1, length2, length3);
	    
	    int res = (res1 > res2 && res1 > res3) ? res1 : (res2 > res3) ? res2 : res3;
	    
	    if(res == -1)
	        return -1;
	        
	    return res+1;
	}


	Time Complexity: O(3^n)			// Where n = ropeLengthr2


-> This problem has a better solution using Dynamic Programming.






Generate Subsets
-----------------------------------------------

Subsequence of a String
	-> A subsequence is obtained by removing 0 or more characters from the
		given string and "keeping the order of remaining characters same".


-> For a string of length n, there are going to be "2^n" subsets/subsequences.



-> Solution using Bitwise Operator

	void printPowerSet(string str)
	{
		int n = str.length();
		int powerSetSize = pow(2, n);

		for (int counter=0; counter < powerSetSize; counter++)
		{
			for(int j=0; j<n; j++)
			{
				if(counter & (1<<j) != 0)
					print(str[j]);
			}
			print("\n");
		}
	}


	Time Complexity: (2^n) * n




Solution Using Recursion

	-> We can generate all subsets for length n string using 
		subsets for length n-1 string.


	void subSets(string &str, int index, string curr="")
	{
	    if(index == str.length())
	    {
	        cout<<curr<<endl;
	        return;
	    }
	    
	    subSets(str, index+1, curr);
	    subSets(str, index+1, curr+str[index]);
	}







Tower of Hanoi
-------------------------

O/P: We need to move all the disks from Tower A to Tower C using 
		Tower B as an auxiliary tower.


-> Recursive Solution:
	1. Move top n-1 disks from Tower A to Tower B using Tower C
		1.1. Move the last(nth) disk from Tower A to Tower C
	2. Move n-1 disks of Tower B to Tower C using Tower A



-> TOH(n, A, B, C)
	1. TOH(n-1, A, C, B)
	2. Move Disc n from A to C
	3. TOH(n-1, B, A, C)



-> Algorithm

	void towerOfHanoi(int n, char A, char B, char C)
	{
	    if(n == 1)
	    {
	        cout<<"Move 1 from "<<A<<" to "<<C<<endl;
	        return;
	    }
	    
	    towerOfHanoi(n-1, A, C, B);     // Moving from A to B using C
	    
	    cout<<"Move "<<n<<" from "<<A<<" to "<<C<<endl;
	    
	    towerOfHanoi(n-1, B, A, C);
	}


	Number of Movements of n disc = (2^n)-1;







Josephus Problem
-------------------------------------------

Algorithm (If the position starts from 0):
	
	int josephus(int n, int k)
	{
	    // base case
	    if(n == 1)
	    {
	        return 0;
	    }
	    else
	    {
	        return (josephus(n-1, k) + k) % n;
	    }
	}


	Time Complexity: O(n)




Algorithm (If the position starts from 1):
	
	int josephus(int n, int k)
	{
	    // base case
	    if(n == 1)
	    {
	        return 0;
	    }
	    else
	    {
	        return (josephus(n-1, k) + k) % n;
	    }
	}

	int myJosephus(int n, int k)
	{
		return josephus(n, k) + 1;
	}










Subset Sum Problem (Recursive Solution)
-----------------------------------------------------

-> for n sized Array, the number of subsets are 2^n


-> Algorithm

	int countSubsets(int arr[], int sz, int sum) 
	{
	    if(sz == 0)
	        return (sum == 0) ? 1 : 0;
	        
	    return countSubsets(arr, sz-1, sum) + countSubsets(arr, sz-1, sum-arr[sz-1]);
	}



	int main()
	{
	    int arr[] = {10, 20, 15, 5};
	    std::cout << countSubsets(arr, 4, 25) << std::endl;		// O/P: 2
	    return 0;
	} 


	"2^n" 		recursive calls for leaves
	"2^n - 1" 	recursive calls for internal nodes

	Time Complexity: O(2^n)

	-> Here, n is size of the Array




-> We can optimise the above solution using "Back tracking"

-> We can also solve the problem using Dynamic Programming(Psuedo Polynomial).









Printing all Permutations
------------------------------------------

-> For a string of length n, there are n! permutations.


-> Algorithm 1

	void swap(char* a, char* b)
	{
	    char* temp;
	    temp = b;
	    b = a;
	    a = temp;
	}

	void permute(string &str, int i=0)
	{
	    if(i==str.length()-1)
	    {
	        cout<<str<<endl;
	        return;
	    }
	    
	    for(int j=i; j<str.length(); j++)
	    {
	        swap(str[i], str[j]);
	        permute(str, i+1);
	        swap(str[i], str[j]);
	    }
	}

	int main()
	{
	    string str = "ABC";
	    permute(str);

	    return 0;
	}





-> Algorithm 2 (By Abdul Bari):














































































###############################################
5. Arrays
###############################################


-> Elements are stored at contiguous memory locations


-> Advantages of Array
	1. Random Access
	2. Cache Friendliness 



-> Cache is a memory, which is closest to CPU. It is the fastest memory in the computer.






Array Types
----------------------------------------------

-> Array Data Structure (Types)
	1. Fixed Sized Arrays
	2. Dynamic Sized Arrays


-> Fixed Sized Arrays in C/C++

	int arr[100];						// Stack Allocated

	int arr[n]; 						// Stack Allocated

	int *arr = new int[n];				// Heap Allocated		

	int arr[] = {10, 15, 30, 40};		// Stack Allocated




-> Fixed Sized Arrays in Java
		$ In Java, Arrays are always Allocated on Heap

	int[] arr = new int[100];

	int[] arr = new int[n];

	int arr[] = {10, 15, 17, 20};



-> Dynamic Sized Arrays (Resize Automatically)
	1. C++		: vector
	2. Java		: ArrayList
	3. Python	: list






Vector in C++
-----------------------------------------------

-> vector container


-> Advantages of vectors
	1. Dynamic Size
	2. Rich Library functions (find, erase, insert etc...)
	3. Easy to know size
		-> vector.size()
	4. No need to pass size
	5. Can be returned from a function
	6. By default initialized with default values
	7. We can copy a vector to other vector




 

ArrayList in Java
-----------------------------------------

-> ArrayList<Integer> al = new ArrayList<Integer>();	// Empty initially

-> ArrayList<Integer> al = new ArrayList<Integer>(10); 	// Initialized with size 10

-> Advantages of ArrayList over Normal Arrays
	1. Dynamic Size
	2. Rich Library Functions 






Operations on Arrays (Part 2)
----------------------------------------------

-> Time Complexity of Different Operations
	
	1. Insert					: O(n)

	2. Search					: O(n) 		// for unsorted arrays
								: O(logn)	// for sorted arrays

	3. Delete					: O(n)

	4. Get (i)th element 		: O(1)

	5. Update (i)th element 	: O(1) 



-> Note: 
	Insert at the end and delete from the end can be done in O(1) time.











Second Largest Element is Array
---------------------------------------------------------------

1. Naive Solution (Uses two traversals)

	int indexOfSecondLargest(int arr[], int sz)
	{
		int indexOfLargestElement = indexOfLargestElement(arr, sz);

		int indexOfSecondLargestElement = -1;

		for(int i=0; i<n; i++)
		{
			if(arr[i] != arr[indexOfLargestElement])
			{
				if(indexOfSecondLargestElement == -1)
				{
					indexOfSecondLargestElement = i;
				}
				else if(arr[i] > arr[indexOfSecondLargestElement])
				{
					indexOfSecondLargestElement = i;
				}
			}
		}

		return indexOfSecondLargestElement;
	}


1.1. Alternative Algorithm using Naive Approach

	int indexOfSecondLargestElement(int A[], int sz)
	{
	    int indexOfLargestElement = 0;
	    int indexOfSecondLargestElement = -1;
	    
	    int secondLargestElement = INT32_MIN;
	    
	    // Loop to find the index of Largest element
	    for(int i=1; i<sz; i++)
	    {
	        if(A[i] > A[indexOfLargestElement])
	        {
	            indexOfLargestElement = i;
	        }
	    }

	    
	    // Loop to find the index of Second Largest Element
	    for(int i=0; i<sz; i++)
	    {
	        if( (i != indexOfLargestElement) && (A[i]>secondLargestElement) && (A[i]<A[indexOfLargestElement]) )
	        {
	            indexOfSecondLargestElement = i;
	            secondLargestElement = A[indexOfSecondLargestElement];
	        }
	    }

	    
	    return indexOfSecondLargestElement;
	}



2. Efficient Solution (Uses 1 traversal only)

	int indexOfSecondLargestElement(int A[], int sz)
	{
	    int indexOfSecondLargestElement = -1;
	    int indexOfLargestElement = 0;
	    
	    for(int i=0; i<sz; i++)
	    {
	        if(A[i] > A[indexOfLargestElement])
	        {
	            indexOfSecondLargestElement = indexOfLargestElement;
	            indexOfLargestElement = i;
	        }
	        else if(A[i] < A[indexOfLargestElement])
	        {
	            if((indexOfSecondLargestElement == -1) || (A[i] > A[indexOfSecondLargestElement]))
	            {
	                indexOfSecondLargestElement = i;
	            }
	        }
	    }
	    
	    return indexOfSecondLargestElement;
	}


	Time Complexity: 	O(n)
	Space Complexity:	O(1)









Remove Duplicates from a Sorted Array
--------------------------------------------------------------

1. My Solution

	int removeDuplicatesFromSortedArray(int* A, int sz)
	{
	    for(int i=0; i<sz-1; i++)
	    {
	        if(A[i] == A[i+1])
	        {
	            int j = i+1;
	            while(A[j] == A[i])
	            {
	                j++;
	                
	                if(j == sz)
	                {
	                    break;
	                }
	            }
	            
	            int oldSize = sz;
	            sz = sz - (j-i-1);
	            
	            int k = i+1;
	            
	            while(j < oldSize)
	            {
	                A[k] = A[j];
	                
	                k++;
	                j++;
	            }
	        }
	    }
	    
	    return sz;
	}



2. Naive Solution (Using an Auxiliary Array)

	int removeDuplicatesFromSortedArray(int arr[], int oldSize)
	{
		int temp[oldSize];

		temp[0] = arr[0];

		int newSize = 1;

		for(int i=1; i<oldSize; i++)
		{
			if(temp[newSize-1] != arr[i])
			{
				temp[newSize] = arr[i];
				newSize++;
			}
		}

		for(int i=0; i<newSize; i++)
		{
			arr[i] = temp[i];
		}

		return newSize;
	}


	Time Complexity		: O(n)
	Space Complexity	: O(N)




3. Efficient Solution

	int removeDuplicatesFromSortedArray(int arr[], int oldSize)
	{
		int newSize = 1;

		for(int i=1; i<oldSize; i++)
		{
			if(arr[i] != arr[newSize-1])
			{
				arr[newSize] = arr[i];
				newSize++;
			}
		}

		return newSize;
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)








Move All Zeroes to End of Array
---------------------------------------------------------------


1. Naive Solution

	void moveZeroesToEnd(int arr[], int n)
	{
		for(int i=0; i<n; i++)
		{
			if(arr[i] == 0)
			{
				for(int j=i+1; j<n; j++)
				{
					if(arr[j] != 0)
					{
						swap(arr[i], arr[j]);
					}
				}
			}
		}
	}


	Time Complexity:	O(n^2)
	Space Complexity: 	O(1)




2. My Solution (Efficient Solution)

	void swap(int* a, int *b)
	{
	    int *temp;
	    temp = a;
	    a = b;
	    b = a;
	}


	void moveZeroesToEnd(int* A, int sz)
	{
	    int currentIndex = 0;
	    
	    for(int i=0; i<sz; i++)
	    {
	        if(A[i] != 0)
	        {
	            swap(A[currentIndex], A[i]);
	            currentIndex++;
	        }
	    }
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)








Left Rotate an Array by One
---------------------------------------------------------------

-> Algorithm 1

	void leftRotateArrayByOne(int A[], int sz)
	{
	    int temp = A[0];
	    
	    for(int i=0; i<sz-1; i++)
	    {
	        A[i] = A[i+1];
	    }
	    
	    A[sz-1] = temp;
	}




-> Algorithm 2 (Algo 1 is better in comparison to Algo 2)

	void swap(int *A, int *B)
	{
	    int *temp;
	    temp = A;
	    A = B;
	    B = A;
	}

	void leftRotateArrayByOne(int* A, int sz)
	{
	    for(int i=0, j=sz-1; j>i; j--)
	    {
	        swap(A[i], A[j]);
	    }
	}









Left Rotate an Array by D places
------------------------------------------------------

1. Naive Solution

	void leftRotateArrayByOne(int arr[], int sz)
	{
		int temp = arr[0];

		for(int i=1; i<sz; i++)
		{
			arr[i-1] = arr[i];
		}

		arr[sz-1] = temp;
	}


	void leftRotateArrayByD(int arr[], int sz, int D)
	{
		for(int i=0; i<d; i++)
		{
			leftRotateArrayByOne(arr, sz);
		}
	}


	Time Complexity: 	O(n*d)
	Space Complexity: 	O(1)



	1.1 Naive Solution 

		void leftRotateArrayByD(int A[], int sz, int D)
		{
		    while(D > 0)
		    {
		        int temp = A[0];
		        
		        for(int i=1; i<sz; i++)
		        {
		            A[i-1] = A[i];
		        }
		        
		        A[sz-1] = temp;
		        
		        D--;
		    }
		}







2. Algorithm 2 (More efficient solution)

	void leftRotateArrayByD(int arr[], int n, int D)
	{
		int temp[D];

		for(int i=0; i<D; i++)
		{
			temp[i] = arr[i];
		}

		for(int i=D; i<n; i++)
		{
			arr[i-D] = arr[i];
		}

		for(int i=0; i<D; i++)
		{
			arr[n-D+i] = temp[i];
		}
	}


	Time Complexity: 	O(n)
	Space Complexity:	O(D)





	2.2 Algorithm 2

		void leftRotateArrayByD(int A[], int sz, int D)
		{
		    int temp[D];
		    
		    for(int i=0; i<D; i++)
		    {
		        temp[i] = A[i];
		    }
		    
		    int i = 0;
		    for(int j=D; j<sz; i++, j++)
		    {
		        A[i] = A[j];
		    }
		    
		    for(int j=0; j<D; j++, i++)
		    {
		        A[i] = temp[j];
		    }
		}






3. Algorithm 3 (Most Efficient solution)

	// this function reverses the array element b/w the indexes "low" and "high" (including the elements)
	void reverse(int arr[], int low, int high)
	{
		while(low < high)
		{
			swap(arr[low], arr[high]);
			low++;
			high--;
		}
	}


	void leftRotateArrayByD(int arr[], int n, int d)
	{
		reverse(arr, 0, d-1);	// 1. reverse the 1st "d" elements
		reverse(arr, d, n-1);	// 2. then reverse the rest elements
		reverse(arr, 0, n-1);	// 3. At last, reverse the entire array.
	}


	Time Complexity: 	O(n)
	Space Complexity: 	O(1)










Leaders in an Array problem
----------------------------------------------------------------

-> An element of Array is called a leader if there is no element
	 greater than or equal to itself to the right of it


-> Right Most element of the Array is always a leader


-> If the array is sorted in Ascending order, then the last element is the only leader.


-> If the array is reverse sorted, then all elements of the array are leader.



1. Naive Solution

	vector<int> findLeadersInArray(vector<int> vec)
	{
	    vector<int> res;
	    
	    for(int i=0; i<vec.size(); i++)
	    {
	        bool flag = true;
	        for(int j=i+1; j<vec.size(); j++)
	        {
	            if(vec[j] >= vec[i])
	            {
	                flag = false;
	                break;
	            }
	        }
	        
	        if(flag == true)
	        {
	            res.push_back(vec[i]);
	        }
	    }
	    
	    return res;
	}


	Time Complexity:	O(n^2)





2. Efficient Solution

	vector<int> findLeaders(vector<int> vec)
	{
	    vector<int> res;
	    
	    for(int i=0; i<vec.size(); i++)
	    {
	        bool flag = true;
	        for(int j=i+1; j<vec.size(); j++)
	        {
	            if(vec[j] >= vec[i])
	            {
	                flag = false;
	                break;
	            }
	        }
	        
	        if(flag == true)
	        {
	            res.push_back(vec[i]);
	        }
	    }
	    
	    return res;
	}


	Time Complexity: 	O(n)









Maximum Difference Problem with Order
-------------------------------------------------------------------

1. Naive Solution

	int maximumDifference(int arr[], int sz)
	{
	    int maxDifference = INT32_MIN;
	    
	    for(int i=0; i<sz-1; i++)
	    {
	        for(int j=i+1; j<sz; j++)
	        {
	            if((arr[j]-arr[i]) > maxDifference)
	            {
	                maxDifference = arr[j] - arr[i];
	            }
	        }
	    }
	    
	    return maxDifference;
	}


	Time Complexity:	O(n^2)
	Space Complexity:	O(1)



2. Efficient Solution

	int maxDifference(int arr[], int sz)
	{
		int res = arr[1] - arr[0];

		int currentMinimum = arr[0];

		for(int j=1; j<sz; j++)
		{
			res = max(res, arr[j]-currentMinimum);

			currentMinimum = min(currentMinimum, arr[j]);
		}

		return result;
	}


	Time Complexity:	O(n)
	Space Complexity: 	O(1)











Frequencies in a Sorted Array
------------------------------------------------------------------

1. My Solution

	vector<int> elementFrequencies(vector<int> arr)
	{
	    vector<int> res;
	    int currentElement = arr[0];
	    int currentCount = 0;
	    
	    for(int i=0; i<arr.size(); i++)
	    {
	        if(arr[i] != currentElement)
	        {
	            res.push_back(currentCount);
	            currentCount = 1;
	            currentElement = arr[i];
	        }
	        else
	        {
	            currentCount++;
	        }
	    }
	    
	    res.push_back(currentCount);
	    
	    return res;
	}





2. Psuedo Code

	void printFreq(int arr[], int n)
	{
		int freq = 1;
		int i = 1;

		while(i<n)
		{
			while((i<n) && (arr[i]==arr[i-1]))
			{
				freq++;
				i++;
			}

			print(arr[i-1] + " " + freq);
			i++;
			freq = 1;
		}

		if((n==1) || (arr[n-1] != arr[n-2]))
		{
			print(arr[n-1] + " " + 1);
		}
	}


	Time Complexity: 	O(n)










Stock Buy and Sell Problem (Part 1)
----------------------------------------------------------------


1. Naive Solution

	int maxProfit(int price[], int start, int end)
	{
		if(end <= start)
		{
			return 0;
		}

		int profit = 0;

		for(int i=start; i<end; i++)
		{
			for(int j=i+1; j<=end; j++)
			{
				if(price[j] > price[i])
				{
					int currentProfit = (price[j] - price[i]) + maxProfit(price, start, i-1) + maxProfit(price, j+1, end);

					profit = max(profit, currentProfit);
				}
			}
		}

		return profit;
	}




Stock Buy and Sell Problem (Part 2)
----------------------------------------------------------------

-> The idea is to Buy the stock at every bottom point and 
	Sell the stock at each top point


2. Efficient Solution

	int maxProfit(int price[], int n)
	{
		int profit = 0;

		for(int i=1; i<n; i++)
		{
			if(price[i] > price[i-1])
			{
				profit = profit + (price[i] - price[i-1]);
			}
		}

		return profit;
	}










Trapping Rain Water
---------------------------------------

-> Popular Interview Problem


-> If the array is "sorted" or "reverse sorted" then amount of rain water collected will be 0



1. Naive Solution

	int getWater(int arr[], int n)
	{
		int res = 0;

		for(int i=1; i<n-1; i++)
		{
			int leftMax = arr[i];

			for(int j=0; j<i; j++)
			{
				leftMax = max(leftMax, arr[j]);
			}

			int rightMax = arr[i];

			for(int j=i+1; j<n; j++)
			{
				rightMax = max(rightMax, arr[j]);
			}

			res = res + ( min(leftMax, rightMax) - arr[i] );
		}

		return res;
	}


	Time Complexity:	O(n^2)
	Space Complexity: 	O(1)



2. Efficient Solution

	-> The idea for Efficient Solution is that, pre-compute the leftMax and rightMax,
		rather that computing it for every index.


		int getWater(int arr[], int n)
		{
			int res = 0;
			int leftMax[n];
			int rightMax[n];

			// building leftMax Array
			leftMax[0] = arr[0];
			for(int i=1; i<n; i++)
			{
				leftMax[i] = max( arr[i], leftMax[i-1] );
			}


			// building rightMax Array
			rightMax[n-1] = arr[n-1];
			for(int i=n-2; i>=0; i--)
			{
				rightMax[i] = max( arr[i], rithtMax[i+1] );
			}


			// finding the result
			for(int i=1; i<n-1; i++)
			{
				res += min(leftMax[i], rightMax[i]) - arr[i];
			}

			return res;
		}


		Time Complexity:	O(n)
		Space Complexity: 	O(n)













Maximum Subarray sum
----------------------------------------------------------

-> If all the elements of the Array are positive, then the
	output is sum of all elements.


-> If all the elements of the Array are negative, then the 
	output is the largest element of the Array.


1. Naive Solution

	int maxSumSubArray(int arr[], int sz)
	{
		int res = arr[0];

		for(int i=0; i<sz; i++)
		{
			int currentSum = 0;

			for(int j=i; j<sz; j++)
			{
				currentSum += arr[i];
				
				res = max(res, currentSum);
			}
		}

		return sum;
	}


	Time Complexity:	O(n^2)
	Space Complexity: 	O(1)




2. Efficient Solution (Kadane's Algorithm)

	Idea: We traverse the element from left to right and for every element we find the maximum sum
			of subarray that must end with this element.


	-> maxEnding(i) = max( maxEnding(i-1)+arr[i], arr[i] );

	-> For each element we have two options
		1. Either extend the previous subarray -> maxEnding(i-1)+arr[i]
		2. Or, start a new subarray -> arr[i]


	void maxSumSubArray(int arr[], int n)
	{
		int res = arr[0];

		int maxEnding = arr[0];

		for(int i=1; i<n; i++)
		{
			maxEnding = max(maxEnding+arr[i], arr[i]);

			res = max(res, maxEnding);
		}

		return res;
	}











Longest Even Odd Subarray
---------------------------------------------------------

1. My Solution

	bool isOdd(int n)
	{
	    return n&1;
	}

	int maxEvenOddSubArrayLength(vector<int> arr)
	{
	    int sz = arr.size();
	    int res = 0;
	    
	    for(int i=1; i<sz; i++)
	    {
	        int count = 1;
	        
	        for(int j=i; j<sz; j++)
	        {
	            if(isOdd(arr[j]) ^ isOdd(arr[j-1]))
	            {
	                count++;
	            }
	            else
	            {
	                res = max(res, count);
	                break;
	            }
	        }
	        
	        res = max(res, count);
	    }
	    
	    return res;
	}


	Time Complexity:	O(n^2)
	Space Complexity: 	O(1)



2. Naive Solution

	int maxEvenOddSubArrayLengthe(int arr[], int n)
	{
		int res = 1;

		for(int i=0; i<n; i++)
		{
			int curr = 1;

			for(int j=i+1; j<n; j++)
			{
				bool condition_1 = (arr[j]%2 == 0) && (arr[j-1]%2 != 0);
				bool condition_2 = (arr[j]%2 != 0) && (arr[j-1]%2 == 0);

				if(condition_1 || condition_2)
				{
					curr++;
				}
				else
				{
					break;
				}
			}

			res = max(res, curr);
		}

		return res;
	}


	Time Complexity:	O(n^2)
	Space Complexity: 	O(1)



3. Efficient Solution(based on Kadane's Algorithm)

	-> Here we will be finding SubArrays ending with ith element, 
		when we are at index i

	-> For every element there are two cases
		a. Either you begin a new subarray OR
		b. you extend the previous subarray

	-> Here, we extend the previous subarray, if current element is 
	   alternating(in terms of even-odd) with the previous element.
			And if it's not Alternating, then we will have to begin a 
			new subarray.



	int maxEvenOddSubArrayLength(int arr[], int n)
	{
		int res = 1;
		int curr = 1;

		for(int i=1; i<n; i++)
		{
			bool condition_1 = (arr[i]%2 == 0) && (arr[i-1]%2 != 0);
			bool condition_2 = (arr[i]%2 != 0) && (arr[i-1]%2 == 0);

			if(condition_1 || condition_2)
			{
				curr++;
				res = max(res, curr);
			}
			else
			{
				curr = 1;
			}
		}

		return res;
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)










Maximum Circular Sum Subarray
----------------------------------------------------------

	-> Circular Subarray = Normal Subarrays + Only Circular Subarrays

	-> Idea: We will consider every element as the beginning element, and find out the
				maximum sum that can be obtained by considering this as beginning element.


1. Naive Solution

	int maxSumCircularSubArray(int arr[], int n)
	{
		int res = arr[0];

		for(int i=0; i<n; i++)
		{
			int curr_max = arr[i];
			int curr_sum = arr[i];

			for(int j=1; j<n; j++)
			{
				int index = (i+j)%n;

				curr_sum += arr[index];

				curr_max = max(curr_max, curr_sum);
			}

			res = max(res, curr_max);
		}

		return res;
	}


	Time Complexity:	O(n^2)
	Space Complexity:	O(1)



2. Efficient Solution

	-> Idea: Take the maximum of the following two
		a. Maximum Sum of a Normal Subarray (Can be found using Kadane's Algorithm in O(n) time)

		b. Maximum Sum of a Circular Subarray (It can also be found using Kadane's Algorithm)
			-> We can find out this by finding out minimum Sum Subarray in the Normal Subarray using 
				Modified Kadane's Algorithm and subtract this sum from the overall Array Sum

			-> Maximum Only Circular Subarray Sum = Total Array Sum - Minimum Normal Subarray Sum


		// Kadane's algorithm to find max sum of a subarray
		int maxSumNormalSubArray(int arr[], int n)
		{
			int res = arr[0];
			int maxEnding = arr[0];

			for(int i=1; i<n; i++)
			{
				maxEnding = max(arr[i], maxEnding+arr[i]);
				res = max(res, maxEnding);
			}

			return res;
		}


		int overAllMaxSumCircularSubArray(int arr[], int n)
		{
			int max_normal = maxSumNormalSubArray(arr, n);

			// Reason for this if block?
			// If max_normal is less than 0, it means than all the elements in Array are negative
			// So, we can simply return the max_normal

			if(max_normal < 0)
			{
				return max_normal;
			}



			int arr_sum = 0;

			for(int i=0; i<n; i++)
			{
				arr_sum += arr[i];
				arr[i] = -arr[i];
			}

			int max_circular = arr_sum + maxSumNormalSubArray(arr, n);

			return max(max_normal, max_circular);
		}


		Time Complexity:	O(n)
		Space Complexity: 	O(1)











Majority Element
------------------------------------------

-> An element in an Array is called "Majority" if it appears more than "n/2" times
	in the array, where "n" is the size of the array.

	Ex: If you have an array of size 5, then the majority elements should appear 
		at least 3 times.

	Ex: If you have an array of size 6, then the majority elements should appear 
		at least 4 times.



1. My Naive Solution

	int indexOfMajorityElement(int arr[], int n)
	{
	    int threshold = (n/2);
	    int index = -1;
	    
	    for(int i=0; i<n; i++)
	    {
	        int count = 1;
	        for(int j=i+1; j<n; j++)
	        {
	            if(arr[j] == arr[i])
	            {
	                count++;
	            }
	        }
	        
	        if(count > threshold)
	        {
	            index = i;
	        }
	    }
	    
	    return index;
	}


	Time Complexity:	O(n^2)
	Space Complexity:	O(1)



2. Naive Solution

	int findMajority(int arr[], int n)
	{
		for(int i=0; i<n; i++)
		{
			int count = 1

			for(int j=i+1; j<n; j++)
			{
				if(arr[i] == arr[j])
				{
					count++;
				}
			}

			if(count > n/2)
			{
				return i;
			}
		}

		return -1;
	}



3. Efficient Solution

	->  Boyer-Moore voting algorithm / Boyer-Moore Majority Voting Algorithm

	-> This Algorithm works in two phases
		a. 1st phase finds out a candidate and the 1st phase guarantees that
			if there is a majority element in the Array, then this candidate 
			is going to be the majority element.

		b. The 2nd phase checks whether the candidate found out by the 1st phase
			is actually a majority or not.


	Note:
		This algorithm may not always give the index of the 1st occurrence of the
		majority element.


	int indexOfMajorityElement(int arr[], int n)
	{	
		// 1st phase -> finds a possible candidate of majority element
		int res = 0;
		int count = 1;

		for(int i=1; i<n; i++)
		{
			if(arr[res] == arr[i])
			{
				count++;
			}
			else
			{
				count--;
			}

			if(count == 0)
			{
				res = i;
				count = 1;
			}
		}


		// 2nd phase -> checks if the candidate is actually a majority element
		count = 0;

		for(int i=0; i<n; i++)
		{
			if(arr[res] == arr[i])
			{
				count++;
			}
		}

		if(count <= n/2)
		{
			res = -1;
		}

		return res;
	}


	Time Complexity: 	O(n)
	Space Complexity:	O(1)










Minimum Consecutive Flips
-------------------------------------------------

1. My Solution (O(n))

	void minimumNumberOfFlips(int arr[], int n)
	{
	    int flipCountOfOne = 0;
	    int flipCountOfZero = 0;
	    
	    // 1st counting the flips required for making 0
	    for(int i=0; i<n; i++)
	    {
	        bool flag = false;
	        while(arr[i] == 1)
	        {
	            flag = true;
	            i++;
	        }
	        
	        if(flag == true)
	            flipCountOfOne++;
	    }
	    
	    // Now counting the flips required for making 1
	    for(int i=0; i<n; i++)
	    {
	        bool flag = false;
	        while(arr[i] == 0)
	        {
	            flag = true;
	            i++;
	        }
	        
	        if(flag == true)
	            flipCountOfZero++;
	    }
	    
	    int targetBit = (flipCountOfZero>flipCountOfOne ? 1 : 0);
	    
	    for(int i=0; i<n; i++)
	    {
	        if(arr[i] == targetBit)
	        {
	            cout<<i<<" ";
	        }
	    }
	    
	}



2. Naive Solution

	// Write the logic by yourself



3. Efficient Solution

	void printGroups(bool arr[], int n)
	{
		for(int i=1; i<n; i++)
		{
			if(arr[i] != arr[i-1])
			{
				if(arr[i] != arr[0])
				{
					cout<<"From "<<i<<" to ";
				}
				else
				{
					cout<<(i-1)<<endl;
				}
			}
		}

		if(arr[n-1] != arr[0])
		{
			cout<<(n-1)<<endl;
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)	 












Sliding Window Technique
--------------------------------------------------------------

-> To Find the maximum sum of k consecutive elements


1. Naive Solution

	int maxSumOfSubArraySizeK(int arr[], int n, int k)
	{
		int res = INT_MIN;		// INT32_MIN	// Integer.MIN_VALUE in Java

		for(int i=0; i+k-1 < n; i++) 
		{
			int curr = 0;

			for(int j=0; j<k; j++)
			{
				curr += arr[i+j];
			}

			res = max(res, curr);		// Math.max() in Java
		}

		return res;
	}



	Time Complexity:	O(n*k)
	Space Complexity:	O(1)



2. Efficient Solution (Sliding Window technique)

	-> Idea is to compute sum of current window using Sum of Previous
		Window in O(1) time.


	Program 1:

		int maxSumOfSubArraySizeK(int arr[], int n, int k)
		{
			int res = 0;

			for(int i=0; i<k; i++)
			{
				res += arr[i];
			}

			int curretnSum = res;

			for(int i=0; i < n-k; i++)
			{
				currentSum = currentSum - arr[i] + arr[i+k];

				res = max(res, currentSum);
			}

			return res;
		}


	Program 2:

		int maxKSum(int arr[], int n, int k)
		{
			int curr = 0;

			for(int i=0; i<k; i++)
			{
				curr += arr[i];
			}

			int res = curr;

			for(int i=k; i<n; i++)
			{
				curr = curr + arr[i] - arr[i-k];

				res = max(res, curr);
			}

			return res;
		}


		Time Complexity:	O(n)
		Space Complexity:	O(1)












Subarray with Given Sum
--------------------------------------------------------------

1. My Solution / Naive Solution

	bool subArrayExistWithGivenSum(int arr[], int sz, int sum)
	{
	    for(int i=0; i<sz; i++)
	    {
	        int currentSum = 0;
	        
	        for(int j=i; j<sz; j++)
	        {
	            currentSum += arr[j];
	            
	            if(currentSum == sum)
	            {
	                return true;
	            }
	        }
	    }
	    
	    return false;
	}


	Time Complexity:	O(n^2)
	Space Complexity:	O(1)



2. Efficient Solution

	-> Idea: We use Window Sliding Technique with a window of variable size


	bool subArrayExistWithGivenSum(int arr[], int n, int sum)
	{
		int start = 0;
		int currentSum = 0;

		for(int end=0; end<n; end++)
		{
			currentSum += arr[e];

			while(sum > currentSum)
			{
				sum -= arr[start];
				start++;
			}

			if(currentSum == sum)
			{
				return true;
			}
		}

		return false;
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)









Prefix Sum Technique (part-1)
-----------------------------------------------------------------

-> Programming Technique

	int prefix_sum[n];

	void prefixSum(int arr[], int n)
	{
		prefix_sum[0] = arr[0];

		for(int i=1; i<n; i++)
		{
			prefix_sum[i] = prefix_sum[i-1] + arr[i];
		}
	}

	int getSum(int prefix_sum[], int l, int r)
	{
		if(l == 0)
		{
			return prefix_sum[r];
		}
		else
		{
			return prefix_sum[r] - prefix_sum[l-1];
		}
	}




Q2. Given an Array of integer, find if it has an equilibrium point

	I/P: arr = [3, 4, 8, -9, 20, 6]
	O/P: Yes 	// Equilibrium point is 20

	I/P: arr = [4, 2, -2]
	O/P: Yes 	// Equilibrium point is 4 	// Sum of elements before 4 is assumed to be 0

	I/P: arr = [2, -2, 4]
	O/P: Yes 	// Equilibrium point is 4 	// Sum of elements after 4 is assumed to be 0

	I/P: arr = [4, 2, 2]
	O/P: No 	// No Equilibrium point



	bool hasEquilibriumPoint(int arr[], int n)
	{
		int sum = 0;

		for(int i=0; i<n; i++)
		{
			sum += arr[i];
		}

		int leftSum = 0;

		for(int i=0; i<n; i+=)
		{
			if( leftSum == (sum - arr[i]) )
			{
				return true;
			}

			leftSum += arr[i];
			sum -= arr[i];
		}

		return false;
	}











Prefix Sum Technique (Part 2)
--------------------------------------------------------------------

[Watch Later]

Q. Given n ranges, find the maximum appearing element in these ranges.

	I/P: L[] = {1, 2, 5, 15}
		 R[] = {5, 8, 7, 18}

	O/P: 5


-> If some constraint is given like:	0 <= L[i], R[i] < 1000
	
	
	int maxOccurance(int L[], int R[], int n)
	{
		vector<int> arr[1000];

		for(int i=0; i<n; i++)
		{
			arr[L[i]]++;
			arr[R[i]]--;
		}

		int max = arr[0];
		int res = 0;

		// doing the prefix sum of array
		for(int i=1; i<1000; i++)
		{
			arr[i] += arr[i-1];

			if(max < arr[i])
			{
				max = arr[i];
				res = i;
			}
		}

		return res;
	}




-> Homework Questions based on Prefix Sum

	1. Check if a given array can be divided into three parts with equal sum

	2. Check if there is a subarray with 0 sum

	3. Find the longest Subarray with equal number of zeroes(0s) and Ones(1s)














































































#########################################################
6. Searching
#########################################################


Binary Search (Iterative)
-------------------------------------------------------

1. My Solution
		
	int indexOfElement(int arr[], int n, int x)
	{
	    int low = 0;
	    int high = n-1;
	    
	    int mid = (low+high)/2;
	    
	    while(low <= high)
	    {
	        if(x == arr[mid])
	        {
	            return mid;
	        }
	        else if(x > arr[mid])
	        {
	            low = mid+1;
	        }
	        else
	        {
	            high = mid-1;
	        }
	        
	        mid = (low+high)/2;
	    }
	    
	    return -1;
	}



2. Binary Search

	int binarySearchIterative(int arr[], int sz, int x)
	{
		int low = 0;
		int high = 0;

		while(low <= high)
		{
			int mid = (low+high)/2;

			if(arr[mid] == x)
				return mid;
			else if(arr[mid] > x)
				high = mid-1;
			else
				low = mid+1;
		}

		return -1;
	}


	Time Complexity:	O(logN)
	Space Complexity:	O(1)










Binary Search (Recursive)
---------------------------------------------------------

1. Recursive Solution

	int binarySearchRecursive(int arr[], int low, int high, int x)
	{
		if(low > high)
			return -1;

		int mid = (low+high)/2;

		if(arr[mid] == x)
			return mid;
		else if(arr[mid] > x)
			return binarySearchRecursive(arr, low, mid-1, x);
		else
			return binarySearchRecursive(arr, mid+1, high, x);
	}


	Time Complexity:	O(logN)
	Space Complexity: 	O(logN)









Index of First Occurrence in Sorted Array
----------------------------------------------------------

1. Naive Solution

	int firstOccurenceOfAnElement (int arr[], int n, int x)
	{
	    for(int i=0; i<n; i++)
	    {
	        if(arr[i] == x)
	        {
	            return i;
	        }
	    }
	    
	    return -1;
	}


	Time Complexity:	O(n)
	Space Complexity: 	O(1)



2. Efficient Solution using Recursion

	int firstOccurenceOfAnElementUsingRecursion(int arr[], int low, int high, int x)
	{
		if(low > high)
		{
			return -1;
		}

		int mid = (low+high)/2;

		if(x > arr[mid])
		{
			return firstOccurenceOfAnElementUsingRecursion(arr, mid+1, high, x);
		}
		else if(x < arr[mid])
		{
			return firstOccurenceOfAnElementUsingRecursion(arr, low, mid-1, x);
		}
		else
		{
			if((mid == 0) || (arr[mid-1] != arr[mid]))
			{
				return mid;
			}
			else
			{
				return firstOccurenceOfAnElementUsingRecursion(arr, low, mid-1, x);
			}
		}
	}


	Time Complexity:	O(logN)
	Space Complexity: 	O(logN)



3. Efficient Solution using Iteration (Most Efficient)

	int firstOccurenceUsingIteration(int arr[], int sz, int x)
	{
	    int low = 0;
	    int high = sz-1;
	    
	    while(low <= high)
	    {
	        int mid = (low+high)/2;
	        
	        if(x < arr[mid])
	        {
	            high = mid-1;
	        }
	        else if(x > arr[mid])
	        {
	            low = mid+1;
	        }
	        else
	        {
	            if( (mid==0) || (x != arr[mid-1]) )
	            {
	                return mid;
	            }
	            else
	            {
	                high = mid-1;
	            }
	        }
	        
	    }
	    
	    return -1;
	}


	Time Complexity:	O(logN)
	Space Complexity: 	O(1)












4. Index of Last Occurrence in Sorted Array
----------------------------------------------------------

1. Naive Solution

	int lastOccurenceOfAnElement (int arr[], int n, int x)
	{
	    for(int i=n-1; i>=0; i--)
	    {
	        if(arr[i] == x)
	        {
	            return i;
	        }
	    }
	    
	    return -1;
	}


	Time Complexity:	O(n)
	Space Complexity: 	O(1)



2. Efficient Solution using Recursion

	int lastOccurenceOfAnElementUsingRecursion(int arr[], int low, int high, int x, int n)
	{
		if(low > high)
		{
			return -1;
		}

		int mid = (low+high)/2;

		if(x > arr[mid])
		{
			return lastOccurenceOfAnElementUsingRecursion(arr, mid+1, high, x, n);
		}
		else if(x < arr[mid])
		{
			return lastOccurenceOfAnElementUsingRecursion(arr, low, mid-1, x, n);
		}
		else
		{
			if((mid == n-1) || (arr[mid+1] != arr[mid]))
			{
				return mid;
			}
			else
			{
				return lastOccurenceOfAnElementUsingRecursion(arr, mid+1, high, x, n);
			}
		}
	}


	Time Complexity:	O(logN)
	Space Complexity: 	O(logN)



3. Efficient Solution using Iteration (Most Efficient)

	int lastOccurenceUsingIteration(int arr[], int sz, int x)
	{
	    int low = 0;
	    int high = sz-1;
	    
	    while(low <= high)
	    {
	        int mid = (low+high)/2;
	        
	        if(x < arr[mid])
	        {
	            high = mid-1;
	        }
	        else if(x > arr[mid])
	        {
	            low = mid+1;
	        }
	        else
	        {
	            if( (mid == n-1) || (x != arr[mid+1]) )
	            {
	                return mid;
	            }
	            else
	            {
	                low = mid+1;
	            }
	        }
	        
	    }
	    
	    return -1;
	}


	Time Complexity:	O(logN)
	Space Complexity: 	O(1)











Count Occurrences in Sorted Array
-------------------------------------------------------------

1. Efficient Solution

	int firstOccurrence(int arr[], int sz, int x) 
	{
	    int low = 0;
	    int high = sz-1;
	    
	    while(low <= high) {
	        int mid = (low+high)/2;
	        
	        if(x < arr[mid])
	        	high = mid-1;
	        else if(x > arr[mid])
	        	low = mid+1;
	        else {
	            if( (mid == 0) || (x != arr[mid-1]) )
	            	return mid;
	            else
	            	high = mid-1;
	        }
	        
	    }	    
	    return -1;
	}


	int lastOccurrence(int arr[], int sz, int x) 
	{
	    int low = 0;
	    int high = sz-1;
	    
	    while(low <= high) {
	        int mid = (low+high)/2;
	        
	        if(x < arr[mid])
	        	high = mid-1;
	        else if(x > arr[mid])
	        	low = mid+1;
	        else {
	            if( (mid == n-1) || (x != arr[mid+1]) )
	            	return mid;
	            else
	            	low = mid+1;
	        }
	        
	    }	    
	    return -1;
	}


	int countOccurrence(int arr[], int sz, int x)
	{
		int indexOfFirstOccurrence = firstOccurrence(arr, sz, x);

		if(indexOfFirstOccurrence == -1)
		{
			return 0;
		}
		else
		{
			int indexOfLastOccurrence = lastOccurrence(arr, sz, x);

			return (indexOfLastOccurrence - indexOfFirstOccurrence + 1);
		}
	}


	Time Complexity:	O(logN)
	Space Complexity: 	O(1)










Count 1's in a Sorted Binary Array
----------------------------------------------------------------

1. Efficient Solution

	int countOnes(int arr[], int n)
	{
		int low = 0;
		int high = n-1;

		int indexOfFirstOccurrenceOfOne;

		while(low <= high)
		{
			int mid = (low+high)/2;

			if(arr[mid] == 0)
			{
				low = mid+1;
			}
			else
			{
				if( (mid == 0) || (arr[mid-1] == 0) )
				{
					indexOfFirstOccurrenceOfOne = mid;

					return (n - indexOfFirstOccurrenceOfOne);
				}
				else
				{
					high = mid-1;
				}
			}
		}

		return 0;
	}


	Time Complexity:	O(logN)
	Space Complexity: 	O(1)













Square Root
------------------------------------------------------------------

1. Naive Solution

	int squareRootFloor(int x)
	{
		int i=1;

		while(i*i <= x)
		{
			i++;
		}

		return i-1;
	}


	Time Complexity: 	O(N^0.5)
	Space Complexity:	O(1)




2. Efficient Solution

	int squareRootFloor(int x)
	{
		int low = 1;
		int high = x;

		int ans = -1;

		while(low <= high)
		{
			int mid = (low+high)/2;
			int midSquare = mid*mid;

			if(midSquare == x)
			{
				ans = mid;
				return ans;
			}
			else if(midSquare > x)
			{
				// then search on left side
				high = mid-1;
			}
			else
			{
				// search on right side
				ans = mid;
				low = mid+1;
			}
		}

		return ans;
	}


	Time Complexity: 	O(logN)
	Space Complexity:	O(1)
















Search in Infinite Sized Array
-----------------------------------------------------------------

-> Search an element in an Infinite Sized Sorted Array

1. Naive Solution
	
	int search(int arr[], int x)
	{
		int i=0;

		while(true)
		{
			if(arr[i] == x)
				return i;

			if(arr[i] > x)
				return -1;

			i++;
		}
	}


	Time Complexity: 	O(position)
	Space Complexity:	O(1)



2. Efficient Solution (Unbounded Binary Search Algorithm)

	int search(int arr[], int x)
	{
		if(arr[0] == x)
			return x;

		int i=1;

		while(arr[i] < x)
		{
			i = i*2;
		}

		if(arr[i] == x)
			return i;

		return binarySearch(arr, i/2 + 1, i-1, x);
	}


	Time Complexity:	O(log(pos))		// pos: position where the element should be
	Space Complexity:	O(1)














Search in a Sorted Rotated Array
---------------------------------------------------------------

-> When we have a Sorted and Rotated Array then it is always guaranteed that 
	one half of this array will always be sorted.


1. Efficient Solution Using Recursion

	int searchInSortedAndRotatedArray(int arr[], int low, int high, int x)
	{
	    if(low > high)
	    {
	        return -1;
	    }
	    
	    int mid = (low+high)/2;
	    
	    if(arr[mid] == x)
	    {
	        return mid;
	    }
	    else
	    {
	        // check if left half is sorted or not 
	        if(arr[low] < arr[mid])
	        {
	            if(x >= arr[low] && x <= arr[mid-1])
	            {
	                return searchInSortedAndRotatedArray(arr, low, mid-1, x);
	            }
	            else
	            {
	                return searchInSortedAndRotatedArray(arr, mid+1, high, x);
	            }
	        }
	        else
	        {
	            // It means right half is sorted
	            if(x >= arr[mid+1] && x <= arr[high])
	            {
	                return searchInSortedAndRotatedArray(arr, mid+1, high, x);
	            }
	            else
	            {
	                return searchInSortedAndRotatedArray(arr, low, mid-1, x);
	            }
	        }
	    }
	    
	}



2. Efficient Solution Using Iteration

	int search(int arr[], int n, int x)
	{
		int low = 0, high = n-1;

		while(low <= high)
		{
			int mid = (low+high)/2;

			if(arr[mid] == x)
			{
				return mid;
			}

			// when left side is sorted
			if(arr[low] < arr[mid])
			{
				if((x >= arr[low]) && (x <= arr[mid]))
				{
					high = mid-1;
				}
				else
				{
					low = mid+1;
				}
			}
			else
			{
				if((x > arr[mid]) && (x <= arr[high]))
				{
					low = mid+1;
				}
				else
				{
					high = mid-1;
				}
			}
		}

		return -1;
	}


	Time Complexity:	O(logN)
	Space Complexity:	O(1)













Find a Peak Element
-----------------------------------------------------------------

-> To find a peak element in a Unsorted Array

-> A peak element is an element which is not smaller than its neighbours


I/P: arr[] = {5, 10, 20, 15, 7}
O/P: 20

I/P: arr[] = {80, 70, 90}
O/P: 80 or 90	// for corner cases we need to check only on one side of the element 


1. Naive Solution

	int getPeak(int arr[], int n)
	{
		if(n == 1)
			return arr[0];

		if(arr[0] >= arr[1])
			return arr[0];

		if(arr[n-1] >= arr[n-2])
			return arr[n-1];

		for(int i=1; i<n-1; i++)
		{
			if( arr[i]>=arr[i-1] && arr[i]>=arr[i+1] )
			{
				return arr[i]; 
			}
		}
	}


	Time Complexity: 	O(N)
	Space Complexity: 	O(1)



2. Efficient Solution

	-> We will use binary search

	-> The fact is, if middle element is not Peak element then 
		-> if left element of mid is greater than or equal to mid then there will definately be a 
			Peak element on left half
		->  if right element of mid is greater than or equal to mid then there will definately be a 
			Peak element on right half



	int getPeak(int arr[], int n)
	{
		int low=0, high=n-1;

		while(low <= high)
		{
			int mid = (low+high)/2;

			bool condition1 = (mid == 0) || (arr[mid-1] <= arr[mid]);	// No need to check on left of 1st element
			bool condition2 = (mid == n-1) || (arr[mid+1] <= arr[mid]);	// No need to check on right of last element

			if(condition1 && condition2)
			{
				return mid;
			}

			if( (mid > 0) && (arr[mid-1] >= arr[mid]) )
			{
				high = mid-1;
			}
			else
			{
				low = mid+1;
			}
		}

		return -1;
	}


	Time Complexity: 	O(logN)
	Space Complexity:	O(1)













Two Pointers Approach
----------------------------------------------------------------

-> Example Problem: To check if a sorted array has a pair having sum equals to x

-> Two Pointer technique is best suited when the input Array is Sorted.

-> If we want to use it on Unsorted Array, then we first need to Sort the array
	which will take O(NlogN) time.


1. Naive Solution

	bool isPair(int arr[], int n, int x)
	{
		for(int i=0; i<n-1; i++)
		{
			for(int j=i+1; j<n; j++)
			{
				if(arr[i]+arr[j] == x)
				{
					return true;
				}
			}
		}

		return false;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)



2. Efficient Solution (Using Two Pointer Algorithm/Technique)

	bool isPair(int arr[], int n, int x)
	{
	    int i=0;
	    int j=n-1;
	    while(i<j)
	    {
	        if(arr[i] + arr[j] == x)
	        {
	            return true;
	        }
	        else
	        {
	            if(arr[i] + arr[j] < x)
	                i++;
	            else
	                j--;
	        }
	    }
	    
	    return false;
	}


	Time Complexity: 	O(N)
	Space Complexity:	O(1)












Triplets in a Sorted Array
--------------------------------------------------------------

-> We need to check if there are triplets which sums upto to x in a Sorted Array


1. Naive Solution

	bool isTriplets(int arr[], int n, int x)
	{
		for(int i=0; i<n-2; i++)
			for(int j=i+1; j<n-1; j++)
				for(int k=j+1; k<n; k++)
					if(x == arr[i]+arr[j]+arr[k])
						return true;

		return false;
	} 


	Time Complexity:	O(N^3)
	Space Complexity:	O(1 )	




2. Efficient Solution

	-> Idea for efficient solution
		1. Traverse the array from left to right

		2. For every element arr[i], check if there is a pair on right side
			with sum = x-arr[i]


	bool isPair(int arr[], int n, int x, int startIndex)
	{
		int i = startIndex;
		int j = n-1;

		while(i < j)
		{
			if(arr[i]+arr[j] == x)
			{
				return true;
			}
			else if(arr[i]+arr[j] < x)
			{
				i++;
			}
			else
			{
				j--;
			}
		}

		return false;
	}


	bool isTriplets(int arr[], int n, int x)
	{
		for(int i=0; i < n-2; i++)
		{
			if( isPair(arr, x-arr[i], i+1) )
			{
				return true;
			}
		}

		return false;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)


	-> If the array is Unsorted, then first sort the array and then apply the 
		efficient approach, time complexity will remain same.












Median of Two Sorted Arrays
-----------------------------------------------------------
#Revise
#Repeat
#Incomplete

1. Naive Solution: O( (n1 + n2) * log(n1+n2) )

	a. create an array temp[] of size(n1+n2)
	b. copy elements of a1[] to temp[]
	c. copy elements of a2[] to temp[]
	d. sort temp[]
	e. find median of temp[]

	Note:
		This process can be optimized if we will use merge sort process while
		copying the elements to temp[], which brings the time complexity to O(n1 + n2)




2. Efficient Solution: O(log(n1))

	-> we will use binary search

	-> Assumption: size of a1[] is always smaller than or equal to size of a2[]
					i.e., n1 <= n2


	double getMedian(int a1[], int a2[], int n1, int n2)
	{
		int b1 = 0;
		int e1 = n1;

		while(b1 <= e1)
		{
			int i1 = (b1+e1)/2;
			int i2 = (n1 + n2 + 1)/2 - i1;

			int minr1 = (i1 == n) ? INT_MAX : a1[i1];
			int maxl1 = (i1 == 0) ? INT_MIN : a1[i1 - 1];

			int minr2 = a2[i2];
			int maxl2 = a2[i2 - 1];

			if( (maxl1 <= minr2) && (maxl2 <= minr1) )
			{
				return ( (double) max(maxl1, maxl2) + min(minr1, minr2) )/2;
			}
			else
			{
				return (double) max(maxl1, maxl2);
			}
			else if(maxl1 > minr2)
			{
				e1 = i1 - 1;
			}
			else
			{
				b1 = i1 + 1;
			}
		}
	}














Repeating Element (Part 1)
---------------------------------------------------------------

-> Constraints of the Problem:
	1. Array Size, n >= 2
	2. Only one element repeats (any number of times)
	3. All the elements from 0 to max(arr) are present.

	-> Therefore 0 <= max(arr) <= n-2 


-> Constraints for the Solution
	1. O(n) Time
	2. O(1) Aux Space
	3. Modification of Array is not allowed




1. Super Naive Solution: [O(n^2) Time and O(1) Space]

	for(int i=0; i < n-1; i++)
		for(int j=i+1; j<n; j++)
			if(arr[i] == arr[j])
				return arr[i];


2. Naive Solution: [O(nlogn) Time and O(1) Space]

	-> Sort the Array 	// It modifies the array

	-> for(int i=0; i < n-1; i++)
	   {
	   		if(arr[i] == arr[i+1])
	   			return arr[i];
	   }



3. Efficient Approach: [O(n) Time and O(n) Space]

	-> Create a boolean array of size n and initilize it with "false"
		visited[] = {F, F, F, ....};

	-> for(int i=0; i<n; i++)
	   {
	   		if(visited[arr[i]])
	   			return arr[i];

	   		visited[arr[i]] = true;
	   }










Repeating Element (Part 2)
---------------------------------------------------------------
#Revise
#Repeat

4. Modified Problem Solution
	-> Let's first see the solution of modified problem

	-> Modified Problem:
		1. All Elements are from 1 to max(arr) are present
		2. 1 <= max(arr) <= n-1 

	-> The first element of cycle will always be the repeating element


	int findRepeating(int arr[], int n)
	{
		int slow = arr[0];
		int fast = arr[0];

		do
		{
			slow = arr[slow];			// Speed 1x
			fast = arr[arr[fast]];		// Speed 2x 

		}while(slow != fast)

		slow = arr[0];

		while(slow != fast)
		{
			slow = arr[slow];
			fast = arr[fast];
		}

		return slow;
	}



5. Efficient Solution / Solution to original Problem [O(n) Time and O(1) Space]

	int findRepeating(int arr[], int n)
	{
		int slow = arr[0]+1;
		int fast = arr[0]+1;

		do
		{
			slow = arr[slow]+1;
			fast = arr[arr[fast]]+1;

		}while(slow != fast)

		slow = arr[0]+1;

		while(slow != fast)
		{
			fast = arr[fast]+1;
			slow = arr[slow]+1;
		}

		return slow-1;
	}















Allocate Minimum Pages (Naive Method)
-----------------------------------------------------------------------------

-> Popular Interview Problem

-> Optimal Distribution Problem


Problem Constraints
	-> N is the total number of books
	-> arr[N] contains the number of pages in each book
	-> K is the number of students among whom the pages are to be distributed

	-> Minimize the maximum pages allocated
	-> Only contiguous pages can be allocated





1. Naive Solution

	int minPages(int arr[], int n, int k)
	{
		if(k == 1)
		{
			return sum(arr, 0, n-1);
		}

		if(n == 1)
		{
			return arr[0];
		}

		int res = INT_MAX;

		for(int i=1; i<n; i++)
		{
			res = min( res, max(minPages(arr, i, k-1), sum(arr, i, n-1)) );
		}

		return res;
	}


	// Utility Function -> returns sum of elements of array from index b to index e

	int sum(int arr[], int b, int e)
	{
		int sum = 0;

		for(int i=b; i<=e; i++)
		{
			sum += arr[i];
		}

		return sum;
	}


	Time Complexity: Exponential(e^N)	// Very Slow









Allocate Minimum Pages (Binary Search)
----------------------------------------------------------------------------

-> It can also be solved using Dynamic Programming


2. Efficient Solution (Using Binary Search)

	bool isFeasible(int arr[], int n, int k, int ans)
	{
		int req = 1;
		int sum = 0;

		for(int i=0; i<n; i++)
		{
			if(sum+arr[i] > ans)
			{
				req++;
				sum = arr[i];
			}
			else
			{
				sum += arr[i];
			}
		}

		return (req <= k);
	}



	int minPages(int arr[], int n, int k)
	{
		int sum = 0;
		int mx = 0;

		for(int i=0; i<n; i++)
		{
			sum += arr[i];
			mx = max(mx, arr[i]);
		}

		int low = mx;
		int high = sum;
		int res = 0;

		while(low <= high)
		{
			int mid = (low + high)/2;

			if(isFeasible(arr, n, k, mid))
			{
				// if feasible go the left half
				res = mid;
				high = mid-1;
			}
			else
			{
				// else go to the right half
				low = mid+1;
			}
		}

		return res;
	}


	Time Complexity: 	O(n*log(sum-mx))		// Upperbound: O(n*log(sum))
	Space Complexity: 	O(1)










































































#########################################################
7. Sorting
#########################################################


Sort in C++ STL
------------------------------------------------------------------

-> "sort()" is a general purpose library function for sorting any types of input.
	
-> It is mainly used for sorting data stored in containers, which allow random access.
	
	Example of containers which allow random access: array, vector, deque



-> sort(iterator_to_first_element, iterator_after_the_last_element, Optional_Comparison_function);

-> iterator -> address

-> Example of Sorting on Array:

	#include <iostream>
	#include <algorithm>	// sort function is defined in this library

	using namespace std;

	int main()
	{
		int arr[] = {10, 20, 5, 7};

		sort(arr, arr+n);		// Sorts in increasing order

		sort(arr, arr+n, greater<int>);		// sorts in reverse order
	}



-> Example of Sorting on Vector:

	#include <iostream>
	#include <algorithm>	// sort function is defined in this library

	using namespace std;

	int main()
	{
		vector<int> v = {5, 7, 20, 10};

		sort(v.begin(), v.end());			// sort in default(increasing) order

		sort(v.begin(), v.end(), greater<int>);		// sort in reverse order
	}




-> Example of a program where we can specify our own order for sorting

	#include <iostream>
	#include <algorithm>

	using namespace std;

	struct Point
	{
		int x, y;
	};


	bool myCmp(Point p1, Point p2)
	{
		return (p1.x < p2.x);
	}


	int main()
	{
		Point arr[] = {{3, 10}, {2, 8}, {5, 4}};

		sort(arr, arr+n, myCmp);

		for(auto i: arr)
		{
			cout<< i.x << " " << i.y << endl;
		}
	}





-> Internal Working of sort function
	-> sort() function internally uses quicksort by default.

	-> If quicksort is doing unfair partitioning and going to take more
		than nlog(n) time, it switches to "heap sort"

	-> And if the array size becomes very small, it switches to insertion sort.

	-> Worst Case and Average Case Time Complexity: O(nlog(n))

	-> Number of Comparisons: O(nlog(n))

	-> It internally uses IntroSort(hybrib of QuickSort, HeapSort and InsertionSort)




















Sorting in Java
-----------------------------------------------------------------------

-> In Java sorting is implemented using two classes.
	1. Arrays class  -> sort implementation for normal arrays
		a. Arrays of primitives(int, char, ...)				 -> 	Dual Pivot QuickSort
		b. Arrays of Objects(String, Integer, Student, ...)  -> 	Based on MergeSort, adaptation of TimSort	

	2. Collections class -> sort implementation for Collections
		a. For Lists(ArrayList, LinkedList, ...) 			 ->		Based on MergeSort, adaptation of TimSort 


-> The Collections which are List Interface implementing classes allows sorting.
	-> ArrayList
	-> LinkedList
	-> Vector



-> Algorithms used by Java for Sorting
	1. For primitive data types sorting it uses Unstable Sorting Algorithm
	2. For non-primitives it uses Stable Sorting Algorithm.



-> TimSort is an Algorithm which is used in Python sort functions.

-> QuickSort by default does not ensures stability and MergeSort by default ensures stability.



















Arrays.sort in Java
--------------------------------------------------------------------------

-> Arrays.sort() is used to sort normal Arrays


-> Example 1:
	
	import java.util.Arrays;

	public class Test
	{
		public static void main(String[] args)
		{
			int arr1[] = {5, 20, 12, 30};

			char arr2[] = {'B', 'B', 'A', 'C', 'A'};

			Arrays.sort(arr1);		// arr1[] = {5, 12, 20, 30}

			Arrays.sort(arr2);		// arr2[] = {'A', 'A', 'B', 'B', 'C'}
		}
	}



-> Arrays.sort() when used for sorting primitive types, it doesn't allow to use custom comparator.
	We can only sort primitive types in natural order or increasing order, i.e., non-decreasing order.



-> Arrays.sort() can also be used for sorting subarray of an array.
	Arrays.sort(arr, start, end);	// start index is included and end index is excluded

-> Example 2:

	public static void main(String args[])
	{
		int arr[] = {5, 30, 20, 10, 8};

		Arrays.sort(arr, 1, 4);		// arr[] = {5, 10, 20, 30, 8}
									// sorts the array elements from index 1 to index 3
	}





-> Example 3: sorting of Array of Non-Primitive types

	class Point implements Comparable<Point>
	{
		int x, y;

		Point(int x, int y)
		{
			this.x = x;
			this.y = y;
		}

		public int compareTo(Point p)
		{
			return this.x - p.x;
		}
	}


	class Test
	{
		public static void main(String args[])
		{
			Point arr[] = {new Point(10, 20), new Point(3, 12), new Point(5, 7)};

			Arrays.sort(arr);		// arr[] = {{3, 12}, {5, 7}, {10, 20}}
		}
	}






-> Example 4: Sorting an Array of non-primitives which doesn't implements Comparable

	class Point 
	{
		int x, y;

		Point(int x, int y)
		{
			this.x = x;
			this.y = y;
		}
	}


	class MyCmp implements Comparator<Point>
	{
		public int compare(Point p1, Point p2)
		{
			return p1.x - p2.x;
		}
	}


	class Test
	{
		public static void main(String args[])
		{
			Point arr[] = {new Point(10, 20), new Point(3, 12), new Point(5, 7)};

			Arrays.sort(arr, new MyCmp());		// arr[] = {{3, 12}, {5, 7}, {10, 20}}
		}
	}





-> Example 5:

	class Test
	{
		public static void main(String args[])
		{
			Integer arr[] = {5, 20, 10, 12};

			Arrays.sort(arr, Collections.reverseOrder());	// arr[] = {20, 12, 10, 5}
		}
	}







-> Example 6: Sorting an Array where all even elements appear on one side and all odd elements on other side

	class MyCmp implements Comparator<Integer>
	{
		public int compare(Integer a, Integer b)
		{
			return a%2 - b%2;
		}
	}


	class Test
	{
		public static void main(String args[])
		{
			Integer arr[] = {5, 20, 10, 3, 12};

			Arrays.sort(arr, new MyCmp());		// arr[] = {20, 10, 12, 5, 3}
		}
	}




























Collections.sort in Java
---------------------------------------------------------------------

-> Used to sort List Collections


1. Example 1:

	class Test
	{
		public static void main(String args[])
		{
			List<Integer> list = new ArrayList<Integer>();

			list.add(10);
			list.add(5);
			list.add(20);

			Collections.sort(list);										// list = [5, 10, 20]

			Collections.sort(list, Collections.reverseOrder());			// list = [20, 10, 5]
		}
	}



-> Wrapper classes implement Comparable interface




2. Example 2: Sorting a list of items of user defined type

	class Point implements Comparable<Point>
	{
		int x,y;

		Point(int x, int y)
		{
			this.x = x;
			this.y = y;
		}


		public int compareTo(Point p)
		{
			return this.x - p.x;
		}
	}


	class Test
	{
		public static void main(String args[])
		{
			List<Integer> list = new ArrayList<Integer>();

			list.add(new Point(5, 10));
			list.add(new Point(2, 20));
			list.add(new Point(10, 30));

			Collection.sort(list);			// list = [{2, 20}, {5, 10}, {10, 30}]
		}
	}





3. Example 3: Sorting using Comparator Interface

	class Point 
	{
		int x, y;

		Point(int x, int y)
		{
			this.x = x;
			this.y = y;
		}
	}


	class MyCmp implements Comparator<Point>
	{
		public int compare(Point p1, Point p2)
		{
			return p1.x - p2.x;
		}
	}


	class Test
	{
		public static void main(String args[])
		{
			List<Integer> list = new ArrayList<Integer>();

			list.add(new Point(5, 10));
			list.add(new Point(2, 20));
			list.add(new Point(10, 30));

			Collections.sort(list, new MyCmp());	// list = [{2, 20}, {5, 10}, {10, 30}]
		}
	}




-> We can not sort the subarray using Collections.sort



















Stability in Sorting Algorithm
------------------------------------------------------------

-> Example of Stable Sorts: Bubble Sort, Insertion Sort, Merge Sort, .....

-> Examples of Unstable Sorts: Selection Sort, Quick Sort, Heap Sort, .....
























Bubble Sort
---------------------------------------------------

-> Simple Comparison based Algorithm

-> Time Complexity: O(N^2)

-> Number of Passes: N-1


1. Algorithm for Bubble Sort

	void bubbleSort(int arr[], int n)
	{
	    for(int pass=1; pass<n; pass++)
	    {
	        for(int i=0; i<n-pass; i++)
	        {
	            if(arr[i] > arr[i+1])
	            {
	                swap(arr[i], arr[i+1]);
	            }
	        }
	    }
	}





2. Algorithm for Bubble Sort

	void bubbleSort(arr, n)
	{
		for(i=0; i<n-1; i++)
		{
			for(int j=0; j<n-1; j++)
			{
				if(arr[j] > arr[j+1])
				{
					swap(arr[j], arr[j+1]);
				}
			}
		}
	}





3. Optimized Algorithm for Bubble Sort

	-> Idea is that, if we are at ith iteration, then i elements are already fixed to their
		last position and they are i largest elements, so they are already sorted.


	void bubbleSort(arr, n)
	{
		for(int i=0; i < n-1; i++)
		{
			for(int j=0; j < n-i-1; j++)
			{
				if(arr[j] > arr[j+1])
				{
					swap(arr[j], arr[j+1]);
				}
			}
		}
	}


	Time Complexity: 	O(N^2)
	Space Complexity: 	O(1)





4. More Optimized Algorithm of Bubble Sort, specially if Array is already Sort

	void bubbleSort(arr, n)
	{
		for(int i=0; i < n-1; i++)
		{
			bool swapped = fasle;

			for(int j=0; j < n-i-1; j++)
			{
				if(arr[j] > arr[j+1])
				{
					swap(arr[j], arr[j+1]);
					swapped = true;
				}
			}

			if(swapped == false)
			{
				break;
			}
		}
	}



-> Bubble Sort is a Stable sorting Algorithm

-> Sorting happens in-place, i.e., it doesn't take any extra space for sorting





















Selection Sort
------------------------------------------------------------------

-> Comparison based Algorithm

-> O(N^2) Time Complexity in all cases

-> The good thing about Selection Sort is, it does less memory writes compared to 
	other Algorithms


-> The most optimal Algorithm in terms of Memory Writes is "Cycle Sort"

-> In EEP ROM, if we do more memory writes, age of this memory reduces. So, in those
	cases we can prefer Selection Sort.


-> This sort is the basic idea for Heap Sort. Heap Sort idea is based on Selection Sort only.
	Heap Sort used heap data-structure to optimize the Selection Sort idea.


-> Not Stable: It is an Unstable Algorithm

-> In-Place: It does take extra space for the modification of the Array.


-> Basic Idea of Selection Sort
	1. If find out the minimum element and put it to 1st position.
	2. Then we find out the 2nd minimum element and put it to 2nd position, and so on...
	3. The last element will automatically get sorted



1. My Solution

	void selectionSort(int arr[], int n)
	{
	    
	    for(int pass=1; pass<=n-1; pass++)
	    {
	        int minimum = INT32_MAX;
	        
	        for(int i=pass-1; i<n; i++)
	        {
	            if(arr[i] < minimum)
	            {
	                minimum = arr[i];
	                swap(arr[pass-1], arr[i]);
	            }
	        }
	    }
	}






2. Naive Solution

	void selectSort(arr, n)
	{
		int temp[n];

		for(int i=0; i<n; i++)
		{
			// i decides the index in temp where we will keep the minimum element

			int min_ind = 0;

			for(int j=1; j<n; j++)
			{
				if(arr[j] < arr[min_ind])
				{
					min_ind = j;
				}
			}

			temp[i] = arr[min_ind];
			arr[mid_ind] = INF;			// INT_MAX
		}

		for(int i=0; i<n; i++)
		{
			arr[i] = temp[i];
		}
	}






3. Algorithm for In-Place Implementation

	void selectSort(arr, n)
	{
		for(int i=0; i<n-1; i++)
		{
			min_ind = i;

			for(int j=i+1; j<n; j++)
			{
				if(arr[j] < arr[min_ind])
				{
					min_ind = j;
				}
			}

			swap(arr[min_ind], arr[i]);
		}
	}






















Insertion Sort
-----------------------------------------------------------------------------------

-> Worst Case Time Complexity: O(N^2)
	1. Worst case happens when the i/p is reverse sorted

-> In-Place 

-> Stable 

-> Used in practice for small arrays (TimSort and IntroSort)
	1. TimSort: hybrid of MergeSort and InsertionSort
	2. IntroSort: hybrid of HeapSort, QuickSort and InsertionSort

-> Best Case Time Complexity: O(N)
	1. Best Case happens when the i/p is already sorted

-> Insertion Sort is best if we have sort small size array



-> Idea of Insertion Sort
	1. We assume the 1st element already sorted
	2. Then the next element is inserted at its sorted position



1. My Solution

	void insertionSort(int arr[], int n)
	{
	    for(int i=1; i<n; i++)
	    {
	        int temp = arr[i];
	        
	        int j;
	        for(j=i-1; j>=0; j--)
	        {
	            if(arr[j] > temp)
	            {
	                arr[j+1] = arr[j];
	            }
	            else
	            {
	                break;
	            }
	        }
	        
	        arr[j+1] = temp;
	    }
	}





2. Program for Insertion Sort

	void insertionSort(int arr[], int n)
	{
		for(int i=1; i<n; i++)
		{
			int key = arr[i];
			int j = i-1;

			while(j>=0 && arr[j]>key)
			{
				arr[j+1] = arr[j];
				j--;
			}

			arr[j+1] = key;
		}
	}
























Merge Sort Introduction
------------------------------------------------------------------

Merge Sort Properties
	1. Divide and Conquer Algorithm (Divide, Conquer and Merge)

	2. Stable Algorithm

	3. Time Complexity: O(nlog(n))

	4. Space Complexity: O(n)

	5. Well suited for Linked List. Works in O(1) Auxiliary Space

	6. Used in external sorting

	7. In general for arrays, QuickSort outperforms MergeSort








Merge two sorted arrays
----------------------------------------------------------

1. My Solution

	vector<int> merge(int arr1[], int arr2[], int n1, int n2)
	{
	    int i=0;
	    int j=0;
	    int k=0;
	    vector<int> vec(n1+n2);
	    
	    while(i<n1 && j<n2)
	    {
	        if(arr1[i] == arr2[j])
	        {
	            vec[k++] = arr1[i++];
	            vec[k++] = arr2[j++];
	        }
	        else if(arr1[i] < arr2[j])
	        {
	            vec[k++] = arr1[i++];
	        }
	        else
	        {
	            vec[k++] = arr2[j++];
	        }
	    }
	    
	    // After if elements are remaining any one of array then copy to third array;
	    while(i<n1)
	    {
	        vec[k++] = arr1[i++];
	    }
	    
	    while(j<n2)
	    {
	        vec[k++] = arr2[j++];
	    }
	    
	    return vec;
	}



2. Naive Solution

	void merge(int a[], int b[], int m, int n)
	{
		int c[m+n];

		for(int i=0; i<m; i++)
		{
			c[i] = a[i];
		}

		for(int i=0; i<n; i++)
		{
			c[m+i] = b[i];
		}

		sort(c, c+m+n);		// c: startIndex, c+m+n: endIndex+1

		for(int i=0; i<(m+n); i++)
		{
			cout<<c[i]<<" ";
		}
	}


	Time Complexity: O((m+n) * log(m+n))
	Space Complexity: O(m+n)



3. Efficient Solution 

	void merge(int a[], int b[], int m, int n)
	{
		int i=0; j=0;

		while(i<m && j<n)
		{
			if(a[i] <= b[j])
			{
				cout<<a[i]<<" ";
				i++;
			}
			else
			{
				cout<<b[j]<<" ";
				j++;
			}
		}

		while(i<m)
		{
			cout<<a[i]<<" ";
			i++;
		}

		while(j<n)
		{
			cout<<a[j]<<" ";
			j++;
		}
	}


	Time Complexity: O(m+n)
	Space Complexity: O(1)















Merge function of Merge Sort
------------------------------------------------------------

-> Assumption:
	1. Elements from low to mid are sorted
	2. Elements from mid+1 to high are sorted


1. My Solution

	void merge(int a[], int low, int mid, int high)
	{
		int sz = high-low;

		int aux[sz];

		int i=low;
		int j=mid+1;
		int k=0;

		while(i<=mid && j<=high)
		{
			if(a[i] <= a[j])
			{
				aux[k++] = a[i++];
			}
			else
			{
				aux[k++] = a[j++];
			}
		}

		while(i<=mid)
		{
			aux[k++] = a[i++];
		}

		while(j<=high)
		{
			aux[k++] = a[j++];
		}

		// Now copy back the elements to original array
		for(int i=low, k=0; i<=high; i++, k++)
		{
			a[i] = aux[k];
		}
	}


	Time Complexity: 	O(n)
	Space Complexity: 	O(n)



2. Algorithm for merge function 

	// This function will be directly used by Merge Sort

	void merge(int a[], int low, int mid, int high)
	{
		// Part 1: Setting up Auxiliary Arrays
		int n1 = mid-low+1;		
		int n2 = high-mid;	

		int left[n1];
		int right[n2];

		for(int i=0; i<n1; i++)
		{
			left[i] == a[low+i];
		}	

		for(int i=0; i<n2; i++)
		{ 
			right[i] == mid+i+1;
		}

		// Part 2: Standard Merge logic
		int i=0, j=0, k=0;

		while(i<n1 && j<n2)
		{
			if(left[i] <= right[j])
			{
				a[k] = left[i];
				i++;
				k++;
			}
			else
			{
				a[k] = right[j];
				k++;
				j++;
			}
		}

		while(i<n1)
		{
			a[k] = left[i];
			i++;
			k++;
		}

		while(j<n2)
		{
			a[k] = right[j];
			j++;
			k++;
		}
	}


	Time Complexity: 	O(n)
	Space Complexity: 	O(n)




















Merge Sorting Algorithm
-----------------------------------------------------------------

-> For Merge Sort there should be atleast 2 elements.

1. Algorithm for MergeSort

	void mergeSort(int arr[], int left, int right)
	{
		if(right > left)
		{
			// right > left condition assures there are atleast two elements.

			int mid = left + (right - left)/2;		// It's same as  mid = (left + right)/2
													// It's written like this to avoid overflow issue

			mergeSort(arr, left, mid);			// Calling MergeSort on left subarray
			mergeSort(arr, mid+1, right);		// Calling MergeSort on right subarray
			merge(arr, left, mid, right);		// At the end Merge the resultant array(Using Merge Function)
		}
	}


	Time Complexity:	O(Nlog(N))
	Space Complexity:	O(N)























Intersection of two sorted arrays
-----------------------------------------------------------

-> We have to print common elements which appear in both sorted arrays

-> Common elements needs to be printed only once


1. My Solution

	vector<int> commonElements(int a[], int b[], int m, int n)
	{
	    int i=0;
	    int j=0;
	    
	    vector<int> res;
	    int lastCommonElement;
	    int flag = 0;
	    
	    while(i<m && j<n)
	    {
	        
	        if(a[i] == b[j])
	        {
	            if(flag == 0)
	            {
	                lastCommonElement = a[i];
	                flag = 1;
	                res.push_back(lastCommonElement);
	            }
	            else if(a[i] != lastCommonElement)
	            {
	                lastCommonElement = a[i];
	                res.push_back(lastCommonElement);
	            }
	            
	            i++;
	            j++;
	        }
	        else if(a[i] < b[j])
	        {
	            i++;
	        }
	        else
	        {
	            j++;
	        }
	    }
	    
	    return res;
	}


	Time Complexity: 	O(m+n)		// O(max(m,n))
	Space Complexity: 	O(1)



2. Naive Solution

	void intersection(int a[], int b[], int m, int n)
	{
		for(int i=0; i<m; i++)
		{
			// this if condition will take care of duplicate elements
			if(i>0 && a[i]==a[i-1])
			{
				continue;
			}

			for(int j=0; j<n; j++)
			{
				if(a[i] == b[j])
				{
					cout<<a[i]<<" ";
					break;				// this also prevents from printing duplicates
				}
			}
		}
	}


	Time Complexity:	O(n*m)
	Space Complexity:	O(1)



3. Efficient Solution

	void intersection(int a[], int b[], int m, int n)
	{
		int i=0, j=0;

		while(i<m && j<n)
		{
			if(i>0 && a[i]==a[i-1])
			{
				i++; 
				continue;
			}

			if(a[i] < b[j])
			{
				i++;
			}
			else if(a[i] > b[j])
			{
				j++;
			}
			else
			{
				cout<<a[i]<<" ";
				i++;
				j++;
			}
		}
	}


	Time Complexity: 	O(m+n)		// O(max(m,n))
	Space Complexity: 	O(1)















Union of two sorted arrays
-------------------------------------------------------

-> To print the Union of Two Sorted Arrays in Sorted Order

1. My Solution

	vector<int> unionOfTwoSortedArrays(int a[], int b[], int m, int n)
	{
	    int i=0;
	    int j=0;
	    
	    vector<int> res;
	    int lastElement;
	    
	    while(i<m && j<n)
	    {
	        if(i>0 && a[i-1] == a[i])
	        {
	            i++;
	            continue;
	        }
	        
	        if(j>0 && a[j-1] == a[j])
	        {
	            j++;
	            continue;
	        }
	        
	        if(a[i] == b[j])
	        {
	           res.push_back(a[i]);
	           i++;
	           j++;
	        }
	        else if(a[i] < b[j])
	        {
	            // copy any one and move both the pointers
	            res.push_back(a[i]);
	            i++;
	        }
	        else
	        {
	            res.push_back(b[j]);
	            j++;
	        }
	    }
	    
	    // we need to copy the remaining elements also
	    while(i<m)
	    {
	        if(a[i] != a[i-1])
	        {
	            res.push_back(a[i]);
	        }
	        i++;
	    }
	    
	    while(j<n)
	    {
	        if(b[j] != b[j-1])
	        {
	            res.push_back(b[j]);
	        }
	        j++;
	    }
	    
	    return res;
	}


	Time Complexity:	O(m+n)
	Space Complexity: 	O(1)



2. Naive Solution

	void printUnion(int a[], int b[], int m, int n)
	{
		int c[m+n];

		for(int i=0; i<m; i++)
		{
			c[i] = a[i];
		}

		for(int i=0; i<n; i++)
		{
			c[m+i] = b[i];
		}

		sort(c, c+m+n);

		for(int i=0; i<m+n; i++)
		{
			if(i==0 || c[i] != c[i-1])
			{
				cout<<c[i]<<" ";
			}
		}
	}


	Time Complexity:	O((m+n) * log(m+n))
	Space Complexity: 	O(m+n)




3. Efficient Solution

	void printUnion(int a[], int b[], int m, int n)
	{
		int i=0, j=0;

		while(i<m && j<n)
		{
			if(i>0 && a[i]==a[i-1])
			{
				i++;
				continue;
			}

			if(j>0 && a[j]==a[j-1])
			{
				j++;
				continue;
			}

			if(a[i] < b[j])
			{
				cout<<a[i]<<" ";
				i++;
			}
			else if(a[i]>b[j])
			{
				cout<<b[j]<<" ";
				j++;
			}
			else
			{
				cout<<a[i]<<" ";
				i++;
				j++;
			}
		}

		while(i < m)
		{
			if(i>0 && a[i]!=a[i-1])
			{
				cout<<a[i]<<" ";
			}

			i++;
		}

		while(j < n)
		{
			if(j>0 && a[j]!=a[j-1])
			{
				cout<<a[j]<<" ";
			}
			j++;
		}
	} 


	Time Complexity:	O(m+n)
	Space Complexity: 	O(1)















Count Inversions in Array
-----------------------------------------------------------------

Inversion: A pair(arr[i], arr[j]), forms an inversion when i<j and arr[i]>arr[j]

-> If the greater element appears before smaller element, then we call that pair inversion


-> If the array are sorted in increasing order then the number of inversions are 0
	1. Increasing Order: 
		Number of Inversion = 0

-> If the array are reverse sorted then the number of inversions are maximum possible.
	2. Decreasing Order:
		Number of Inversion = (n-1) + (n-2) + ... + 1 = (n * (n-1))/2
	



1. Naive Solution
	
	int countInversion(int arr[], int n)
	{
		int res = 0;

		for(int i=0; i<(n-1); i++)
		{
			for(int j=i+1; j<n; j++)
			{
				if(arr[i] > arr[j])
				{
					res++;
				}
			}
		}

		return res;
	}


	Time Complexity:	O(n^2)
	Space Complexity: 	O(1)




2. Efficient Solution

	-> Idea is based on mergeSort

	-> We do exactly as mergeSort but along with sorting we 
		count inversions on left half and count inversions 
		on right half, and while merging we count inversion
		on both sides.


	-> Every inversion(x, y) where x > y, has possibilities
		1. both x and y are in left half
		2. both x and y are in right half
		3. x is in left half and y is in right half 



	// key part of "countInversion" function is "countAndMerge" function

	int countAndMerge(int arr[], int left, int mid, int right)
	{
		int n1 = mid-left+1;
		int n2 = right-m;

		int leftArray[n1];
		int rightArray[n2];

		for(int i=0; i<n1; i++)
		{
			leftArray[i] = arr[left+i];
		}

		for(int i=0; i<n2; i++)
		{
			rightArray[i] = arr[mid+1+i];
		}

		int res=0;						// Extra step compared to Merge Function

		int i=0, j=0, k=left;

		while(i<n1 && i<n2)
		{
			if(leftArray[i] <= rightArray[j])
			{
				arr[k] = leftArray[i];
				i++;
				k++;
			}
			else
			{
				arr[k] = rightArray[j];
				j++;

				res = res + (n1-i);			// Extra step compared to Merge Function
				
				// if we find an element in the right array, which is smaller, then it's 
					going to be smaller than all the elements from i to n1-i
			}

			k++;
		}


		while(i < n1)
		{
			arr[k] = leftArray[i];
			i++;
			k++;
		}

		while(j < n2)
		{
			arr[k] = rightArray[j];
			j++;
			k++;
		}


		return res;							// Extra step compared to Merge Function 
	}


	int countInversion(int arr[], int left, int right)
	{
		int res = 0;

		if(left < right)
		{
			int mid = left + (right - left)/2;		// same as mid = (left+right)/2

			// count Inversion on the left half
			res = res + countInversion(arr, left, mid);		

			// count Inversion on the right half
			res = res + countInversion(arr, mid+1, right);	

			// counting Inversions while we merge these two parts
			res = res + countAndMerge(arr, left, mid, right);	
		}

		return res;
	}


	Time Complexity: 	O(nlog(n))
	Space Complexity:	O(n)


















Naive Partition
-----------------------------------------------------------

-> Partition function of quick sort

-> Naive Partition is Stable


-> Requirement of the partition function
	1. it should partition the array around given index->element.

	2. All the elements left to the element should be smaller or equal

	3. All the elements right to the element should be greater

	4. element to the left and to the right around paritition element can be
		in any order.




-> Partition Function
	1. Naive Partition / Naive Solution
	2. Lomuto Partition
	3. Hoare's Partition




1. Naive Solution

	void partition(int arr[], int low, int high, int p)
	{
		int temp[high-low+1];
		int index = 0;

		for(int i=low; i<=high; i++)
		{
			if(arr[i] <= arr[p])
			{
				temp[index] = arr[i];
				index++;
			}
		}

		for(int i=low; i<=high; i++)
		{
			if(arr[i] > arr[p])
			{
				temp[index] = arr[i];
				index++;
			}
		}

		for(int i=low; i<=high; i++)
		{
			arr[i] = temp[i-low];
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)












Lomuto Partition
---------------------------------------------------------------

-> Lomuto Partion, partitions the array in only one traversal	

-> On average, Hoare's Partition performs much better than Lomuto's Partition

-> Lomuto Partition is not Stable

2. Case 1: Pivot index is not passed as an argument

	-> Assumption: We consider here pivot element to be always the last element 

	-> While traversing we ensure that
		1. Elements from index low to index i are less than pivot element

		2. Elements from index i+1 to index j-1 are greater than or equal to pivot


	int lomutoPartition(int arr[], int low, int high)
	{
		int pivot = arr[high];		// Always the last element of the array

		int i = low-1;

		for(int j=low; j<=high-1; j++)
		{
			// we need to swap the element if we found any element smaller than pivot
			if(arr[j] < pivot)
			{
				i++;	// increasing the window size of smaller elements
				swap(arr[i], arr[j]);
			}
		}

		swap(arr[i+1], arr[high]);

		return (i+1);
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)





2.1. Case 2: Pivot index is passed as an argument

	-> Here in the 1st step we swap the partition element from the last element
		then we can use the standard lomuto partition algorithm. 

	-> While traversing we ensure that
		1. Elements from index low to index i are less than pivot element

		2. Elements from index i+1 to index j-1 are greater than or equal to pivot


	int lomutoPartition(int arr[], int low, int high, int p)
	{
		swap(arr[p], arr[high]);  // This way we are ensuring the pivot element is the last element

		int pivot = arr[high];		// Always the last element of the array

		int i = low-1;

		for(int j=low; j<=high-1; j++)
		{
			// we need to swap the element if we found any element smaller than pivot
			if(arr[j] < pivot)
			{
				i++;	// increasing the window size of smaller elements
				swap(arr[i], arr[j]);
			}
		}

		swap(arr[i+1], arr[high]);

		return (i+1);
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)




















Hoare's Partition
-----------------------------------------------------------

-> In Hoare's Partition, in it's typical implementation we consider the
	first element as the pivot element.


3. Typical Implementation of Hoare's Partition

	int hoarePartition(int arr[], int low, int high)
	{
		int pivot = arr[low];

		int i = low-1;
		int j = high+1;

		while(true)
		{
			do
			{
				i++;

			}while(arr[i] < pivot)

			do
			{
				j--;

			}while(arr[j] > pivot)

			if(i >= j)
			{
				return j;
			}

			swap(arr[i], arr[j]);
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)




3.1. Modified Implementation of Hoare's Partition

	int hoarePartition(int arr[], int low, int high, int p)
	{
		swap(arr[low], arr[p]);		// It ensures that pivot element is always the 1st element

		int pivot = arr[low];

		int i = low-1;
		int j = high+1;

		while(true)
		{
			do
			{
				i++;

			}while(arr[i] < pivot)

			do
			{
				j--;

			}while(arr[j] > pivot)

			if(i >= j)
			{
				return j;
			}

			swap(arr[i], arr[j]);
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)




-> In Hoare's Partition, all the elements less than or equal to pivot are on left side,
	and all the elements greater than or equal to pivot are on right side

	1. All the elements to the left of returned index are smaller than or equal to pivot
	2. All the elements to the right of returned index are greater than or equal to pivot 



-> Lomuto's Partition ensures that the pivot element is at its correct position, once
	the partition is done


-> Hoare's Partition is not stable, and this is one of the reason why Quick Sort is 
	not stable by default.





















Quick Sort Introduction
---------------------------------------------------------------

-> Quick Sort
	1. Divide and Conquer Algorithm

	2. Worst Case Time: O(N^2)

	3. Despite O(N^2) worst case, it is considered faster, because of 
		the following reasons.
			a. In-Place
			b. Cache friendly
			c. Average case is O(nlog(n))
			d. Tail Recursion

	4. Partition is Key Function(Naive, Lomuto, Hoare) 


















QuickSort using Lomuto Partition
-----------------------------------------------------------

1. Algorithm for Quick Sort

	void quickSort(int arr[], int low, int high)
	{
		if(low < high)
		{
			int p = lomutoPartition(arr, low, high);

			quickSort(arr, low, p-1);

			quickSort(arr, p+1, high);
		}
	}














Quick Sort using Hoare Partition
--------------------------------------------------------------------------

1. Algorithm for Quick Sort

	void quickSort(int arr[], int low, int high)
	{
		// base condition implies, there should be atlease two elements to sort
		if(low < high)		
		{
			int p = hoarePartition(arr, low, high);

			quickSort(arr, low, p);		// in case of lomutoPartition we were passing "p-1"

			quickSort(arr, p+1, high);
		}
	} 



















Quick Sort Analysis
---------------------------------------------------------------

-> Best Case Recursion: 	T(n) = 2T(n/2) + (n)

-> Worst Case Recursion: 	T(n) = T(n-1) + (n)


-> Time Complexities for different cases:
	1. Best Case Time Complexity:		O(nlog(n))

	2. Worst Case Time Complexity:		O(n^2)

	3. Average Case Time Complexity:	O(nlog(n))













Space Analysis of Quick Sort
---------------------------------------------------------------------

-> Space Complexities for different cases:
	1. Best Case Space Complexity:		O(log(n))

	2. Worst Case Space Complexity:		O(n)




















Choice of pivot and worst case of Quick Sort
--------------------------------------------------------------------------

-> Adversary Analysis

-> For choosing pivot 
	p = random(low, high)
		1. swap(arr[low], arr[p])		// Hoare Partition

		2. swap(arr[high], arr[p])		// Lomuto Partition












Tail Call elimination in Quick Sort
---------------------------------------------------------------------------

-> Most of times, modern compilers do tail call optimization themselves.
	Ex. C++, Java


-> Python does not do tail call optimization by itself.



1. Idea for tail call elimination in Quick Sort

	void quickSort(int arr[], int low, int high)
	{
		Begin:
			if(low < high)
			{
				int p = hoarePartition(arr, low, high);

				quickSort(arr, low, p);

				low = p+1;

				goto Begin;
			}
	}





















Kth Smallest Element
-----------------------------------------------------------------------

1. Naive Solution

	int KthSmallestElement(int arr[], int n, int k)
	{
		sort(arr, arr+n);		// In case of Java: Arrays.sort(arr);

		return arr[k-1];
	}


	Time Complexity:	O(nlog(n))
	Space Complexity: 
		1. If allowed to modify the array:		O(1)
		2. If not allowed to modify the array:	O(n)







2. Efficient Solution (Works better than above algorithm on average)

	-> It is also know as "Quick Select Algorithm" 

	-> Idea for the efficient solution

		1. Partition the Array around a Pivot
			p = partition(arr, low, high)

		2. If p == k-1					p=1, k=2
				return arr[p];

		   Else if p > k-1				p=3, k=2
		   		high = p-1;

		   Else (p < k-1) 				p=2, k=4
		   		low = p+1;




	int KthSmallestElement(int arr[], int n, int k)
	{
		int low = 0;
		int high = n-1;

		while(low <= high)
		{
			int p = lomutoPartition(arr, low, high);

			if(p == k-1)
			{
				return arr[p];
			}
			else if(p > k-1)
			{
				high = p-1;
			}
			else
			{
				low = p+1;
			}
		}

		return -1;
	}























Minimum Difference in an Array
-----------------------------------------------------------------------------

1. My Solution

	int getMinimumDifference(int arr[], int n)
	{
	    int minDiff = INT_MAX;
	    
	    if(n == 1)
	        return minDiff;
	        
	    for(int i=0; i<n-1; i++)
	    {
	        for(int j=i+1; j<n; j++)
	        {
	            int diff = abs(arr[i] - arr[j]);
	            minDiff = min(minDiff, diff);
	        }
	    }
	    
	    return minDiff;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)



2. Naive Solution

	int getMinDiff(int arr[], int n)
	{
		int res = INT_MAX;			// For Java: Integer.MAX;

		for(int i=1; i<n; i++)
		{
			for(int j=0; j<i; j++)
			{
				res = min(res, abs(arr[i] - arr[j]));		// for Java:
															//	1. min() -> Math.min()
															//  2. abs() -> Math.abs() 
			}
		}
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)



3. Efficient Solution

	int getMinDiff(int arr[], int n)
	{
		int res = INT_MAX;		// for Java: res = Integer.MAX_VALUE

		sort(arr, arr+n);		// for Java: Arrays.sort(arr)

		for(int i=1; i<n; i++)
		{
			res = min(res, arr[i]-arr[i-1]);
		}

		return res;
	}


	Time Complexity:	O(Nlog(N))
	Space Complexity:	O(1)























Chocolate Distribution Problem
-------------------------------------------------------------------------

-> Problem Statement:
	1. n = number of chocolate packets

	2. number of chocolates in each packets are represented by array elements

	3. m = number of children

	4. we have to select m packets from the array such that distribution of chocolates is fair
		-> fair distribution means: difference b/w maximum chocolate a child gets and 
			minimum chocolate a child gets should be minimum.




1. My Solution

	int fairChocolateDistribution(int arr[], int n, int childrenCount)
	{
	    sort(arr, arr+n);
	    
	    int res = INT_MAX;
	    
	    for(int i=0, j=childrenCount-1; j<n; i++, j++)
	    {
	        res = min(res, arr[j]-arr[i]);
	    }
	    
	    return res;
	}




2. Efficient Solution

	int minDiff(int arr[], int n, int m)
	{
		if(m>n)
		{
			return -1;
		}

		sort(arr, arr+n);

		int res = arr[m-1] - arr[0];

		for(int i=1; (i+m-1)<n; i++)
		{
			res = min(res, arr[i+m-1]-arr[i]);
		}

		return res;
	}


	Time Complexity:	O(nlog(n))





















Sort an Array with two types of elements
--------------------------------------------------------------------------------

-> There are various forms of this problem
	1. Segregate positive and negative

	2. Segregate Even and Odd

	3. Sort a Binary Array




1. My Solution

	void segregatePositiveAndNegative(int arr[], int n)
	{
	    int i=0, j=n-1;
	    
	    while(i<j)
	    {
	        while(arr[i] < 0)
	        {
	            if(i>=n)
	                break;
	            i++;
	        }
	        
	        while(arr[j] >= 0)
	        {
	            if(j <= 0)
	                break;
	            j--;
	        }
	        
	        swap(arr[i++], arr[j--]);
	    }
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)



2. Naive Solution

	void segregatePosNeg(int arr[], int n)
	{
		int temp[n];

		int i = 0;

		for(int j=0; j<n; j++)
		{
			if(arr[j] < 0)
			{
				temp[i] = arr[j];
				i++;
			}
		}

		for(int j=0; j<n; j++)
		{
			if(arr[j] >= 0)
			{
				temp[i] = arr[j];
				i++;
			}
		}

		for(int j=0; j<n; j++)
		{
			arr[j] = temp[j];
		}
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)



3. Efficient Solution

	-> Idea: This problem is mainly a variation of 
			 partition() of QuickSort.

				-> Hoare or Lomuto Partition can 
				   solve this in O(n) time and
				   O(1) Aux space. 



	void segPosNeg(int arr[], int n)
	{
		int i = -1;
		int j = n;

		while(true)
		{
			do
			{
				i++;

			}while(arr[i] < 0)

			do
			{
				j--;

			}while(arr[j] >= 0)

			if(i >= j)
			{
				return;
			}

			swap(arr[i], arr[j]);
		}
	}
























Sort an Array with three types of elements
-----------------------------------------------------------------

-> Variations of this problem
	1. Sort an Array of 0s, 1s and 2s

	2. Three way Partitioning
		Example:
			i/p: arr[] = {2, 1, 2, 20, 10, 20, 1}, 	pivot = 2
			o/p: arr[] = {1, 1, 2, 2, 20, 10, 20}	
				-> All the pivot element should come together, and left side should be less than pivot
				   and right side should be greater than the pivot

	3. Partition around a Range
		Example:
			i/p: arr[] = {10, 5, 6, 3, 20, 9, 40}, 	Range = [5, 10]
			o/p: arr[] = {3, 5, 6, 9, 10, 20, 40}




1. Naive Solution

	void sort(int arr[], int n)
	{
		int temp[n], i=0;

		for(int j=0; j<n; j++)
		{
			if(arr[j] == 0)
			{
				temp[i] = arr[j];
				i++;
			}
		}

		for(int j=0; j<n; j++)
		{
			if(arr[j] == 1)
			{
				temp[i] = arr[j];
				i++;
			}
		}

		for(int j=0; j<n; j++)
		{
			if(arr[j] == 2)
			{
				temp[i] = arr[j];
				i++;
			}
		}

		for(int j=0; j<n; j++)
		{
			arr[j] = temp[j];
		}
	}


	Time Complexity:	O(N)	// Four Traversals
	Space Complexity:	O(N)




2. Efficient Solution (Dutch National Flag Algorithm)

	-> It's a variation of Hoare's Partition
		1. We are going to maintain Four Sections in our Array

		2. The section from index 0 to low-1 will be having 0s only

		3. The section from index low to mid-1 will be having 1s only

		4. The section from index mid to high is Unknown

		5. The section from high+1 till end will be having 2s only




	void sort(int arr[], int n)
	{
		int low = 0;
		int high = n-1;
		int mid = 0;

		while(mid <= high)
		{
			if(arr[mid] == 0)
			{
				swap(arr[low], arr[mid]);
				low++;
				mid++;
			}

			else if(arr[mid] == 1)
			{
				mid++;
			}
			else
			{
				swap(arr[mid], arr[high]);
				high--;
			}
		}
	}


	Time Complexity:	O(n)	// one traversal only
	Space Complexity:	O(1)




























Merge Overlapping Intervals
----------------------------------------------------------------------

#Revisit
#Revise

-> Objective: To print/get Non-Overlapping Intervals

	I/P: [{1, 3}, {2, 4}, {5, 7}, {6, 8}]
	o/p: [{1, 4}, {5, 8}]

	I/P: [{7, 9}, {6, 10}, {4, 5}, {1, 3}, {2, 4}]
	o/p: [{1, 5}, {6, 10}]



-> Method to check if two intervals overlap
	1. Take the greater value of start values of intervals, if this value lies in the
		range of other interval, then the two intervals overlap

									OR

	2. Take the smaller value of end values of intervals, if this value lies in the 
		range of other interval, then the two intervals overlap





1. Naive Solution: 	O(n^3)

	// Implement it by yourself




2. Efficient Solution: O(nlog(n))

	-> Idea for efficient solution
		1. Sort by start time in Increasing order
							OR
		   Sort by end time in decreasing order
 



	struct Interval
	{
		int start;
		int end;
	}

	void mergeIntervals(Interval arr[], int n)
	{
		sort(arr, arr+n, myComp);

		int res = 0;

		for(int i=1; i<n; i++)
		{
			// condition for Merge to take place
			if(arr[res.end] >= arr[i].start)
			{
				arr[res].end = max(arr[res].end, arr[i].end);
				arr[res].start = min(arr[res].start, arr[i].start);
			}
			else
			{
				res++;

				arr[res] = arr[i];		// Starting a new Merge
			}
		}

		for(int i=0; i <= res; i++)
		{
			cout<<arr[i].start<<" "<<arr[i].end<<endl;
		}
	}

























Meeting the Maximum Guests
------------------------------------------------------------------

1. Efficient Solution: O(nlog(n))

	int maxGuest(int arr[], int dep[], int n)
	{
		sort(arr, arr+n);		// Java: Arrays.sort(arr)
		sort(dep, dep+n);		// Java: Arrays.sort(dep)

		int i=1, j=0;

		int res=1, curr=1;

		while(i<n && j<n)
		{
			if(arr[i] <= dep[j])
			{
				curr++;
				i++;
			}
			else
			{
				curr--;
				j++;
			}

			res = max(res, curr);
		}

		return res;
	}



















Cycle Sort
------------------------------------------------------

#Revisit
#Revise

-> Properties
	1. A Worst Case O(n^2) Sorting Algorithm

	2. Does minimum memory writes and can be useful for cases where memory
	   write is costly.

	3. "In-Place" and "Not Stable"

	4. Useful to solve questions like find minimum swaps required to sort an Array





1. Cycle Sort Algorithm: Assumption(No repeating elements)

	-> The algorithm ensures that the elements from 0 to cs-1 are always sorted

	-> cs stand for cycleStart



	void cycleSortDistinctElements(int arr[], int n)
	{
		for(int cs=0; cs < n-1; cs++)
		{
			int item = arr[cs];

			int pos = cs;

			for(int i=cs+1; i<n; i++)
			{
				if(arr[i] < item)
				{
					pos++;
				}
			}

			swap(item, arr[pos]);

			while(pos != cs)
			{
				pos = cs;

				for(int i = cs+1; i<n; i++)
				{
					if(arr[i] < item)
					{
						pos++;
					}
				}

				swap(item, arr[pos]);
			}
		}
	}





Exercise 1: Extend this Cycle sort to handle duplicates in the Array

Exercise 2: Modify the counting sort, so that it counts the minimum number of swaps
			required to sort an Array





















Heap Sort
------------------------------------------------------------
#Revise: revise this topic after learning "Tree Data Structure" and "Heap Data Structure"
#Revisit


-> The basic idea of Heap Sort is based on Selection Sort Algorithm

-> In Selection Sort algorithm, we find out the maximum element and we swap it with 
   the last element.

 -> In Selection Sort, we do linear search to find out the maximum element, therefore it 
    takes O(n^2) time.  




-> Heap Sort doen an optimization over Selection Sort, for finding the maximum element instead 
   of doing linear search, Heap Sort uses Max Heap data Structure.


-> Building a Max Heap or a Min Heap from a random array is O(N) time


-> To Sort an Array in increasing order we use Max Heap and to Sort an Array in decreasing order
   we use Min Heap.




-> Heap Sort works in two steps

	1. Build Max Heap or Min Heap from the given Random Array

	2. Heapify




1. Heap Sort Algorithm

	void maxHeapify(int arr[], int n, int i)
	{
		int largest = i;
		int left = 2*i + 1; 
		int right = 2*i + 2;

		if(left<n && arr[left]>arr[largest])
		{
			largest = left;
		}

		if(right<n && arr[right]>arr[largest])
		{
			largest = right;
		}

		if(largest != i)
		{
			swap(arr[largest], arr[i]);
			maxHeapify(arr, n, largest);
		}
	}


	// This function converts a complete binary tree to Max Heap 
	void buildHeap(int arr[], int n)
	{
		for(int i=(n-2)/2; i >= 0; i--)
		{
			maxHeapify(arr, n-i);
		}
	}


	void heapSort(int arr[], int n)
	{
		buildHeap(arr, n);

		for(int i = n-1; i>=1; i--)
		{
			swap(arr[0], arr[i]);
			heapify(arr, i, 0);
		}
	}





-> Heap Sort can mainly be seen as improvement of Selection Sort. It uses 
   heap data structure and concept of Selection Sort


-> Selection Sort worst case time complexity is O(N^2), whereas Heap Sort 
   time complexity is O(Nlog(N))


-> In Practice, Merge Sort and Quick Sort takes less time compared to Heap Sort



Note:
	1. Merge Sort takes O(Nlog(N)) time in 	:	Worst Case

	2. Quick Sort takes O(Nlog(N)) time in 	:	Average Case

	3. Heap Sort takes O(Nlog(N)) time in 	:	All cases
























Counting Sort
------------------------------------------------------------

-> Counting Sort is a linear time Algorithm for the cases when our input elements
   are in a small range.


-> If we have "n" elements and elements are in the range of "0" to "k-1" then 
   Count Sort will take O(n+k) time for sorting


-> It not comparison based algorithm



1. Naive Approach

	void countSort(int arr[], int n, int k)
	{
		int count[k];

		for(int i=0; i<k; i++)
		{
			count[i] = 0;
		}

		for(int i=0; i<n; i++)
		{
			count[arr[i]]++;
		}

		int index = 0;

		for(int i=0; i<k; i++)
		{
			for(int j=0; j<count[i]; j++)
			{
				arr[index] = i;
				index++;
			}
		}
	}


	Time Complexity:	O(n+k)
	Space Complexity:	O(k)



	-> The above implementation of Count Sort is not a genereal purpose Sort Algorithm, it will only work for 
   integer type elements.





2. General Purpose Count Sort Implementation

	void countSort(int arr[], int n, int k)
	{
		int count[k];

		for(int i=0; i<k; i++)
		{
			count[i] = 0;
		}

		for(int i=0; i<n; i++)
		{
			count[arr[i]]++;
		}


		// Here we are modifying "count array" such that "count[i]" stores how many elements
		// in the input(original) array are smaller than or equal to i
		for(int i=0; i<n; i++)
		{
			count[i] = count[i-1] + count[i];
		}



		int output[n];

		// To build the output array we can traverse from "0" to "n-1" also, but we are traversing in 
		// opposite direction, so that our output sort is "Stable"
		for(int i = n-1; i>=0; i--)
		{
			output[count[arr[i]] - 1] = arr[i];
			count[arr[i]]--;
		}

		for(int i=0; i<n; i++)
		{
			arr[i] = output[i];
		}
	}


	Time Complexity:	O(n+k)
	Space Complexity:	O(n+k)



-> Important Points of Count Sort
	1. Not a comparison based Algorithm

	2. Time Complexity: O(n+k)

	3. Space Complexity: O(n+k)

	4. Stable

	5. Used as a subroutine in Radix Sort



Exersice: Extend the given implementation to work for an arbitrary range of size k
		  i.e., elements ranges from "minValue" to "maxValue = minValue+k"
		  minValue can be negative also.
























Radix Sort
-------------------------------------------------------

-> It's a linear time algorithm, if the data is in a limited range.

-> Radix Sort uses, Count sort as a subroutine to sort the elements. 

-> Similar to Count sort, it is also "not a comparison based" sorting algorithm.



-> Let's see an example of Radix sort in action:

	-> int arr[] = {319, 212, 6, 8, 100, 50}

	-> Rewriting Numbers with leading zeroes so that all elements have number of digits
	   int arr[] = {319, 212, 006, 008, 100, 050}

	-> Stable sort based on the last digit (least significant digit)
	   int arr[] = {100, 050, 212, 006, 008, 319}

	-> Stable sort based on the next significant digit
	   int arr[] = {100, 006, 008, 212, 319, 050}

	-> Stable sort based on the most significant digit
	   int arr[] = {006, 008, 050, 100, 212, 319}









1. Radix Sort Algorithm

	void countSort(int arr[], int n, int exp)
	{
		int count[10]; 
		int output[n];

		for(int i=0; i<10; i++)
			count[i] = 0;


		for(int i=0; i<n; i++)
			count[(arr[i]/exp)%10]++;


		for(int i=0; i<10; i++)
			count[i] = count[i] + count[i-1];


		for(int i = n-1; i>=0; i--)
		{
			int index = (arr[i]/exp)%10;
			output[count[index] - 1] = arr[i];
			count[index]--;
		}


		for(int i=0; i<n; i++)
		{
			arr[i] = output[i];
		}
	}


	void radixSort(int arr[], int n)
	{
		int mx = arr[0];

		// Loop to find maximum element of the array
		for(int i=1; i<n; i++)
		{
			if(arr[i] > mx)
			{
				mx = arr[i];
			}
		}


		for(int exp=1; mx/exp > 0; exp = exp*10)
		{
			countSort(arr, n, exp);
		}
	}


	Time Complexity:	O(d * (n + b))		
		-> d: number of digit in the maximum number
		-> n: size of input array
		-> b: base of Numbers 	// for above example the base is 10

	Space Complexity: 	O(n+b)
























Bucket Sort
--------------------------------------------------------------

-> Let's consider two situation where Bucket Sort can be applied
	1. Consider a situation where we have numbers uniformly distributed in range 
		from 1 to 10e8. How do we sort efficiently

	2. Consider another situation where we have floating point numbers uniformly
		distributed in range 0.0 to 1.0


-> Bucket Sort is an Algorithm that works in linear time, when data is uniformly 
	distributed across a range.


-> The Algorithm is similar to Hashing with Chaining


-> We can use any Standard Sorting algorithm to sort the individual Buckets.
	If we are sure that individual buckets are going to have less number of 
	elements, then we can use Insertion Sort.


-> Insertion Sort is the best suitable algorithm for small amount of data.




1. C++ implementation of Bucket Sort

	void bucketSort(int arr[], int n, int k)
	{
		int max_val = arr[0];

		//Loop to find maximum value of the array
		for(int i=1; i<n; i++)
		{
			max_val = max(max_val, arr[i]);
		}

		max_val++;


		vector<int> bkt[k];			// Array of vectors

		// Loop to fill the buckets
		for(int i=0; i<n; i++)
		{
			int bi = (k*arr[i])/max_val;		// bi -> bucketIndex
			bkt[bi].push_back(arr[i]);
		}


		// Loop to sort the bucket
		for(int i=0; i<k; i++)
		{
			sort(bkt[i].begin(), bkt[i].end());
		}


		// Loop for joining/concatanating the buckets
		int index = 0;

		for(int i=0; i<k; i++)
		{
			for(int j=0; j<bkt[i].size(); j++)
			{
				arr[index++] = bkt[i][j];
			}
		}
	}






2. Java implementation of Bucket Sort

	void bucketSort(int arr[], int k)
	{
		int n = arr.length();
		int max_val = arr[0];

		// Loop to find maximum element of the array
		for(int i=1; i<n; i++)
		{
			max_val = Math.max(max_val, arr[i]);
		}

		max_val++;


		ArrayList<ArrayList<Integer>> bkt = new ArrayList<ArrayList<Integer>>();

		for(int i=0; i<n; i++)
		{
			bkt.add(new ArrayList<Integer>());
		}


		// Loop to fill the buckets
		for(int i=0; i<n; i++)
		{
			int bi = (k*arr[i])/max_val;
			bkt.get(bi).add(arr[i]);
		}


		// Loop to sort the individual buckets
		for(int i=0; i<k; i++)
		{
			Collection.sort(bkt.get(i));
		}


		// Loop for joining/concatanating the buckets
		int index = 0;

		for(int i=0; i<k; i++)
		{
			for(int j=0; j<bkt.get(i).size(); j++)
			{
				arr[index++] = bkt.get(i).get(j);
			}
		}
	}






-> Time Complexity Analysis of Bucket Sort

	1. Assuming k  n 		// k -> number of buckets

	2. Best Case: O(n)
		-> Data is uniformly distributed

	3. Worst Case: O(n^2)
		-> All item go into a single bucket.

		-> If we use Insertion Sort to sort individual buckets, then O(n^2)

		-> If we use O(nlog(n)) algorithm to sort individual buckets, then
			it will take O(nlog(n))




















Overview of Sorting Algorithm
--------------------------------------------------------------

1. Binary Array
	-> Can be efficiently sorted using Partitioning Algorithm of Quick sort
	-> Partition Algorithms: Lomuto, Hoare, Naive(Stable) 

2. Array with three value
	-> Can be solved using Partitioning Algorithm of Quick Sort
	
3. Array of size n and small ranged values
	-> Counting Sort

4. Array of size n and range is of size n^2 or n^3 or closer
	-> Radix Sort

5. Array of uniformly distributed data over a range
	-> Bucket Sort

6. When memory writes are costly
	-> Selection Sort: O(n^2)
	-> Cycle Sort: optimal in terms of memory writes

7. When adjacent swaps are allowed
	-> Bubble Sort
	-> Cocktail Sort: optimized version of Bubble Sort

8. When array size is small 
	-> Selection Sort
	-> Insertion Sort: it is considered best algorithm to sort small number of elements

9. When available extra memory is less
	-> Shall Sort: O(n * log^2(n)) = O(n * (log(n)^2))





-> General Purpose Sorting Algorithms
	1. MergeSort		// Works best for Linked List as well

	2. HeapSort			// Can not be used for sorting Linked List

	3. QuickSort		// Can be used for sorting linked list


-> Hybrid Algorithms (Used in Libraries)
	1. TimSort	-> Used by Python Library		// MergeSort + InsertionSort

	2. IntroSort 								// QuickSort + HeapSort + InsertionSort




























































































































#########################################################
8. Matrix
#########################################################


Multidimensional Array in CPP
-----------------------------------------------------------------

-> An Example of 2-D Array in Cpp

	#include <iostream>
	using namespace std;

	int main()
	{
		int arr[3][2] = {
							{10, 20},
							{30, 40}, 
							{50, 60}
						};


		// Printing the elements of 2-D Array

		for(int i=0; i<3; i++)
		{
			for(int j=0; j<2; j++)
			{
				cout<<arr[i][j]<<" ";
			}
		}

		return 0;
	}


	O/P: 10 20 30 40 50 60




-> Important Points
	1. Elements are stored in row-major order

	2. Internal curly brackets are optional
		-> int arr[3][2] = {10, 20, 30, 40, 50, 60}

	3. Only the first dimension can be omitted when we initialize
		-> int arr[][2] = { {1, 2}, {3, 4} };

		-> int arr[][2][2] = { 
								{
									{1, 2}, {3, 4}
								},

							    {
							    	{5, 6}, {7, 8}
							    } 
							 }





-> C++(14) allowes Variable Sized array

	#include<iostream>
	using namespace std;

	int main()
	{
		int m=3, n=2;

		int arr[m][n];

		for(int i=0; i<m; i++)
		{
			for(int j=0; j<n; j++)
			{
				arr[i][j] = i+j;
			}
		}

		for(int i=0; i<m; i++)
		{
			for(int j=0; j<n; j++)
			{
				cout<<arr[i][j]<<" ";
			}
		}

		return 0;
	}

	O/P: 0 1 1 2 2 3




-> Other ways to create multidimensional-Arrays in C++

	1. Double Pointer

		#include <iostream>
		using namespace std;

		int main()
		{
			int m=3, n-2;

			int** arr;
			arr = new int* [m];


			for(int i=0; i<m; i++)
			{
				arr[i] = new int[n];
			}


			for(int i=0; i<m; i++)
			{
				for(int j=0; j<n; j++)
				{
					arr[i][j] = 10;
					cout<<arr[i][j]<<" ";
				}
			}

			return 0;
		}



	2. Array of Pointers

		#include <iostream>
		using namespace std;

		int main()
		{
			int m=3;
			int n=2;

			int* arr[m];

			for(int i=0; i<m; i++)
			{
				arr[i] = new int[n];
			}


			for(int i=0; i<m; i++)
			{
				for(int j=0; j<n; j++)
				{
					arr[i][j] = 10;
					cout<<arr[i][j]<<" ";
				}
			}
		}



	3. Array of Vectors

		-> Not as cache friendly as simple 2-D arrays

		-> Individual rows are of dynamic sizes

		-> Easy to pass to a function


		#include <iostream>
		#include <vector>

		using namespace std;

		int main()
		{
			int m=3, n=2;

			vector<int> arr[m];

			for(int i=0; i<m; i++)
			{
				for(int j=0; j<n; j++)
				{
					arr[i].push_back(10);
				}
			}


			for(int i=0; i<m; i++)
			{
				for(int j=0; j<n; j++)
				{
					cout<<arr[i][j]<<" ";  
				}
			}
		}



	4. Vector of Vectors

		-> Number of Rows can also be dynamic


		#include <iostream>
		#include <vectors>

		using namespace std;

		int main()
		{
			int m=3;
			int n=2;

			vector<vector<int>> arr;

			for(int i=0; i<m; i++)
			{
				vector<int> v;
				for(int j=0; j<n; j++)
				{
					v.push_back(10);
				}

				arr.push_back(v);
			}


			for(int i=0; i<arr.size(); i++)
			{
				for(int j=0; j<arr[i].size(); j++)
				{
					cout<<arr[i][j]<<" ";
				}
			}
		}




















Passing 2-D arrays as arguments in CPP
----------------------------------------------------------------

-> Example 1:
	
	void printMatrix(int mat[3][2])
	{
		for(int i=0; i<3; i++)
		{
			for(int j=0; j<2; j++)
			{
				cout<<mat[i][j]<<" ";
			}
		}
	}


	int main()
	{
		int mat[3][2] = {
							{10, 20},
							{30, 40},
							{50, 60}
						};

		printMatrix(mat);

		return 0;
	}



-> Example 2:

	void printMatrix(int mat[][2], int m)
	{
		for(int i=0; i<m; i++)
		{
			for(int j=0; j<2; j++)
			{
				cout<<mat[i][j]<<" ";
			}
		}
	}


	int main()
	{
		int mat[3][2] = {
							{10, 20},
							{30, 40},
							{50, 60}
						};

		printMatrix(mat, 3);

		return 0;
	}



-> Example 3:
	
	const int R = 3;
	const int C = 2;

	void printMatrix(int mat[R][C])
	{
		for(int i=0; i<R; i++)
		{
			for(int j=0; j<C; j++)
			{
				cout<<mat[i][j]<<" ";
			}
		}
	}


	int main()
	{
		int mat[R][C] = {
							{10, 20},
							{30, 40},
							{50, 60}
						};

		printMatrix(mat);

		return 0;
	}



-> Other ways to pass matrix to a function, which works for any dimension Matrix

	1. Using Double Pointer

		void printMatrix(int** arr, int m, int n)
		{
			for(int i=0; i<m; i++)
			{
				for(int j=0; j<n; j++)
				{
					cout<<arr[i][j]<<" ";
				}
			}
		}


		int main()
		{
			int** arr;

			int m=3;
			int n=2;

			arr = new int*[m];

			for(int i=0; i<m; i++)
			{
				arr[i] = new int[n];

				for(int j=0; j<n; j++)
				{
					arr[i][j] = i;
					cout<<arr[i][j]<<" ";
				}
			}

			return 0;
		}

		o/p: 0 0 1 1 2 2


	2. Using Array of Pointers

		void printMatrix(int* arr[], int m, int n)
		{
			for(int i=0; i<m; i++)
			{
				for(int j=0; j<n; j++)
				{
					cout<<arr[i][j]<<" ";
				}
			}
		}


		int main()
		{
			int m=3;
			int n=2;

			int* arr[m];

			for(int i=0; i<m; i++)
			{
				arr[i] = new int[n];

				for(int j=0; j<n; j++)
				{
					arr[i][j] = i;
					cout<<arr[i][j]<<" ";
				}
			}

			return 0;
		}




-> C++ vector Solutions to write general purpose Matrix Function

	1. Using Array of Vectors

		void printMatrix(vector<int> arr[], int m)
		{
			for(int i=0; i<m; i++)
			{
				for(int j=0; j<arr[i].size(); j++)
				{
					cout<<arr[i][j]<<" ";
				}
			}
		}


		int main()
		{
			int m=3;
			int n=2;

			vector<int> arr[m];

			for(int i=0; i<m; i++)
			{
				for(int j=0; j<n; j++)
				{
					arr[i].push_back(i);
				}
			}

			printMatrix(arr);

			return 0;
		}



	2. Using vector of vectors

		// We are passing the vector by reference for optimization
		void printMatrix(vector<vector<int>> &vec)
		{
			for(int i=0; i<vec.size(); i++)
			{
				for(int j=0; j<vec[i].size(); j++)
				{
					cout<<vec[i][j]<<" ";
				}
			}
		}


		int main()
		{
			int m=3;
			int n=2;

			vector<vector<int>> vec;

			for(int i=0; i<m; i++)
			{
				vector<int> v;
				for(int j=0; j<n; j++)
				{
					v.push_back(i);
				}

				vec.push_back(v);
			}

			printMatrix(vec);

			return 0;
		}




-> Jagged Array: A 2-D array is called Jagged Array if individual rows of the Array
				 have different number of elements

























Multidimensional Array in Java
-----------------------------------------------------------------------------

-> Example 1:
	
	class Test
	{
		public static void main(String[] args)
		{
			int arr[][] = {{1, 2, 3, 8, 9}, {4, 5, 6}};

			for(int i=0; i<arr.length(); i++)
			{
				for(int j=0; j<arr[i].length(); j++)
				{
					System.out.println(arr[i][j] + " ");
				}
			}
		}
	}




-> Important Point 

	1. Memory allocation in Java is different from C++

	2. We do not specify dimensions with array name
		-> int arr[2][3] is invalid

		-> int arr[][3] is also invalid



-> Example 2:

	class Test
	{
		public static void main(String[] args)
		{
			int m=2, n=3;

			int arr[][] = new int[m][n];

			for(int i=0; i<arr.length(); i++)
			{
				for(int j=0; j<arr[i].length(); j++)
				{
					System.out.println(arr[i][j] + " ");
				}
			}
		}
	}

	O/P: 0 0 0 0 0 0 



-> Example 3: Jagged Array of user specified sizes

	class Test
	{
		public static void main(String[] args)
		{
			int m=3;

			int arr[][] = new int[m][];

			for(int i=0; i<arr.length(); i++)
			{
				arr[i] = new int[i+1];

				for(int j=0; j<arr[i].length(); j++)
				{
					arr[i][j] = i;

					System.out.println(arr[i][j] + " ");
				}

				System.out.println();
			}
		}
	}


























Passing 2-D arrays as arguments in Java
-------------------------------------------------------------------------

-> Example 1: 
	
	class Test
	{
		public static void printMatrix(int arr[][])
		{
			for(int i=0; arr.length(); i++)
			{
				for(int j=0; j<arr[i].length(); j++)
				{
					System.out.println(arr[i][j] + " ");
				}

				System.out.println();
			}
		}


		public static void main(String[] args)
		{
			int arr[][] = {{1, 2, 3}, {4, 5, 6}};

			printMatrix(arr);
		}
	}




















Matrix in Snake Pattern
-----------------------------------------------------------------------------

1. My Solution

	void printMatrixInSnakeForm(vector<vector<int>> vec)
	{
	    for(int i=0; i<vec.size(); i++)
	    {
	        vector<int> v = vec[i];
	        
	        if(i%2 == 0)
	        {
	            for(int j=0; j<v.size(); j++)
	            {
	                cout<<v[j]<<" ";
	            }
	            cout<<endl;
	        }
	        else
	        {
	            for(int j=v.size()-1; j>=0; j--)
	            {
	                cout<<v[j]<<" ";
	            }
	            cout<<endl;
	        }
	    }
	}

	int main()
	{
	    vector<vector<int>> vec = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};
	    
	    printMatrixInSnakeForm(vec);

	    return 0;
	}



2. Psuedo code to print the Snake Pattern

	void printSnake(int mat[R][C])
	{
		for(int i=0; i<R; i++)
		{
			if(i%2 == 0)
			{
				for(int j=0; j<C; j++)
				{
					print(mat[i][j] + " ");
				}
			}
			else
			{
				for(int j = C-1; j >= 0; j--)
				{
					print(mat[i][j] + " ");
				}
			}
		}
	}


	Time Complexity:	O(R*C)






















Matrix Boundary Traversal
------------------------------------------------------------

1. Program for Matrix boundary traversal

	void matrixBoundaryTraversal(int mat[R][C])
	{
		if(R == 1)
		{
			for(int i=0; i<C; i++)
			{
				print(mat[0][i] + " ");
			}
		}
		else if(C == 1)
		{
			for(int i=0; i<R; i++)
			{
				print(mat[i][0] + " ");
			}
		}
		else
		{
			for(int i=0; i<C; i++)
			{
				print(mat[0][i] + " ");
			}

			for(int i=1; i<R; i++)
			{
				print(mat[i][C-1] + " ");
			}

			for(int i = C-2; i >= 0; i--)
			{
				print(mat[R-1][i] + " ");
			}

			for(int i = R-2; i >= 1; i--)
			{
				print(mat[i][0] + " ");
			}
		}
	}


	Time Complexity:	O(R+C)



















Transpose of a Matrix
---------------------------------------------------------------

1. My Solution

	void transpose(vector<vector<int>> &vec)
	{
	    int R = vec.size();
	    int C = vec[0].size();
	    
	    if(R != C)
	    {
	        return;
	    }
	    
	    for(int i=0; i<R; i++)
	    {
	        for(int j=0; j<C; j++)
	        {
	            if(i < j)
	            {
	                swap(vec[i][j], vec[j][i]);
	            }
	        }
	    }
	}

	int main()
	{
	    vector<vector<int>> vec = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16} };
	    
	    cout<<"Before Transpose"<<endl;
	    for(int i=0; i<vec.size(); i++)
	    {
	        for(int j=0; j<vec[0].size(); j++)
	        {
	            cout<<vec[i][j]<<" ";
	        }
	        cout<<endl;
	    }
	    
	    transpose(vec);
	    
	    cout<<"After Transpose"<<endl;
	    for(int i=0; i<vec.size(); i++)
	    {
	        for(int j=0; j<vec[0].size(); j++)
	        {
	            cout<<vec[i][j]<<" ";
	        }
	        cout<<endl;
	    }

	    return 0;
	}



2. Naive Solution

	void transpose(int mat[n][n])
	{
		int temp[n][n];

		for(int i=0; i<n; i++)
		{
			for(int j=0; j<n; j++)
			{
				temp[i][j] = mat[j][i];		// temp[j][i] = mat[i][j]
			}
		}

		for(int i=0; i<n; i++)
		{
			for(int j=0; j<n; j++)
			{
				mat[i][j] = temp[i][j];
			}
		}
	}



3. Efficient Solution

	-> In-Place
	-> One Traversal


	void transpose(int mat[][])
	{
		for(int i=0; i<n; i++)
		{
			for(int j = i+1; j<n; j++)
			{
				swap(mat[i][j], mat[j][i]);
			}
		}
	}























Rotate Matrix Anti-Cloakwise by 90
-------------------------------------------------------------------

1. My Solution

	void rotateMatrixBy90AntiClockwise(vector<vector<int>> &vec)
	{
	    int n = vec.size();
	    
	    int arr[n][n];
	    
	    for(int i=0; i<n; i++)
	    {
	        int k = 0;
	        for(int j=n-1; j>=0; j--)
	        {
	            arr[k++][i] = vec[i][j];
	        }
	    }
	    
	    for(int i=0; i<n; i++)
	    {
	        for(int j=0; j<n; j++)
	        {
	            vec[i][j] = arr[i][j];
	        }
	    }
	    
	}



2. Naive Solution

	-> Time Complexity: 	O(N^2)
	-> Space Complexity: 	O(N^2)


	-> Last Column becomes first row
	-> Second Last column becomes second row
		......
		.....
		....
		...


	void rotate90(int mat[R][C])
	{
		int temp[n][n];

		for(int i=0; i<n; i++)
		{
			for(int j=0; j<n; j++)
			{
				temp[n-j-1][i] = mat[i][j];
			}
		}

		for(int i=0; i<n; i++)
		{
			for(int j=0; j<n; j++)
			{
				mat[i][j] = temp[i][j];
			}
		}
	}



3. Efficient Solution

	i) Find transpose of Matrix

	ii) Reverse individual columns i.e., reverse the matrix using mid row as an axis.


	void transpose(vector<vector<int>> &vec)
	{
	    int n = vec.size();
	    
	    for(int i=0; i<n; i++)
	    {
	        for(int j=0; j<n; j++)
	        {
	            if(i<j)
	            {
	                swap(vec[i][j], vec[j][i]);
	            }
	        }
	    }
	}

	void rotate90(vector<vector<int>> &vec)
	{
	    int n = vec.size();
	    
	    transpose(vec);
	    
	    cout<<"Matrix After the Transpose"<<endl;
	    
	    for(int i=0; i<vec.size(); i++)
	    {
	        for(int j=0; j<vec[0].size(); j++)
	        {
	            cout<<vec[i][j]<<" ";
	        }
	        cout<<endl;
	    }
	    
	    // To reverse the Matrix along row axis
	    for(int i=0, k=n-1; i<k; i++, k--)
	    {
	        for(int j=0; j<n; j++)
	        {
	            swap(vec[i][j], vec[k][j]);
	        }
	    }
	}



	int main()
	{
	    vector<vector<int>> vec = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16} };
	    
	    cout<<"Matrix before the Rotation"<<endl;
	    
	    for(int i=0; i<vec.size(); i++)
	    {
	        for(int j=0; j<vec[0].size(); j++)
	        {
	            cout<<vec[i][j]<<" ";
	        }
	        cout<<endl;
	    }
	    
	    rotate90(vec);
	    
	    cout<<"Matrix After the Rotation"<<endl;
	    
	    for(int i=0; i<vec.size(); i++)
	    {
	        for(int j=0; j<vec[0].size(); j++)
	        {
	            cout<<vec[i][j]<<" ";
	        }
	        cout<<endl;
	    }

	    return 0;
	}



3. Efficient Solution (Psuedo Code)

	-> Find transpose of Matrix
	-> Reverse individual columns


	void rotate90(int mat[n][n])
	{
		// Converting Matrix to it's Transpose
		for(int i=0; i<n; i++)
		{
			for(int j = i+1; j<n; j++)
			{
				swap(mat[i][j], mat[j][i]);
			}
		}


		// Reversing the columns
		for(int i=0; i<n; i++)
		{
			int low = 0; 
			int high = n-1;

			while(low < high)
			{
				swap(mat[low][i], mat[high][i]);

				low++;
				high--;
			}
		}
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)



















Spiral Traversal of Matrix
---------------------------------------------------------------
#Revisit

1. Programme for Spiral Traversal of Matrix

	void printSpiral(int mat[][], int R, int C)
	{
		int top = 0;
		int bottom = R-1;
		int left = 0;
		int right = C-1;


		while((top <= bottom) && (left <= right))
		{
			// Printing the top row
			for(int i=left; i <= right; i++)
			{
				print(mat[top][i] + " ");
			}

			top++;


			// Printing the right column
			for(int i=top; i<=bottom; i++)
			{
				print(mat[i][right] + " ");
			}

			right--;


			if(top <= bottom)
			{
				// Printing bottom row (reverse order)
				for(int i=right; i >= left; i--)
				{
					print(mat[bottom][i] + " ");
				}

				bottom--;
			}


			if(left <= right)
			{
				// Printing Left Column (reverse order)
				for(int i=bottom; i >= top; i--)
				{
					print(mat[i][left] + " ");
				}

				left++;
			}
		}
	}


	Time Complexity: 	O(R*C)





















Search in Row-wise and Column-wise sorted Matrix
------------------------------------------------------------------------

1. Naive Solution

	void search(int mat[R][C], int x)
	{
		for(int i=0; i<R; i++)
		{
			for(int j=0; j<C; j++)
			{
				if(mat[i][j] == x)
				{
					print("Found at (" + i + "," + j + ")");

					return;
				}
			}
		}

		print("Not Found");
	}


	Time Complexity:	O(R*C)



2. Efficient Solution: O(R+C)

	-> Begin from the top-right corner

	-> If x is same, print position and return 

	-> If x is smaller than current element, move left

	-> If x is greater than current element, move down


	Note: 
		We can do the same task by beginning from bottom-left corner



	void search(int mat[R][C], int x)
	{
		int i=0; 
		int j=C-1;

		while((i<R) && (j >= 0))
		{
			if(mat[i][j] == x)
			{
				print("Found at (" + i + "," + j + ")");y
				return;
			}
			else if(x < mat[i][j])
			{
				// move left
				j--;
			}
			else
			{
				// move down
				i++;
			}
		}


		print("Not Found");
	}


	Time Complexity:	O(R+C)
























Median of a Row-wise Sorted Matrix in C++
----------------------------------------------------------------------------
#Revisit
#Revise

-> Given:
	1. Odd sized Array
	2. Each Row is sorted in increasing order
	3. All elements of the Matrix are distinct



1. Naive Solution

	1. Put all elements in an array 		// O(R*C)

	2. Sort the Array 						// O(RC*log(RC))

	3. Return the middle element of the sorted Array 		// O(1)


	Note: 
		-> Overall time complexity : 	O(RC*log(RC))

		-> Overall time complexity can be optimized by modifying Step 2 & 3
			For finding the median, instead of sorting the array, we can use
			quick select Algorithm to find the element at median index,
			Which will bring Overall Time Complexity to O(R*C)




2. Efficient Solution

	-> Time Complexity:		O(R*log(maxElement - minElement)*log(C))


	int matrixMedian(int mat[][MAX], int R, int C)
	{
		int min = mat[0][0];	// Minimum will be in 1st column only
		int max = mat[0][C-1];	// Maximum will be in last column only

		// Loop to find min and max in Matrix : O(R)
		for(int i=1; i<R; i++)
		{
			if(mat[i][0] < min)
			{
				min = mat[i][0];
			}

			if(mat[i][C-1] > max)
			{
				max = mat[i][C-1];
			}
		}


		int medPos = (R*C + 1)/2;

		while(min < max)
		{
			int mid = (min+max)/2;
			int midPos = 0;

			for(int i=0; i<R; i++)
			{
				midPos += upper_bound(mat[i], mat[i]+C, mid) - mat[i];
			}

			if(midPos < medPos)
			{
				min = mid+1;
			}
			else
			{
				max = mid;
			}
		}

		return min;		// return max;
	}




















Median of a Row-wise Sorted Matrix in Java
----------------------------------------------------------------------------

1. Efficient Solution

	int matrixMedian(int mat[][], int R, int C)
	{
		int min = mat[0][0];
		int max = mat[0][C-1];

		for(int i=1; i<R; i++)
		{
			if(mat[i][0] < min)
			{
				min = mat[i][0];
			}

			if(mat[i][C-1] > max)
			{
				max = mat[i][C-1];
			}
		}


		int medPos = (R*C + 1)/2;

		while(min < max)
		{
			int mid = (min+max)/2;

			int midPos = 0;

			for(int i=0; i<R; i++)
			{
				int pos = Arrays.binarySearch(mat[i], mid) + 1;

				midPos += Math.abs(pos);
			}

			if(midPos < medPos)
			{
				min = mid+1;
			}
			else
			{
				max = mid;
			}
		}

		return min;		// return max
	}























































































































































#########################################################
9. Hashing
#########################################################


Introduction to Hashing
---------------------------------------------------------

-> Hashing is mainly used to implement "Dictonaries", where we have
	"key-value" pair. 
	It is also used to implement "Sets", where we have only keys.



-> Hashing provides "Search", "Insert" and "Delete" operations in O(1) time on average.


-> In Hash-Table or Hashing, we always have unique values. No duplicates are allowed.



-> Hashing is not useful for following cases:
	1. Finding closest value
		-> AVL Tree or Red Black Tree is more suitable for this problem

	2. Sorted Data
		-> AVL Tree or Red Black Tree is more suitable for this problem

	3. Prefix Searching
		-> "Trie" data structure is suited for this problem
























Hashing Applications
----------------------------------------------------

-> Hash Table is the second most used data structure after Array data structure.


-> Applications of Hashing
	1. Dictionaries

	2. Database Indexing

	3. Cryptography

	4. Caches

	5. Symbol Tables in Compilers/Interpreters

	6. Routers

	7. Getting data from databases

	8. Many more...


























Direct Address Table
--------------------------------------------------------

-> Problems with Direct Address Table
	1. It can not handle large values

	2. It can not be used if the keys are floating point numbers

	3. It can not be used if the keys are strings or addresses point numbers



















Hashing Functions
----------------------------------------------------------

-> How Hash Function Work?
	1. Should always map a large key to same small key

	2. Should generate values from 0 to m-1, if m is the size of Hash Table

	3. Should be fast, O(1) for integers and O(len) for string of length "len"

	4. Should uniformly distribute large keys into Hash Table slots 



-> Size of Hash Table is proportional to number of keys


-> Example Hash Functions
	
	1. h(large_key) = large_key % m
		-> Ideally "m" is chosen as a prime number close to hash table size

	2. For strings, weighted sum
		-> str[] = "abcd"

		-> (str[0]*x^0 + str[1]*x^1 + str[2]*x^2 + str[3]*x^3) % m

	3. Universal Hashing
		-> One hash function is randomly picked from a group of hash functions




























Collison Handling
--------------------------------------------------------------

-> Birthday Paradox: It says that if there are 23 people in a room, then there is a 
					 probability of "1/2" that the two people have the same birthday,
					 i.e., there is 50% chance of two people among 23 people 
					 having the same birthday.
					 If there are 70 people then the chances goes to 99.9%




-> If we know keys in advance, then we can do Perfect Hashing, which guarantees no collision



-> If we do not knows keys in advance, then we can use one of the following
	
	1. Chaining

	2. Open Addressing
		-> Linear Probing
		-> Quadratic Probing
		-> Double Hashing

























Chaining
---------------------------------------------------

-> Performance of Chaining
	
	Let, m = number of slots in Hash Table
		 n = number of keys to be inserted


	-> Load Factor() = n/m

		-> If the Load Factor is high i.e., Hash Table size is small 
			then there will be more collisions


	-> Expected Chain Length = 				// Assuming Hashing does uniform distribution


	-> Expected Time to Search = O(1 + )		// 1 for hash function computation,  for chain length


	-> Expected Time to Insert/Delete = O(1 + )





-> Data Structures for Storing Chains
	
	1. Linked List
		a. Search: O(chainLength)
		b. Delete: O(chainLength)
		c. Insert: O(chainLength)
		d. Not cache friendly

	2. Dynamic Sized Arrays
		-> vectors in C++
		-> ArrayList in Java
		-> list in Python

		a. Search: O(chainLength)
		b. Delete: O(chainLength)
		c. Insert: O(chainLength)
		d. Cache friendly 

	3. Self Balancing BST
		-> AVL Tree
		-> Red Black Tree

		a. Search: O(log(chainLength))
		b. Delete: O(log(chainLength))
		c. Insert: O(log(chainLength))
		d. Not cache friendly



-> From Java v8, they have started using Self Balancing BST for HashMaps




























Implementation of Chaining
----------------------------------------------------------------

-> Implementation of Chaining in C++

	struct MyHash
	{
		int BUCKET;

		list<int> *table;

		MyHash(int b)
		{
			BUCKET = b;
			table = new list<int>[b];
		}

		void insert(int key)
		{
			int i = key % BUCKET;

			table[i].push_back(key);
		}

		bool search(int key)
		{
			int i = key % BUCKET;

			for(auto x : table[i])
			{
				if(x == key)
				{
					return true;
				}
			}

			return false;
		}

		void remove(int key)
		{
			int i = key % BUCKET;

			table[i].remove(key);
		}
	}






-> Implementation of Chaining in Java

	class MyHash
	{
		int BUCKET;

		ArrayList<LinkedList<Integer>> table;

		MyHash(int b)
		{
			BUCKET = b;

			table = new ArrayList<LinkedList<Integer>>();

			for(int i=0; i<b; i++)
			{
				table.add(new LinkedList<Integer>());
			}
		}


		void insert(int key)
		{
			int i = key % BUCKET;

			table.get(i).add(key);
		}


		boolean search(int key)
		{
			int i = key % BUCKET;

			return table.get(i).contains(key);
		}


		void remove(int key)
		{
			int i = key % BUCKET;

			table.get(i).remove((Integer)i);
		}
	}
























Open Addressing
-----------------------------------------------------

-> Important Points

	1. It is used for handling collision in hashing

	2. No. of slots in Hash Table >= No. of "keys" to be inserted

	3. Cache Friendly




-> There are multiple ways of implementing Open Addressing

	1. Linear Probing
		-> Linearly search for next empty slot in case of collision 
		-> hash(key, i) = (hash(key) + i) % 7
		-> Has the problem of "Clustering"

	2. Quadratic Probing
		-> hash(key, i) = (hash(key) + i^2) % m 		// m is Hash Table size
		-> Has the problem of "Secondary Clustering"
		-> It might happen that it does not find empty slot even if there exist an empty slot
		-> If the load factor() is less than 0.5 and m is prime number, then only it guarantees
			to find an empty slot

	3. Double Hashing
		-> hash(key, i) = (h1(key) + i*h2(key)) % m



-> Open Addressing using Linear Probing

	1. To resolve the problem with delete, we mark the cell as "deleted" not as "empty"

	2. Clustering (A problem with linear probing)
		-> Quadratic Probing 
		-> Double Hashing
























Double Hashing
----------------------------------------------------

-> Important Points

	1. Here we use two hash functions

	2. hash(key, i) = (h1(key) + i*h2(key)) % m

	3. If h2(key) is relatively prime to m, then it always
		finds a free slot if there is one

	4. Distributes keys more uniformly than linear probing and quadratic hashing

	5. No clustering 



-> Algorithm for Insert using Double Hashing

	void doubleHashingInsert(key)
	{
		if(table is full)
		{
			return error;
		}

		probe = h1(key);
		offset = h2(key);		// for Linear Probing: offset = 1

		while(table[probe] is occupied)
		{
			probe = (probe + offset) % m;
		}

		table[probe] = key;
	}




-> Performance Analysis of Unsuccessful search in Double Hashing(Open Addressing)

	1.  = n/m = No. of keys/No. of slots 		// Should be <= 1

	2. Assumption: Every probe sequence looks at a random location

	3.  is the Fraction of table which is filled/occupied

	4. (1 - ) Fraction of the Table is empty

	5. Expected No. of probes requires = 1/(1 - ) 



























Implementation of Open Addressing (Linear Probing)
----------------------------------------------------------------

-> Assumption
	1. Empty cell is identified by -1

	2. Deleted cell is identified by -2




-> Simple Implementation of Open Addressing in C++

	struct MyHash
	{
		int *arr;
		int cap;
		int size;

		MyHash(int c)
		{
			cap = c;
			size = 0;
			for(int i=0; i<cap; i++)
			{
				arr[i] = -1;	// -1 denotes empty
			}
		}

		int hash(int key)
		{
			return (key % cap);
		}

		bool search(int key)
		{
			int h = hash(key);
			int i = h;

			while(arr[i] != -1)
			{
				if(arr[i] == key)
				{
					return true;
				}

				i = (i+1)%cap;

				if(i == h)
				{
					return false;
				}
			}

			return false;
		}


		bool insert(int key)
		{
			if(size == key)
			{
				return false;
			}

			int i = hash(key);

			while( (arr[i] != -1) && (arr[i] != -2) && (arr[i] != key) )
			{
				i = (i+1)%cap;
			}

			if(arr[i] == key)
			{
				return false;
			}
			else
			{
				arr[i] = key;
				size++;
				return true;
			}
		}


		bool erase(int key)
		{
			int h = hash(key);
			int i = h;

			while(arr[i] != -1)
			{
				if(arr[i] == key)
				{
					arr[i] = -2;
					return true;
				}

				i = (i+1)%cap;

				if(i == h)
				{
					return false;
				}
			}

			return false;
		}
	};





-> Simple Implementation of Open Addressing in Java

	class MyHash
	{
		int []arr;
		int cap;
		int size;

		MyHash(int c)
		{
			cap = c;
			size = 0;

			for(int i=0; i<cap; i++)
			{
				arr[i] = -1;
			}
		}


		int hash(int key)
		{
			return (key % cap);
		}


		boolean search(int key)
		{
			int h = hash(key);
			int i = h;

			while(arr[i] != -1)
			{
				if(arr[i] == key)
				{
					return true;
				}

				i = (i+1)%cap;

				if(i == h)
				{
					return false;
				}
			}

			return false;
		}


		boolean insert(int key)
		{
			if(size == key)
			{
				return false;
			}

			int i = hash(key);

			while( (arr[i] != -1) && (arr[i] != -2) && (arr[i] != key) )
			{
				i = (i+1)%cap;
			}

			if(arr[i] == key)
			{
				return false;
			}
			else
			{
				arr[i] = key;
				size++;
				return true;
			}
		}


		boolean erase(int key)
		{
			int h = hash(key);
			int i = h;

			while(arr[i] != -1)
			{
				if(arr[i] == key)
				{
					arr[i] = -2;
					return true;
				}

				i = (i+1)%cap;

				if(i == h)
				{
					return false;
				}
			}

			return false;
		}
	}




























Chaining vs Open Addressing
----------------------------------------------------------

Chaining: 			Hash Table never fills
Open Addressing:	Table may become full & Resizing becomes mandatory



Chaining: 			Less sensitive to Hash Functions	
Open Addressing:	Extra care required for avoiding Clustering



Chaining: 			Poor cache performance
Open Addressing: 	Cache friendly	



Chaining: 			Extra space for links
Open Addressing: 	Extra space might be needed to achieve same performance as chaining



Chaining: 			Performance(Better) = 1 + 	
Open Addressing:	Performance(Poor)   = 1/(1 - )



























unordered_set in C++ STL
-------------------------------------------------------------------

-> "set" is based on "Red Black Tree"

-> "unordered_set" is based on Hashing


-> Some useful predefined functions for unordered_set

	1. insert(key)
		-> Time Complexity: O(1) on average

	2. begin()
		-> It returns an iterator to the first element
		-> Time Complexity: O(1)

	2.1 cbegin()
		-> Time Complexity: O(1)

	3. end()
		-> It returns an iterator beyond the last element
		-> Time Complexity: O(1)

	3.1 cend()
		-> Time Complexity: O(1)

	4. size()
		-> Time Complexity: O(1)

	5. clear()
		-> clears(delete all the elements of) the set

	6. find(key)
		-> If the element/key is present then it returns iterator to that element
		-> If the element is not present then it returns iterator to end i.e., s.end()
		-> Time Complexity: O(1) on average

	7. count(key)
		-> can be used as a substitute to the find() function
		-> It returns "1" if the element is present
		-> It returns "0" if the element is not present
		-> Time Complexity: O(1) on average

	8. erase(key) / erase(iterator)
		-> can be used to remove "an item" or "a range of item"
		-> Time Complexity: O(1) on average

	9. empty()
		-> Returns "true" if the size is 0
		-> Returns "false" if the size is not 0
		-> Time Complexity: O(1)




-> Example 1

	#include <iostream>
	#include <unordered_set>

	using namespace std;

	int main()
	{
		unordered_set<int> s;

		s.insert(10);
		s.insert(5);
		s.insert(15);
		s.insert(20);

		for(int x: s)
		{
			cout<<x<<" ";		// Elements will get printed in any order
		}

		for(auto it = s.begin(); it != s.end(); it++)
		{
			cout<<(*it)<<" ";	// Elements will get printed in any order
		}

		cout<<endl;

		cout<<s.size()<<endl;	// o/p: 4

		s.clear();

		cout<<s.size<<endl;		// o/p: 0

		return 0;
	}



-> Example 2

	int main()
	{
		unordered_set<int> s;

		s.insert(10);
		s.insert(5);
		s.insert(15);
		s.insert(20);

		cout<<s.size()<<endl;			// o/p: 4

		s.erase(15);					// erase an item using key

		cout<<s.size()<<endl;			// o/p: 3

		auto it = s.find(10);			// it is an iterator pointing to 10
		s.erase(it);					// erase an item using iterator

		cout<<s.size<<endl;				// o/p: 2


		s.erase(s.begin(), s.end());	// erase the range from beginning and before the end iterator
										// last iterator is not included in the range

		cout<<s.size()<<endl;			// o/p: 0

		return 0;
	}








-> Applications of "unordered_set": We can use anywhere when we need following operations
	(or a subset of following operations quickly)

		1. Search
		2. Insert
		3. Delete


























unordered_map in C++ STL
---------------------------------------------------------


-> Important Points
	
	1. "unordered_map" is based on hashing
		-> "map" is based on "Red Black Tree", which is a self balancing Tree

	2. Used to store key, value pair

	3. Uses Hashing

	4. No order of keys

	5. "unordered_map" doesn't stores the keys in ordered form
		-> map stores the keys in ordered form
		-> In general keys in map are ordered in increasing order, but we can use 
			our own order when using "map"

	6. unordered container with fast Search, Insert and Delete operations: O(1) on average
		-> In case of "map" data structure, Search, Insert and Delete operations are of O(log(N))


	7. [] operator
		-> square bracket is actually a member access operator
		-> If the key is present, then it returns a reference to the value corresponding to that key
		-> If the key is not present, then it inserts that key and returns the reference for that key
		-> It initializes values as default	value





-> Example 1:

	#include <iostream>
	#include <unordered_map> m;

	using namespace std;

	int main()
	{
		unordered_map<string, int> m;

		m["gfg"] = 20;
		m["ide"] = 30;

		m.insert({"courses", 15});

		for(auto x : m)
		{
			// x is a pair 
			cout<<x.first<<" "<<x.second<<endl;
		}


		return 0;
	}



-> Example 2:

	#include <iostream>
	#include <unordered_map> m;

	using namespace std;

	int main()
	{
		unordered_map<string, int> m;

		m["gfg"] = 20;
		m["ide"] = 30;
		m["courses"] = 15;

		if(m.find("ide") != m.end())
		{
			cout<<"Found \n";
		}
		else
		{
			cout<<"Not Found \n";
		}


		auto it = m.find("courses");

		if(it != m.end())
		{
			cout<<it->first<<endl;		// o/p: courses
			cout<<it->second<<endl;		// o/p: 30
		}


		for(auto it = m.begin(); it != m.end(); it++)
		{
			cout<<(it->first)<<" "<<(it->second)<<endl;
		}

		cout<<m.count("ide")<<endl;				// o/p: 1
		cout<<m.count("notPresent")<<endl;		// o/p: 0

		return 0;
	}



-> Example 3: 

	int main()
	{
		unordered_map<string, int> m;

		m["gfg"] = 20;
		m["ide"] = 30;
		m["courses"] = 15;
		m["abc"] = 3;
		m["abhishek"] = 8;

		cout<<m.size()<<endl;			// o/p: 5

		m.erase("abhishek");
		cout<<m.size()<<endl;			// o/p: 4

		m.erase(m.begin());	
		cout<<m.size()<<endl;			// o/p: 3

		m.erase(m.begin(), m.end());	
		cout<<m.size()<<endl;			// o/p: 0

		return 0;
	}



-> Functions/Methods having "Time Complexity = O(1)"

	1. begin()
	2. end()
	3. size();
	4. empty();


-> Functions/Methods having "Time Complexity = O(1) on average"

	1. count()
	2. find()
	3. erase(key)
	4. insert()
	5. []
	6. at



























HashSet in Java
--------------------------------------------------------

-> "HashSet" is used to store a set of keys and it uses "hash table" to store these keys.


-> Important methods in HashSet Class
	
	1. add()
		-> returns "True" if the item is added
		-> returns "False" if the item is already present
		-> O(1) on average

	2. contains()
		-> O(1) on average

	3. remove()
		-> If the key is present, it removes it and returns "True"
		-> Otherwise, it returns "False"
		-> O(1) on average

	4. size()
		-> O(1)

	5. isEmpty()
		-> O(1)

	6. clear()
		-> clears all the content of HashSet



-> The operations like "add()", "contains()" and "remove()" takes O(1) time on average.



-> Example 1:

	import java.util.*;

	class Test
	{
		public static void main(String args[])
		{
			HashSet<String> h = new HashSet<String>();

			h.add("gfg");
			h.add("courses");
			h.add("ide");

			System.out.println(h);							// o/p: [gfg courses ide]

			System.out.println(h.contains("ide"));			// o/p: True


			Iterator<String> it = h.iterator();

			while(it.hasNext())
			{
				System.out.print(h.next() + " ");			// o/p: gfg courses ide
			}
		}
	}



-> Example 2:

	class Test
	{
		public static void main(String args[])
		{
			HashSet<String> h = new HashSet<String>();

			h.add("gfg");
			h.add("courses");
			h.add("ide");

			System.out.println(h.size());				// o/p: 3

			h.remove("ide");							
			System.out.println(h.size());				// o/p: 2


			for(String s: h)
			{
				System.out.print(s + " ");				// o/p: gfg courses
			}

			System.out.println(h.isEmpty());			// o/p: False
		}
	}





























HashMap in Java
-------------------------------------------------------------------------

-> "HashMap" is used to store "key-value" pair

-> It implements "Map" Interface


-> Some important methods of "HashMap" class

	1. put();
		-> O(1) on average

	2. containsKey()
		-> O(1) on average

	3. containsValue()
		-> O(1) on average

	4. remove()
		-> If the key is present then it removes the key and returns the "value"
		-> If the key is not present then it returns "NULL"
		-> O(1) on average

	5. get(key)
		-> If the key is present, it returns the corresponding value
		-> If the key is not present, it returns "null"
		-> O(1) on average

	6. size()
		-> O(1)

	7. isEmpty()
		-> O(1)



-> Example 1:

	class Test
	{
		public static void main(String args[])
		{      
			HashMap<String, Integer> m = new HashMap<String, Integer>();

			m.put("gfg", 10);
			m.put("ide", 15);
			m.put("courses", 20);

			System.out.println(m);						// o/p: [gfg=10, courses=20, ide=15]
			System.out.println(m.size());				// o/p: 3


			// Method to iterate HashMap
			for(Map.entry<String, Integer> e: m.entrySet())
			{
				System.out.print(e.getKey() + " " + e.getValue());
			}
		}
	}





























Count Distinct Elements
-----------------------------------------------------------------------

1. My Solution

	int countDistinct(vector<int> v)
	{
	    unordered_set<int> s;
	    
	    for(int i=0; i<v.size(); i++)
	    {
	        s.insert(v[i]);
	    }
	    
	    return s.size();
	}


	Time Complexity:	O(N)
	Space Complexity:	O(1)




2. Naive Solution

	int countDistinct(int arr[], int n)
	{
		int res = 0;

		for(int i=0; i<n; i++)
		{
			bool flag = false;

			for(int j=0; j<i; j++)
			{
				if(arr[i] == arr[j])
				{
					flag = true;
					break;
				}
			}

			if(flag == false)
			{
				res++;
			}
		}


		return true;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)






3.1 Better Solution(C++ Implementation)

	int countDistinct(int arr[], int n)
	{
		unordered_set<int> s;

		for(int i=0; i<n; i++)
		{
			s.insert(arr[i]);
		}

		return s.size();
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)





3.2 Better Solution(Java Implementation)

	int countDistinct(int arr[])
	{
		HashSet<Integer> s = new HashSet<>();

		for(int i=0; i<arr.length(); i++)
		{
			s.add(arr[i]);
		}

		return s.size();
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)






4.1 Improved Better Solution(C++ Implementation)

	int countDistinct(int arr[], int n)
	{
		unordered_set<int> s(arr, arr+n);		// initializing using start and end iterator

		return s.size();
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)





4.2 Improved Better Solution(Java Implementation)

	int countDistinct(int arr[])
	{
		HashSet<Integer> s = new HashSet<>(Arrays.asList(arr));

		return s.size();
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)
























Frequecies of array elements
-------------------------------------------------------------------------

1. My Solution

	void printFrequeciesOfElements(vector<int> v)
	{
	    unordered_map<int, int> m;
	    
	    for(int i=0; i<v.size(); i++)
	    {
	        if(m.find(v[i]) == m.end())
	        {
	            m[v[i]] = 1;
	        }
	        else
	        {
	            m[v[i]]++;
	        }
	    }
	    
	    for(auto it: m)
	    {
	        cout<<it.first<<": "<<it.second<<endl;
	    }
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)




2. Naive Solution

	void printFreq(int arr[], int n)
	{
		for(int i=0; i<n; i++)
		{
			bool flag = false;

			// checking if the element is seen before
			for(int j=0; j<i; j++)
			{
				if(arr[i] == arr[j])
				{
					flag = true;
					break;
				}
			}

			// If the elements is seen before, then ignore that element
			if(flag == true)
			{
				continue;
			}


			// If the element is not seen before, then count the frequency
			int freq = 1;

			for(int j = i+1; j<n; j++)
			{
				if(arr[i] == arr[j])
				{
					freq++;
				}
			}

			cout<<arr[i]<<" "<<freq<<endl;
		}
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)



3.1. Efficient Solution(C++ Implementation)

	void printFreq(int arr[], int n)
	{
		unordered_map<int, int> h;

		for(int i=0; i<n; i++)
		{
			h[arr[i]]++;		// Since, the default values are 0
								// for the first time, when the key is not there, it will insert the key with 
									// value 0, then do the post-increment
		}


		for(auto e: h)
		{
			cout<<e.first<<" "<<e.second<<endl;
		}
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)




3.2. Efficient Solution(Java Implementation)

	void printFreq(int arr[])
	{
		HashMap<Integer, Integer> h = new HashMap<>();

		for(int x: arr)
		{
			h.put( x, h.getOrDefault(x,0) + 1 );
		}


		for(map.Entry<Integer, Integer> e: h.entrySet())
		{
			System.out.println(e.getKey() + " " + e.getValue());
		}
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)



-> In Java "LinkedHashMap" maintains order of insertion of "keys"





























Intersection of Two Arrays
------------------------------------------------------------------------

-> To find Intersection of Two Unsorted Arrays

-> The Arrays can have repetitions, but in the Intersections there must be distinct elements only


1. My Solution

	int countOfIntersection(vector<int> v1, vector<int> v2)
	{
	    unordered_set<int> s;
	    
	    for(int i=0; i<v1.size(); i++)
	    {
	        s.insert(v1[i]);
	    }
	    
	    int count = 0;
	    for(int i=0; i<v2.size(); i++)
	    {
	        if(s.find(v2[i]) != s.end())
	        {
	            count++;
	            s.erase(v2[i]);
	        }
	    }
	    
	    return count;
	}






2. Naive Solution

	int intersection(int a[], int b[], int m, int n)
	{
		int res = 0;

		for(int i=0; i<m; i++)
		{
			bool flag = false;

			for(int j=0; j < i-1; j++)
			{
				if(a[j] == a[i])
				{
					flag = true;
					break;
				}
			}

			if(flag == true)
			{
				continue;
			}


			for(int j=0; j<n; j++)
			{
				if(a[i] == b[j])
				{
					res++;
					break;
				}
			}
		}


		return res;
	}


	Time Complexity:	O(m*(m+n))
	Space Complexity:	O(1)





3. Efficient Solution

	int interaction(int a[], int b[], int m, int n)
	{
		unordered_set<int> s;				// Java: HashSet<Integer> s = new HashSet<>();


		for(int i=0; i<m; i++)
		{
			s.insert(a[i]);					// s.add(a[i]);
		}

		int res = 0;

		for(int j=0; j<n; j++)
		{
			if(s.find(b[j]) != s.end())		// Java: if(s.contains(b[j]))
			{
				res++;
				s.erase(b[j]);				// Java: s.remove(b[j])
			}
		}


		return res;
	}


	Time Complexity:	O(m+n)
	Space Complexity:	O(m)			   	// Space Complexity optimized by choosing m such that m<n
























Union of two unsorted arrays
--------------------------------------------------------------------------

-> Given Two unsorted Array

-> To find count of elements in the union of two Arrays (Count only distinct elements in the union)



1. My Solution

	int countOfDistinctUnionElements(vector<int> v1, vector<int> v2)
	{
	    unordered_set<int> s;
	    
	    for(int i=0; i<v1.size(); i++)
	    {
	        s.insert(v1[i]);
	    }
	    
	    for(int i=0; i<v2.size(); i++)
	    {
	        s.insert(v2[i]);
	    }
	    
	    return s.size();
	}






2. Naive Solution

	int findUnion(int a[], int b[], int m, int n)
	{
		int c[m+n];

		for(int i=0; i<m; i++)
		{
			c[i] = a[i];
		}

		for(int i=0; i<n; i++)
		{
			c[m+i] = b[i];
		}

		int res = 0;
		for(int i=0; i < m+n; i++)
		{
			bool flag = false;

			for(int j=0; j<i; j++)
			{
				if(c[i] == c[j])
				{
					flag = true;
					break;
				}
			}

			if(flag == false)
			{
				res++;
			}
		}


		return res;
	}


	Time Complexity:	O((m+n)*(m+n));
	Space Complexity:	O(m+n)

	int findUnion(int a[], int b[], int m, int n)
	{
		unordered_set<int> s(a, a+n);		// Adding all the element of Array a[] to Set

		for(int i=0; j<n; j++)
		{
			s.insert(b[i]);
		}

		return s.size();
	}


	Time Complexity:	O(m+n);
	Space Complexity:	O(m+n);





























Pair with given sum in unsorted array
----------------------------------------------------------------------------

-> For Sorted Array, we can perform the same task in O(N) time, using "two pointer approach"

-> For Unsorted array, we can first sort the Array in O(Nlog(N)) time and find the pair

-> We can use "Set Data Structure" to find the pair in unsorted array in O(N) time



1. My Solution

	bool pairExist(vector<int> v, int sum)
	{
	    int diff;
	    
	    unordered_set<int> s;
	    
	    for(int i=0; i<v.size(); i++)
	    {
	        diff = sum-v[i];
	        
	        if(s.find(diff) != s.end())
	        {
	            return true;
	        }
	        
	        s.insert(v[i]);
	    }
	    
	    return false;
	}






2. Naive Solution

	bool isPair(int arr[], int n, int sum)
	{
		for(int i=0; i<n; i++)
		{
			for(int j=0; j<n; j++)
			{
				if(arr[i]+arr[j] == sum)
				{
					return true;
				}
			}
		}

		return false;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)





3. Efficient Solution

	bool isPair(int arr[], int n, int sum)
	{
		unordered_set<int> s;

		for(int i=0; i<n; i++)
		{
			if(s.find(sum-arr[i]) != s.end())
			{
				return true;
			}

			s.insert(arr[i]);
		}

		return false;
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)
























Subarray with zero sum
--------------------------------------------------------------------

-> Given unsorted Arrays, we need to check if there exist any subarray with sum = 0


1. Naive Solution

	bool isZeroSubarray(int arr[], int n)
	{
		for(int i=0; i<n; i++)
		{
			int currentSum = 0;

			for(int j=i; j<n; j++)
			{
				currentSum += arr[j];

				if(currentSum == 0)
				{
					return true;
				}
			}
		}


		return false;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)




2.1. Efficient Solution (C++ Implementation)

	-> Idea: to use "Prefix Sum" and "Hashing" both techniques

	-> int arr[] = A[0], A[1], ...., A[i-1], A[i], A[i+1], ....., A[j], ......, A[n-1]

		1. If there exist a subarray A[i] to A[j] which sum up to 0, then

		2. Prefix Sum from A[0] to A[j] is same as Prefix Sum from A[0] to A[i-1], since the sum of A[i] to A[j] is 0


	
	bool isZeroSubarray(int arr[], int n)
	{
		unordered_set<int> s;

		int prefixSum = 0;

		for(int i=0; i<n; i++)
		{
			prefixSum += arr[i];

			if(s.find(prefixSum) != s.end())
			{
				return true;
			}

			if(prefixSum == 0)
			{
				return true;
			}

			s.insert(prefixSum);
		}


		return false;
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)






2.2. Efficient Solution (Java Implementation)

	boolean isZeroSubarray(int[] arr)
	{
		HashSet<Integer> s = new HashSet<>();

		int prefixSum = 0;

		for(int i=0; i<arr.length(); i++)
		{
			prefixSum += arr[i];

			if(s.contains(prefixSum) || prefixSum == 0)
			{
				return true;
			}

			s.add(prefixSum);
		}


		return false;
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)






















Subarray with given Sum
-----------------------------------------------------------------------

-> This problem is simple extension of the problem "Subarray with zero sum"


1. Naive Solution

	bool isSum(int arr[], int n, int sum)
	{
		for(int i=0; i<n; i++)
		{
			int currentSum = 0;

			for(int j=i; j<n; j++)
			{
				currentSum += arr[j];

				if(currentSum == sum)
				{
					return true;
				}
			}
		}


		return false;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)




2.1. Efficient Solution (C++ Implementation)

	-> Idea: to use "Prefix Sum" and "Hashing" both techniques

	-> int arr[] = A[0], A[1], ...., A[i-1], A[i], A[i+1], ....., A[j], ......, A[n-1]

		1. If there exist a subarray A[i] to A[j] which adds up to "Given Sum -> sum", then

		2. Prefix Sum from A[0] to A[j] is same as -> [(Prefix Sum from A[0] to A[i-1]) - sum] , 
			since the -> [(sum of A[i] to A[j]) - sum] is 0
                                                                 

	
	bool isSum(int arr[], int n, int sum)
	{
		unordered_set<int> h;

		int prefixSum = 0;

		for(int i=0; i<n; i++)
		{
			prefixSum += arr[i];

			if(h.find(prefixSum - sum) != h.end())
			{
				return true;
			}

			if(prefixSum == sum)
			{
				return true;
			}

			h.insert(prefixSum);
		}


		return false;
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)






2.2. Efficient Solution (Java Implementation)

	boolean isSum(int[] arr, int sum)
	{
		HashSet<Integer> h = new HashSet<>();

		int prefixSum = 0;

		for(int i=0; i<arr.length(); i++)
		{
			prefixSum += arr[i];

			if(h.contains(prefixSum - sum) || prefixSum == sum)
			{
				return true;
			}

			h.add(prefixSum);
		}


		return false;
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)



























Longest subarray with given sum
------------------------------------------------------------------------
#Repeat
#Revise

-> We have to return the length of longest subarray with given sum


1. My Solution

	int longestSubarrayLength(vector<int> vec, int sum)
	{
	    unordered_set<int> s;
	    vector<int> temp;
	    int prefixSum = 0;
	    int subarrayLength = 0;
	    
	    for(int i=0; i<vec.size(); i++)
	    {
	        prefixSum += vec[i];
	        
	        if((s.find(prefixSum - sum) != s.end()) || (prefixSum == sum))
	        {
	            temp.push_back(i);
	        }
	        
	        s.insert(prefixSum);
	    }
	    
	    if(temp.size() == 0)
	    {
	        return 0;
	    }
	    
	    for(int i=0; i<temp.size(); i++)
	    {
	        int currentLength = 1;
	        int index = temp[i];
	        int currentSum = vec[index];
	        while(currentSum != sum)
	        {
	            index--;
	            currentSum += vec[index];
	            currentLength++;
	        }
	        
	        subarrayLength = max(subarrayLength, currentLength); 
	    }
	    
	    
	    return subarrayLength;
	}



2. Naive Solution

	int maxLen(int arr[], int n, int sum)
	{
		int res = 0;

		for(int i=0; i<n; i++)
		{
			int currentSum = 0;

			for(int j=i; j<n; j++)
			{
				currentSum += arr[j];
				if(currentSum == sum)
				{
					res = max(res, j-i+1);
				}
			}
		}


		return res;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)



3. Efficient Solution

	int maxLen(int arr[], int n, int sum)
	{
		unordered_map<int, int> m;				// HashMap<Integer, Integer> m = new HashMap<>()
		int prefixSum = 0;
		int res = 0;

		for(int i=0; i<n; i++)
		{
			prefixSum += arr[i];

			if(prefixSum == sum)				// Corner Case: when subarray consists of all elements
			{
				res = i+1;
			}

			if(m.find(prefixSum) == m.end())				// if(m.contains(prefixSum) == false)
			{
				m.insert({prefixSum, i});		// It ensures that, we are inserting only left most appearence of prefixSum
			}

			if(m.find(prefixSum - sum) != m.end())			// if(m.contains(prefixSum - sum))
			{
				res = max(res, i-m[prefixSum - sum]);
			}
		}
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)
























Longest subarray with equal number of 0s and 1s
---------------------------------------------------------------------------

-> One of the most asked Interview Question

1. Naive Solution

	int longestSub(bool arr[], int n)
	{
		int res = 0;

		for(int i=0; i<n; i++)
		{
			int zeroCount = 0;
			int oneCount = 0;

			for(int j=i; j<n; j++)
			{
				if(arr[j] == 0)
				{
					zeroCount++;
				}
				else
				{
					oneCount++;
				}


				if(zeroCount == oneCount)
				{
					res = max(res, j-i+1);
				}
			}
		}

		return res;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)


2. Efficient Solution

	Hint: This problem is going to reduce into the problem of 
		  finding length of longest subarray with 0 sum.


	-> The trick is to replace each 0 with -1, then the question simply becomes
		"find the length of longest subarray with sum as 0"


	-> Time Complexity:		O(N)
	-> Space Complexity:	O(N)



	2.1. Implementation 1

		int maxLen(int arr[], int n, int sum)
		{
			unordered_map<int, int> m;				// HashMap<Integer, Integer> m = new HashMap<>()
			int prefixSum = 0;
			int res = 0;

			for(int i=0; i<n; i++)
			{
				prefixSum += arr[i];

				if(prefixSum == sum)
				{
					res = i+1;
				}

				if(m.find(prefixSum) == m.end())				// if(m.contains(prefixSum) == false)
				{
					m.insert({prefixSum, i});		// It ensures that, we are inserting only left most appearence of prefixSum
				}

				if(m.find(prefixSum - sum) != m.end())			// if(m.contains(prefixSum - sum))
				{
					res = max(res, i-m[prefixSum - sum]);
				}
			}
		}

		int longestSubarrayOfEqual0sAnd1s(int arr[], int n)
		{
			for(int i=0; i<n; i++)
			{
				if(arr[i] == 0)
				{
					arr[i] = -1;
				}
			}

			int ans = maxLen(arr, n, 0);

			return ans;
		}



	2.2 Implementation 2


		int longestSubarrayOfEqual0sAnd1s(int arr[], int n)
		{
			unordered_map<int, int> m;
			int res = 0;
			int prefixSum = 0;

			for(int i=0; i<n; i++)
			{
				if(arr[i] == 0)
				{
					prefixSum += -1;
				}
				else
				{
					prefixSum += 1;
				}


				if(prefixSum == 0)
				{
					res = i+1;
				}


				if(m.find(prefixSum) == m.end())
				{
					m.insert(make_pair(prefixSum, i));
				}
				else
				{
					res = max(res, i-m[prefixSum]);
				}
			}

			return res;
		}
























Longest common span with same sum in binary array
------------------------------------------------------------------------------

-> Given two binary arrays (of same size)

-> Common subarray implies that starting index and ending index should be same in both Arrays.



1. My Solution(Naive Approach)

	int longestCommonSpan(vector<int> arr1, vector<int> arr2)
	{
	    int res = 0;
	    int n = arr1.size();
	    
	    for(int i=0; i<n; i++)
	    {
	        int sum1=0, sum2=0;
	        
	        for(int j=i; j<n; j++)
	        {
	            sum1 += arr1[j];
	            sum2 += arr2[j];
	            
	            if(sum1 == sum2)
	            {
	                res = max(res, j-i+1);
	            }
	        }
	    }
	    
	    return res;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)




2. Naive Solution

	int maxCommon(bool arr1[], bool arr2[], int n)
	{
		int res = 0;

		for(int i=0; i<n; i++)
		{
			int sum1 = 0;
			int sum2 = 0;

			for(int j=i; j<n; j++)
			{
				sum1 += arr1[j];
				sum2 += arr2[j];

				if(sum1 == sum2)
				{
					res = max(res, j-i+1);
				}
			}
		}

		return res;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)





2. Efficient Solution

	-> Hint: This problem is going to reduce into the problem of finding the 
	         longest subarray with sum = 0

	-> Idea:

		1. We subtract one array from other array.

		2. Then from the resultant array, we need to find the longest subarray with sum = 0




	int maxLen(int arr[], int n, int sum)
	{
		unordered_map<int, int> m;				// HashMap<Integer, Integer> m = new HashMap<>()
		int prefixSum = 0;
		int res = 0;

		for(int i=0; i<n; i++)
		{
			prefixSum += arr[i];

			if(prefixSum == sum)
			{
				res = i+1;
			}

			if(m.find(prefixSum) == m.end())				// if(m.contains(prefixSum) == false)
			{
				m.insert({prefixSum, i});		// It ensures that, we are inserting only left most appearence of prefixSum
			}

			if(m.find(prefixSum - sum) != m.end())			// if(m.contains(prefixSum - sum))
			{
				res = max(res, i-m[prefixSum - sum]);
			}
		}
	}



	int maxCommon(bool arr1[], bool arr2[], int n)
	{
		int temp[n];

		for(int i=0; i<n; i++)
		{
			temp[i] = arr1[i] - arr2[i];
		}

		int res = maxLen(temp, n, 0);

		return res;
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)
























Longest Consecutive Subsequence
-----------------------------------------------------------------------

-> To find out length of longest subsequence such that the subsequence have consecutive elements.

-> We need to find the longest subsequence in the form of x, x+1, x+2, ....., x+i 
   with these elements appearing in any order



1. My Solution

	int lengthOfLongestConsecutiveSubsequence(vector<int> arr)
	{
	    unordered_set<int> s;
	    int res = 1;
	    
	    for(int i=0; i<arr.size(); i++)
	    {
	        int currentLength = 1;
	        int currentElement = arr[i];
	        
	        int temp1 = currentElement-1;
	        int temp2 = currentElement+1;
	        
	        s.insert(currentElement);
	        
	        while(s.find(temp1) != s.end())
	        {
	            currentLength++;
	            temp1--;
	        }
	        while(s.find(temp2) != s.end())
	        {
	            currentLength++;
	            temp2++;
	        }
	        
	        res = max(res, currentLength);
	    }
	    
	    
	    return res;
	}

	Time Complexity:	O(N^2)
	Space Complexity:	O(N)




2. Naive Solution 

	-> Hint: Use Sorting 


	int longestSubsequence(int arr[], int n)
	{
		sort(arr, arr+n);			// Java: Arrays.sort(arr)

		int res = 1;
		int curr = 1;

		for(int i=1; i<n; i++)
		{
			if(arr[i] == arr[i-1]+1)
			{
				curr++;
			}
			else if(arr[i] != arr[i-1])
			{
				res = max(res, curr);		// Java: res = Math.max(res, curr)
				curr = 1;
			}
		}

		return max(res, curr);				// Java: return Math.max(res, curr)
	}


	Time Complexity:	O(Nlog(N))
	Space Complexity:	O(1)







3. Efficient Solution

	-> Hints:
		1. We first insert all elements in a hash table

		2. Then with "2n lookups", we find the result  




	int longestSubsequence(int arr[], int n)
	{
		unordered_set<int> s(arr, arr+n);		// Initilizing the set with Array elements

		int res = 1;

		for(auto x: s)							// Java: for(Integer x: s)
		{
			if(s.find(x-1) == s.end())			// Java: if(s.contains(x-1) == false)
			{
				int curr = 1;

				while(s.find(x+curr) != s.end())	// Java: while(s.contains(x+curr))
				{
					curr++;
				}

				res = max(res, curr);				// res = Math.max(res, curr);
			}
		}

		return res;
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)
	-> There are always 2n lookups at most


	-> The claim is that, if the hash table size is "m", then there will 
		be at most "2m lookups"

	-> Lookup for the very first element of the subsequence: 2 + (len - 1)t
	-> Lookup for the Other Elements: 1

































Count Distinct Elements in Every Window
---------------------------------------------------------------------

-> Problem Constraints:
	
	1. N = Array Size

	2. K = Window Size 			

	3. K <= N

	4. The number of windows of size K in a N size Array = (N - K + 1)




1. My Solution

	vector<int> countDistinct(vector<int> arr, int k)
	{
	    vector<int> res;
	    int n = arr.size();
	    unordered_map<int, int> m;
	    
	    for(int i=0; i<k; i++)
	    {
	        m[arr[i]]++;
	    }
	    
	    for(int i=k; i<n; i++)
	    {
	        res.push_back(m.size());
	        m[arr[i-k]]--;
	        if(m[arr[i-k]] == 0)
	        {
	            m.erase(arr[i-k]);
	        }
	        m[arr[i]]++;
	    }
	    
	    res.push_back(m.size());
	    
	    return res;
	}


	Time Complexity:	O(N)
	Space Complexity:	O(N)





2. Naive Solution
	
	void printDistinctWindow(int arr[], int n, int k)
	{
		for(int i=0; i <= n-k; i++)
		{
			int count = 0;

			for(int j=0; j<k; j++)
			{
				bool flag = false;

				for(int p=0; p<j; p++)
				{
					if(arr[i+j] == arr[i+p])
					{
						flag = true;
						break;
					}
				}

				if(flag == false)
				{
					count++;
				}
			}

			cout<<count<<" ";
		}
	}


	Time Complexity: 	O((n-k) * k * k)			// If "k" is very high, it can go cubic
	Space Complexiyt:	O(1)





3. Efficient Solution: O(N)

	-> Idea for efficient solution

		1. Create a frequency map of first k items

		2. Print size of the frequency map

		3. for(int i=k; i<n; i++)
			a. Decrease frequency of arr[i-k]

			b. If the frequency of arr[i-k] becomes 0, remove it from the map

			c. If arr[i] does not exist in the map, insert it.
			   Else, increase its frequency in the map.

			d. Print size of the map


	-> Time Complexity:		O(N)
	-> Space Complexity: 	O(K)			



































More than n/k Occurences
------------------------------------------------------------------------------

-> Problem Statement

	1. Given size = n

	2. Given an Integer k

	3. To print all those elements having count more than n/k




1. My Solution

	void printMoreThanNbyKOccurrences(vector<int> arr, int k)
	{
	    unordered_map<int, int> m;
	    
	    int n = arr.size();
	    
	    for(int i=0; i<n; i++)
	    {
	        m[arr[i]]++;
	    }
	    
	    for(auto x: m)
	    {
	        if(x.second > n/k)
	        {
	            cout<<x.first<<" ";
	        }
	    }
	    cout<<endl;
	}


	Time Complexity:	O(N)
	Space Complexity: 	O(N)





2. Naive Solution

	void printNByK(int arr[], int n, int k)
	{
		sort(arr, arr+n);			// Java: Arrays.sort(arr)

		int i = 1;
		int count = 1;

		while(i<n)
		{
			while(i<n && arr[i]=arr[i-1])
			{
				count++;
				i++;
			}

			if(count > n/k)
			{
				print(arr[i-1]+" ");
			}

			count = 1;
			i++;   
		}

	}


	Time Complexity:	O(Nlog(N))
	Space Complexity: 	O(1)





3. Efficient Solution

	-> Time Complexity:		O(N)
	-> Space Complexity:	O(N)

	3.1. C++ Implementation

		void printNByK(int arr[], int n, int k)
		{
			unordered_map<int, int> m;

			for(int i=0; i<n; i++)
			{
				m[arr[i]]++;
			}

			for(auto e: m)
			{
				if(e.second > n/k)
				{
					cout<<e.first<<" ";
				}
			}
		}



	3.2. Java Implementation

		void printNByK(int arr[], int k)
		{
			HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();

			int n = arr.length();

			for(int x: arr)
			{
				m.put(x, m.getOrDefault(x, 0)+1);
			}

			for(Map.Entry<Integer, Integer> e: m)
			{
				if(e.getValue() > n/k)
				{
					System.out.print(e.getKey() + " ");
				}
			}
		}























More than n/k Occurences: O(nk) solution
-----------------------------------------------------------------------------

#Repeat
#Revise

-> This solution is extension of above problem's solution, to optimize the solution
   when n is very high and k is very small



-> Extension of "BoyerMoore majority vote algorithm"


-> Let "res_count" be the number of elements in the result:   "res_count <= k-1" 


-> The solution consists of Two phases
	1. The first phase has two steps: step 1 and step 2
		-> In phase 1: we find candidate elements

	2. The second phase has one step: step 3



-> Algorihtm

	1. Create an empty map m

	2. for(i=0; i<n; i++)

		a. if(m contains arr[i])
			m[arr[i]]++;

		b. Else if(m.size() is less than (k-1))
			m.put(arr[i], 1);

		c. Else
			Decrease all values in m by one. If value becomes 0, remove.


	3. For all elements in m, print the elements that actually appear
	   more than n/k times.



-> In the rejected set, an element rejects (k-1) distinct others
























































































































































#########################################################
10. Strings
#########################################################


Introduction to Strings
---------------------------------------------------------------

-> Important Points

	1. Sequence of characters

	2. Small set of characters

	3. Contiguous integer values for 'a' to 'z' and 'A' to 'Z' in both ASCII and UTF-16

	4. C/C++
		-> char data type uses ASCII
		-> stores character using 8-Bit
		-> Also supports wchar_t

	5. Java
		-> char data type uses UTF-16
		-> stores character using 16-Bit
		-> Also supports byte

	6. 'a': 97	&	'A': 65





1. Example Problem
	-> Print Frequencies of characters(in sorted order) in a string of lowercase alphabets.


	1.1. C++ Implementation

		void printFreq(string str)
		{
			int count[26] = {0};		// Initilize all the elements of the array with 0

			for(int i=0; i<str.length(); i++)
			{
				count[str[i] - 'a']++;
			}

			for(int i=0; i<26; i++)
			{
				if(count[i] > 0)
				{
					cout<<(char)(i + 'a')<<" "<<count[i]<<endl;
				}
			}
		}



	1.2. Java Implementation

		void printFreq(String str)
		{
			int[] count = new int[26];

			for(int i=0; i<str.length(); i++)
			{
				count[str.charAt(i) - 'a']++;
			}

			for(int i=0; i<26; i++)
			{
				if(count[i] > 0)
				{
					System.out.println((char)(i + 'a') + " " + count[i]);
				}
			}
		}




























Strings in C++
-----------------------------------------------------------------

-> Strings in C++ can be represented in two ways

	1. C-style strings
		-> Array of chars

		-> Some useful Functions
			1. strlen(str)
			2. strcmp(s1, s2)		// Compares two strings lexicographically
			3. strcpy(s1, s2)


	2. Using an object of "string" class
		-> Richer library
		-> Supports operators like +, <, >, ==, <=, >=
		-> Can assign a string later
		-> Do not have to worry about size
		-> Can be converted to C-style string(char array) if needed -> using function "c_str" 




-> Example of C-style String

	int main()
	{
		char str[] = "gfg";
		cout<<str;				// gfg

		cout<<sizeof(str);		// 4 -> 1 extra space is taken by "\0"
		return 0;
	}



-> Example of C++ style string

	int main()
	{
		string str = "geeksforgeeks";

		cout<<str.length()<<" ";		// o/p: 13

		str = str + "xyz";				// str = geeksforgeeksxyz

		cout<<str<<" ";					// o/p: geeksforgeeksxyz

		cout<<str.substr(2, 4)<<" ";	// o/p: eksf
			// Note: substr -> gives the substring, 1st parameter is index of substring and 
			// 2nd parameter is length of the substring

		cout<<str.find("eek")<<" ";		// o/p: 1

		cout<<str.find("kgf")<<" ";		// o/p: string::npos
			// Note: find function returns the index of 1st occurence if substring exists
			// If not found it returns a special constant "string::npos" -> indicates No substring found

		return 0;
	}




-> Reading strings from Console in C++

	int main()
	{
		string str;
		string address;

		cout<<"Enter your name";
		cin>>str;					// Reads the input string till the first space character
		cout<<"\nYour name is: "<<str;

		cout<<"Enter your Address";
		getline(cin, address);		// Reads the input till the first Enter character
		cout<<"\nYour Address is: "<<address;

		return 0;
	}



-> Note: getline function can take an optional parameter as its 3rd parameter.
	It specifies the character which stops the reading from console

	Example: getline(cin, str, 'a')
		-> It will keep reading the i/p until key 'a' is pressed on keyboard





-> Iterating through a string

	int main()
	{
		string str = "geeksforgeeks";

		for(int i=0; i<str.length(); i++)
		{
			cout<<str[i];
		}
		cout<<endl;

		for(char c: str)
		{
			cout<<c;
		}
	}


























String in Java
-------------------------------------------------------

-> There are 4 ways to create Strings in Java

	1. Character Array/ArrayList
		-> char[] arr = ['g', 'e', 'e', 'k', 's'];

	2. String class
		-> Creates Immutable String
		-> Since it's Immutable, it is automatically Thread Safe
			a. String str = "geeks";
			b. String str = new String("geeks");

	3. StringBuffer class
		-> Mutable
		-> Thread Safe / Synchronous 			// Slow
			-> StringBuffer str = new StringBuffer("geeks");

	4. StringBuilder class
		-> Mutable
		-> Thread Unsafe / Asynchrounous 		// Fast
			-> StringBuilder str = new StringBuilder("geeks");





-> Example Program 1

	class Test
	{
		public static void main(String[] args)
		{
			String str = "geeks";

			System.out.println(str.length());				// o/p: 5

			System.out.println(str.charAt(3));				// o/p: k

			System.out.println(str.substring(2));			// o/p: eks

			System.out.println(str.substring(2, 4));		// o/p: ek 		// from "index 2" to "index 4-1"
		}
	}



-> String Literal Pool



-> Example Program 2

	class Test
	{
		public static void main(String[] args)
		{
			String s1 = "geeksforgeeks";
			String s2 = "geeks";
			String s3 = "kfg";
			System.out.println(s1.contains(s2));		// o/p: true
			System.out.println(s1.contains(s3));		// o/p: false


			String str1 = "abhishekaryan";
			String str2 = "abhishekaryan";
			String str3 = "aryanabhishek";
			System.out.println(str1.equals(str2));		// o/p: true
			System.out.println(str1.equals(str3));		// o/p: false


			String s4 = "geeksforgeeks";
			String s5 = "her";
			String s6 = "for"
			String s7 = "geeksforgeeks";

			int res = s4.compareTo(s5);					// o/p: res < 0
			int res = s4.compareTo(s6);					// o/p: res > 0
			int res = s4.compareTo(s7);					// o/p: res = 0
		}
	}




-> str1.indexOf(str2)
	-> It returns the index of first occurence of str2 in str1
	-> If substring str2 is not present in str1 then it returns some negative value




-> Example Program 3

	class Test
	{
		public static void main(String[] args)
		{
			String s1 = "geeksforgeeks";
			String s2 = "for";
			String s3 = "kgf";

			System.out.println(s1.indexOf(s2));			// o/p: 5

			System.out.println(s1.indexOf(s2, 1));		// o/p: 8
				// Note: 2nd parameter indicates the index from where we need to
				// start Searching

			System.out.println(s1.indexOf(s3));			// o/p: Some Negative Value
		}
	}





























Palindrome Check
--------------------------------------------------------------------

1. My Solution

	bool isPalindrome(string str)
	{
	    for(int i=0, j=str.length()-1; i<j; i++, j--)
	    {
	        if(str[i] != str[j])
	        {
	            return false;
	        }
	    }
	    
	    return true;
	}


	Time Complexity:	O(N)
	Space Complexity:	O(1)



2. Naive Solution

	-> If store the reverse of the string in a temp string
	-> We compare the temp string with Original string

	-> Time Complexity:		O(N)
	-> Space Complexity:	O(N)


	2.1. C++ Implementation

		bool isPalindrome(string &str)
		{
			string rev = str;

			reverse(rev.begin(), rev.end());

			return (rev == str);
		}


	2.2. Java Implementation

		bool isPalindrome(String str)
		{
			StringBuilder rev = new StringBuilder(str);

			rev.reverse();

			return str.equals(rev.toString());
		}



3. Efficient Solution

	-> Keep two index one at left side and one at right side 
	-> Compare the characters at two indexes
	-> Return false if the characters don't match
	-> Return true if the left index cross right index

	-> Time Complexity: 	O(N)
	-> Space Complexity:	O(1)


	3.1. C++ Implementation

		bool isPalindrome(string &str)
		{
			int begin = 0;
			int end = str.length()-1;

			while(begin < end)
			{
				if(str[begin] != str[end])
				{
					return false;
				}

				begin++;
				end--;
			}

			return true;
		}



	3.2. Java Implementation

		boolean isPalindrome(String str)
		{
			int begin = 0;
			int end = str.length()-1;

			while(begin < end)
			{
				if(str.charAt(begin) != str.charAt(end))
				{
					return false;
				}

				begin++;
				end--;
			}

			return true;
		}



























Check if a String is Subsequence of Other
------------------------------------------------------------------------------------

-> Total number of Subsequence in a String of Length n is: 2^n


-> Example: All Subsequences of "ABC" are
	"", "A", "B", "C", "AB", "AC", "BC", "ABC"



1. My Solution

	bool isSubsequence(string s1, string s2)
	{
	    if(s2.length() == 0)
	    {
	        return true;
	    }
	    
	    if(s2.length() > s1.length())
	    {
	        return false;
	    }
	    
	    int i=0;
	    int j=0;
	    
	    while(j<s2.length())
	    {
	        if(i >= s1.length())
	        {
	            return false;
	        }
	        
	        while(s2[j] != s1[i])
	        {
	            i++;
	            
	            if(i >= s1.length())
	            {
	                return false;
	            }
	        }
	        
	        i++;
	        j++;
	    }
	    
	    return true;
	}


	Time Complexity: 	O(N)
	Space Complexity:	O(1)



2. Naive Solution

	-> The idea for the Naive Solution is to generate all the Subsequences(2^n) of String s1 and 
	   compare it with String s2

	-> Time Complexity:		O(2^n * n)			// Exponential time complexity




3. Efficient Solution

	3.1. Iterative Implementation

		bool isSubsequence(string s1, string s2, int n, int m)
		{
			int j=0;

			for(int i=0; i<n && j<m; i++)
			{
				if(s1[i] == s2[j])
				{
					j++;
				}
			}

			return (j == m);
		}



		Time Complexity:	O(n+m)
		Space Complexity:	O(1)




	3.2. Recursive Solution

		bool isSubsequence(string s1, string s2, int n, int m)
		{
			if(m == 0)
				return true;

			if(n == 0)
				return false;


			if(s1[n-1] == s2[m-1])
				return isSubsequence(s1, s2, n-1, m-1);
			else 
				return isSubsequence(s1, s2, n-1, m);
		}


		Time Complexity:	O(n+m)
		Space Complexity:	O(n+m)


























Check for Anagram
------------------------------------------------------------

-> Anagram is checking if the two strings are permutations of each other or not
   It implies:
   	1. Every character that appears in the first string should also appear in the second string
   	2. Frequency of every character should also be same in both the strings
   	3. The order of appearence of individual characters may differ



1. My Solution

	bool isAnagram(const string &s1, const string &s2)
	{
	    // for optimization
	    if(s1.length() != s2.length())
	        return false;
	        
	    int temp[26] = {0};			// Since Array size is fixed, it's O(1) Aux Space
	    
	    // traversing the first string
	    for(int i=0; i < s1.length(); i++)
	    {
	        temp[s1[i] - 'a']++;
	    }
	    
	    // traversing the second string
	    for(int i=0; i < s2.length(); i++)
	    {
	        temp[s2[i] - 'a']--;
	    }
	    
	    // traversing the temp
	    for(int i=0; i<26; i++)
	    {
	        if(temp[i] != 0)
	            return false;
	    }
	    
	    return true;
	}


	Time Complexity:	O(N)
	Space Complexity:	O(1)




2. Naive Solution

	-> Time Complexity:		O(Nlog(N))
	-> Space Complexity:	O(1)

	2.1. C++ Implementation

		bool areAnagram(string &s1, string &s2)
		{
			if(s1.length() != s2.length())
				return false;

			sort(s1.begin(), s1.end());
			sort(s2.begin(), s2.end());

			return (s1 == s2);
		}


	2.2. Java Implementation

		boolean areAnagram(String s1, String s2)
		{
			if(s1.length() != s2.length())
				return false;

			char a1[] = s1.toCharArray();
			Arrays.sort(a1);
			s1 = new String(s1);

			char a2[] = s2.toCharArray();
			Arrays.sort(a2);
			s2 = new String(a2);

			return s1.equals(s2);
		}




3. Efficient Solution

	-> Time Complexity:		O(N+CHAR)
	-> Space Complexity:	O(CHAR)


	3.1. C++ Implementation

		const int CHAR = 256;

		bool areAnagram(string &s1, string &s2)
		{
			if(s1.length() != s2.length())
				return false;

			int count[CHAR] = {0};

			for(int i=0; i<s1.length(); i++)
			{
				count[s1[i]]++;
				count[s2[i]]--;
			}

			for(int i=0; i<CHAR; i++)
			{
				if(count[i] != 0)
					return false;
			}

			return true;
		}



	3.2. Java Implementation

		static final int CHAR = 256;

		boolean areAnagram(String s1, String s2)
		{
			if(s1.length() != s2.length())
				return false;

			int count[] = new int[CHAR];

			for(int i=0; i<s1.length(); i++)
			{
				count[s1.charAt(i)]++;
				count[s2.charAt(i)]--;
			}

			for(int i=0; i<CHAR; i++)
			{
				if(count[i] != 0)
					return false;
			}

			return true;
		}





























Leftmost Repeating Character
------------------------------------------------------------------------------

1. My Solution

	int indexOfLeftmostRepeatingCharacter(const string &str)
	{
	    unordered_map<char, int> m;
	    
	    for(int i=0; i<str.length(); i++)
	    {
	        m[str[i]]++;
	    }
	    
	    for(int i=0; i<str.length(); i++)
	    {
	        if(m[str[i]] > 1)
	        {
	            return i;
	        }
	    }
	    
	    return -1;
	}


	Time Complexity: 	O(N)
	Space Complexity: 	O(256)		// O(1)





2. Naive Solution

	int leftMost(string &str)							// Java: String str
	{
		for(int i=0; i < str.length(); i++)
		{
			for(int j=i+1; j<str.length(); j++)
			{
				if(str[i] == str[j])					// Java: str.charAt(i) == str.charAt(j)
				{
					return i;
				}
			}
		}

		return -1;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)




3. Better Solution

	const int CHAR = 256;						// Java: static int CHAR = 256

	int leftMost(string &str)					// String str
	{
		int count[CHAR] = {0};					// int[] count = new int[CHAR]

		for(int i=0; i<str.length(); i++)
		{
			count[str[i]]++;					// count[str.charAt(i)]++
		}

		for(int i=0; i<str.length(); i++)
		{
			if(count[str[i]] > 1)				// if(count[str.charAt(i)] > 1)
			{
				return i;
			}
		}

		return -1;
	}

	-> Time Complexity:		O(N)
	-> Number of Traversals: 2




4. Efficient Solution

	-> Finds the leftmost repeating element is one traversal

	const int CHAR = 256;							// Java: static final int CHAR = 256;

	int leftMost(string &str)						// Java: String str	
	{
		int fIndex[CHAR];							// Java: int[] fIndex = new int[CHAR];

		fill(fIndex, fIndex+CHAR, -1);				// Java: Arrays.fill(fIndex, -1);

		int res = INT_MAX;							// Java: res = Integer.MAX_VALUE;

		for(int i=0; i<str.length(); i++)
		{
			int fi = fIndex[str[i]];				// Java: fi = fIndex[str.charAt(i)];

			if(fi == -1)
			{
				fIndex[str[i]] = i;					// Java: fIndex[str.charAt(i)] = i;
			}
			else
			{
				res = min(res, fi);					// Java: res = Math.min(res, fi);
			}
		}

		return (res == INT_MAX) ? -1 : res;			// Java: return (res == Integer.MAX_VALUE) ? -1 : res;
	}


	Time Complexity:	O(N + CHAR)
	Space Complexity:	O(CHAR)






5. Another Efficient Solution

	-> We can traverse the String from right to optimize the solution even more

	const int CHAR = 256;							// Java: static final int CHAR = 256;

	int leftMost(string &str)
	{
		bool visited[CHAR];							// Java: boolean[] visited = new boolean[CHAR];

		fill(visited, visited+CHAR, false);			// Java: boolean array by default initialized with false

		int res = -1;

		for(int i = str.length()-1; i >= 0; i--)
		{
			if(visited[str[i]])						// Java: if(visited[str.charAt(i)])
			{
				res = i;
			}
			else
			{
				visited[str[i]] = true;				// Java: visited[str.charAt(i)] = true;
			}
		}

		return res;
	}  


	Time Complexity:	O(N + CHAR)
	Space Complexity:	O(CHAR)



























Leftmost Non-Repeating Element/Character
---------------------------------------------------------------------------------------

-> To find the index of Leftmost/First non-repeating character


1. My Solution

	int indexOfLeftmostNonRepeatingCharacter(const string &str)
	{
	    unordered_map<char, int> m;
	    
	    for(int i=0; i<str.length(); i++)
	    {
	        m[str[i]]++;
	    }
	    
	    for(int i=0; i<str.length(); i++)
	    {
	        if(m[str[i]] == 1)
	        {
	            return i;
	        }
	    }
	    
	    return -1;
	}


	Time Complexity:	O(N)
	Space Complexity:	O(1)




2. Naive Solution

	int indexOfFirstNonRepeatingCharacter(string &str)		// Java: String str
	{
		for(int i=0; i<str.length(); i++)
		{
			bool flag = false;

			for(int j=0; j<str.length(); j++)
			{
				if(i!=j && str[i]==str[j])					// Java: if(i!=j && str.charAt(i)==str.charAt(j))
				{
					flag = true;
					break;
				}
			}

			if(flag == false)
			{
				return i;
			}
		}

		return -1;
	}


	Time Complexity:	O(N^2)
	Space Complexity:	O(1)




3. Better Solution

	-> Requires Two traversals

	const int CHAR = 256;									// Java: static final int CHAR = 256;

	int indexOfFirstNonRepeatingCharacter(string &str)		// Java: String str
	{
		int count[CHAR] = {0};								// Java: int[] count = new int[CHAR];

		for(int i=0; i<str.length(); i++)
		{
			count[str[i]]++;								// Java: count[str.charAt(i)]++;
		}

		for(int i=0; i<str.length(); i++)
		{
			if(count[str[i]] == 1)							// Java: if(count[str.charAt(i)] == 1)
			{
				return i;
			}
		}

		return -1;
	}


	Time Complexity:	O(N)
	Space Complexity:	O(CHAR)




4. Efficient Solution

	-> Requires One Traversal only


	const int CHAR = 256;									// Java: static final int CHAR = 256;

	int indexOfFirstNonRepeatingCharacter(string &str)		// Java: String str
	{
		int firstIndex[CHAR];								// Java: int[] firstIndex = new int[CHAR];

		fill(firstIndex, firstIndex+CHAR, -1);				// Java: Arrays.fill(firstIndex, -1);

		for(int i=0; i<str.length(); i++)
		{
			if(firstIndex[str[i]] == -1)					// Java: if(firstIndex[str.charAt(i)] == -1)
			{
				firstIndex[str[i]] = i;						// Java: firstIndex[str.charAt(i)] = i;
			}
			else
			{
				firstIndex[str[i]] = -2;					// Java: firstIndex[str.charAt(i)] = -2;
			}
		}

		int res = INT_MAX;									// Java: res = Integer.MAX_VALUE;

		// Below loop runs for constant number of time
		for(int i=0; i<CHAR; i++)
		{
			if(firstIndex[i] >= 0)
			{
				res = min(res, firstIndex[i]);				// Java: res = Math.min(res, firstIndex[i]);
			}
		}

		return (res == INT_MAX) ? -1 : res;					// Java: return (res == Integer.MAX_VALUE) ? -1 : res;
	}


	Time Complexity: 	O(N + CHAR)
	Space Complexity:	O(CHAR)




























Reverse Words in a String 
---------------------------------------------------------------------

-> I/P: Welcome to gfg
   O/P: gfg to Welcome


1. My Solution

	string reverseWords(string &str)
	{
	    string ans = "";
	    
	    int j = str.length()-1;
	    int i = j;
	    
	    while(i > 0)
	    {
	        
	        while(i>0 && str[i]!=' ')
	        {
	            i--;
	        }
	        
	        if(i == 0)
	        {
	            ans += str.substr(i, j+1-i);
	            return ans;
	        }
	        
	        ans += str.substr(i+1, j-i);
	        ans += " ";
	        
	        j = i-1;
	        i = j;
	    }
	    
	    return ans;
	}



-> Problem Constraints:
	1. Take the string as a character Array

	2. We need to modify the character Array in Place


2. Naive Solution

	-> Create a Stack
	-> Push words one by one to the stack
	-> Pop words from the stack and append to output

	-> Space Complexity:	O(N)





3. Efficient Solution

	-> Idea:
		1. First, we reverse the individual words
		2. Then, we reverse the whole character Array

	-> Space Complexity:	O(1)


	void reverse(char str[], int low, int high)
	{
		while(low <= high)
		{
			swap(str[low], str[high]);
			low++;
			high--;
		}
	}


	void reverseWords(char str[], int n)
	{
		int start = 0;

		for(int end=0; end<n; end++)
		{
			if(str[end] == ' ')
			{
				reverse(str, start, end-1);
			}

			start = end+1;
		}

		reverse(str, start, n-1);	// To reverse the last word

		reverse(str, 0, n-1);
	}




-> Important Points for Java Implementation

	String str = "Welcome to Gfg"

	char[] ch = str.toCharArray();			// Creates a character Array from String

	String str = new String(ch);			// Intializing a String from char Array




-> Important Points for C++ Implementation

	1. In case you initialize a character Array like below
		char str[] = "Welcome to Gfg";

	2. Then, do pass array size minus one as parameter, since C++ compiler add '\0'
		by default which increases the size of the string by 1



























Overview of Pattern Searching
---------------------------------------------------------------------------

-> Overview of Pattern Searching Algorithms

	1. Naive
		-> No Preprocessing
		-> O((n-m+1)*m)

	2. Naive when All characters of "Pattern" are Distinct
		-> No Preprocessing
		-> O(n)


	3. Rabin Karp
		-> Preprocess "Pattern"
		-> Uses the idea of Rolling Hash to optimize the Naive Algorithm
		-> O((n-m+1)*m)			// But better than Naive on Average

	4. KMP
		-> Preprocess "Pattern"
		-> One of the most popular & Complicated Algorithm is Computer Science
		-> This Algorithm preprocess the redundancies in the pattern
		-> "LPS - Longest Proper Prfix" which is also Suffix
		-> O(n)

	5. Suffix Tree
		-> Preprocess "Text"
		-> It's not an Algorithm, it's a data structure
		-> Suffix Tree is mainly built using the idea of "trie" data-structure 
		-> Useful when the "text" is not changing, it is fixed
		-> O(m)

	6. Honorable Mentions(Algorithm having Linear Time Complexity)
		a. Boyer Moore Algorithm
		b. Z Algorithm


Note:
	1. n = Text Length

	2. m = Pattern Length

	3. 1 <= m <= n


























Naive Pattern Searching
--------------------------------------------------------------------------

1. My Solution

	void patternSearch(string text, string pattern)
	{
	    int patternLength = pattern.length();
	    int textLength = text.length();
	    
	    if(patternLength > textLength)
	    {
	        return;
	    }
	    
	    for(int i=0, j=patternLength-1; j<textLength; i++, j++)
	    {
	        bool flag = true;
	        for(int k=i; k <= j; k++)
	        {
	            if(text[k] != pattern[k-i])
	            {
	                flag = false;
	                break;
	            }
	        }
	        
	        if(flag == true)
	        {
	            cout<<i<<" ";
	        }
	    }
	    
	}







2. Naive Solution

	void patSearching(string &txt, string &pat)			// Java: String txt, String pat
	{
		int m = pat.length();
		int n = txt.length();

		for(int i=0; i <= n-m; i++)
		{
			int j;
			for(j=0; j<m; j++)
			{
				if(pat[j] != txt[i+j])					// Java: if(pat.charAt(j) != txt.charAt[i+j])
				{
					break;
				}
			}

			if(j == m)
			{
				cout<<i<<" ";							// Java: System.out.println(i+" ");
			}
		}
	}


	Time Complexity:	O((n-m+1) * m)
	Space Complexity: 	O(1)































Improved Naive Pattern Searching for Distinct
------------------------------------------------------------------------------

-> Given that the Pattern has all distinct characters


1. My Solution

	void distinctPatternSearch(string text, string pattern)
	{
	    int patternLength = pattern.length();
	    int textLength = text.length();
	    
	    if(patternLength > textLength)
	    {
	        return;
	    }
	    
	    for(int i=0, j=patternLength-1; j<textLength; i++, j++)
	    {
	        bool flag = true;
	        for(int k=i; k <= j; k++)
	        {
	            if(text[k] != pattern[k-i])
	            {
	                flag = false;
	                break;
	            }
	        }
	        
	        if(flag == true)
	        {
	            cout<<i<<" ";
	            i = i+patternLength-1;
	            j = j+patternLength-1;
	        }
	    }
	    
	}





2. Improved Naive Solution

	void patSearchDist(string& txt, string& pat)
	{
		int n = txt.length();
		int m = pat.length();

		for(int i=0; i <= n-m; )
		{
			int j;
			for(j=0; j<m; j++)
			{
				if(pat[j] != txt[i+j])
				{
					break;
				}
			}

			if(j == m)				// Substring found
			{
				cout<<i<<" ";
			}
			
			if(j == 0)				// First character of the window is not matching
			{
				i++;
			}
			else
			{
				i = (i+j);
			}
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)



























Rabin Karp Algorithm
-----------------------------------------------------------------
#Repeat
#Revise

-> Important Point
	1. The Algorithm is quadratic in worst case, but works better in general

	2. Like Naive Algorithm, slide the pattern one by one

	3. Compare hash values of pattern and current text window.
		If hash values match, then only compare individual characters.



-> Spurious Hit: Hash value mathches but the individual characters don't match


-> We can compute the value of next Hash, by using previous Hash.


-> Simple Example of Rolling Hash

	t(i+1) = t(i) + txt[i+m] - txt[i]		// M: length of Pattern



-> Simple Hash: Sum of values
   Problem:		Spurious Hits



-> Improved Hash:
	1. Let d = 5

	2. Do the Weithted Sum
		Example: h("xyz") = 24*d^2 + 25*d^1 + 26*d^0

	3. Rolling Hash:
		t(i+1) = d(t(i) - txt[i]*d^(m-1)) + txt[i+m];			// M: Length of Pattern






-> Psuedo code for Rabin Karp Algorithm Implementation

	void RBSearch(string pat, string txt, int M, int N)
	{
		// Compute (d^(m-1))%q
		int h = 1;
		for(int i=1; i <= m-1; i++)
		{
			h = (h*d) % q;
		}


		// Compute p and t(0)
		int p = 0;
		int t = 0;
		for(int i=0; i<m; i++)
		{
			p = (p*d + pat[i]) % q;
			t = (t*d + txt[i]) % q;
		}


		for(int i=0; i <= N-M; i++)
		{
			// This if block is for checking "Spurious Hits"
			if(p == t)
			{
				bool flag = true;
				for(int j=0; j<M; j++)
				{
					if(txt[i+j] != pat[j])
					{
						flag = false;
						break;
					}
				}

				if(flag == true)
				{
					print i;
				}
			}


			// This if block is for Computing t(i+1) using t(i)
			if(i < N-M)
			{
				t = ( (d * (t - txt[i]*h) + txt[i+M]) % q );

				if(t < 0)
				{
					t = t+q;		// Not understood
				}
			}
		}
	}


	Time Complexity: 	O((N-M+1) * M)



-> We are performing various calculations under modulo q, to avoid overflow
   We can choose q = Any Suitable Prime Number



-> Rabin Karp Algorithm has its own applications. It is used when we want to 
   Search multiple patterns in a text.



























KMP Algorithm(Part1: Constructing LPS Array)
-----------------------------------------------------------------------------------

-> LPS: Longest Proper Prefix Suffix


-> Problem Statement: 
	Given a string, we have to construct a LPS array for the given string


-> The LPS Array construction is a prerequisite for understanding KMP Algorithm.
	It's a preprocessing step in KMP Algorithm


-> Understanding Proper Prefix and Suffix using Example

	1. Proper Prefix of "abc"
		-> "", "a", "ab"
		-> Since it's a proper prefix, length of prefix must be smaller than the original String

	2. Suffix of "abc"
		-> "", "c", "bc", "abc"



-> So, we are given a String, we need to find out "Longest Proper Prefix", which is also a "Suffix"
	at every point


-> Some Important Points
	1. First element of the LPS[] is always 0

	2. If all the characters of the String are same, then LPS[] will be like
		-> LPS[] = {0, 1, 2, 3, ...... str.length()-1};

	3. If all the characters of the String are distinct, then all elements of LPS[] will be 0



-> Some examples of Strings and their corresponding LPS[]

	1. string str = "ababc"
		lps[] = {0,0,1,2,0}

	2. string str = "aaaa"
		lps[] = {0,1,2,3}

	3. string str = "abcd"
		lps[] = {0,0,0,0}

	4. string str = "ababab"
		lps[] = {0,0,1,2,3,4}

	5. string str = "abacabad"
		lps[] = {0,0,1,0,1,2,3}

	6. string str = "abbabb"
		lps[] = {0,0,0,1,2,3}





1. My Solution

	vector<int> lps(string &str)
	{
	    vector<int> LPS;
	    int n = str.length();
	    
	    for(int i=0; i<n; i++)
	    {
	        int suffix = i;
	        int prefix = 0;
	        int maxLength = 0;
	        int currentLength = 0;
	        
	        while(prefix < i)
	        {
	            int flag = true;
	            for(int j=0; j<=prefix; j++)
	            {
	                if(str[j] != str[suffix+j])
	                {
	                    flag = false;
	                    break;
	                }
	            }
	            
	            if(flag == true)
	            {
	                currentLength = prefix+1;
	            }
	            
	            maxLength = max(maxLength, currentLength);
	            
	            prefix++;
	            suffix--;
	        }
	        
	        LPS.push_back(maxLength);
	    }
	    
	    return LPS;
	}


	Time Complexity:	O(N^3)
	Space Complexity: 	O(1)



2. Naive Solution

	int longPropPreSuffix(string str, int n)
	{
		for(int len = n-1; len > 0; len--)
		{
			bool flag = true;

			for(int i=0; i<len; i++)
			{
				if(str[i] != str[n-len+i])
				{
					flag = false;
				}
			}

			if(flag == true)
			{
				return len;
			}
		}

		return 0;
	}

	void fillLPS(string str, int[] lps)
	{
		for(int i=0; i<str.length(); i++)
		{
			lps[i] = longPropPreSuff(str, i+1);
		}
	}


	Time Complexity:	O(N^3)
	Space Complexity:	O(1)




3. Efficient Solution

	-> This uses the already calcuted values of lps
	-> When we are at index i, we have already calculated lps[] values for i-1 indexes


	-> Basic Idea:
		1. If "len = lps[i-1]" and "str[len]" & "str[i]" are same, then "lps[i] = len+1"
			-> i.e.,
						if(str[i] == str[lps[i-1]])
						{
							lps[i] = lps[i-1] + 1;
						}

		2.  If "len = lps[i-1]" and "str[len]" & "str[i]" are not same, then

			-> Case a: If len = 0 i.e., lps[i-1] = 0
				 => lps[i] = 0;

				 		if(str[i] != str[lps[i-1]] && lps[i-1] == 0)
				 		{
				 			lps[i] = 0;
				 		} 

			-> Case b: Else, we Recursively apply lps[]
							len = lps[len - 1]
					   then compare str[i] with str[len]

					   // In this case, we recursively apply the "lps function", to find out
					      index of the next character that has to be matched with str[i]


		3. Writing the overall conditions

				if(str[i] == str[lps[i-1]])
				{
					lps[i] = lps[i-1] + 1;
				}
				else if(lps[i-1] == 0)
				{
					lps[i] = 0;
				}
				else
				{
					len = lps[i-1];
					len = lps[lps[i-1] - 1];

					// We now compare str[i] and str[len]
				}





4. Implementation of Efficient Solution 

	-> Implementation of O(n) algorithm

	void fillLPS(string str, int[] lps)
	{
		int n = str.length();
		int len = 0;

		lps[0] = 0;

		int i=1;

		while(i<n)
		{
			if(str[i] == str[len])
			{
				len++;
				lps[i] = len;
				i++;
			}
			else
			{
				if(len == 0)
				{
					lps[i] = 0;
					i++;
				}
				else
				{
					len = lps[len - 1];
				}
			}
		}
	}
























KMP Algorithm (Part2: Complete Algorithm)
-------------------------------------------------------------------------------

-> KMP String Matching
	
	1. Time Complexity:		O(n)		// n: text length
	2. Space Complexity:	O(m)		// m: pattern length

	3. The main idea of KMP algorithm is to Preprocess the "Pattern"  



1. KMP Algorithm Implementation


	void fillLPS(string str, int[] lps)
	{
		int n = str.length();
		int len = 0;

		lps[0] = 0;

		int i=1;

		while(i<n)
		{
			if(str[i] == str[len])
			{
				len++;
				lps[i] = len;
				i++;
			}
			else
			{
				if(len == 0)
				{
					lps[i] = 0;
					i++;
				}
				else
				{
					len = lps[len - 1];
				}
			}
		}
	}


	void KMP(string pat, string txt)
	{
		int N = txt.length();
		int M = pat.length();

		int lps[M];

		fillLPS(pat, lps);

		int i=0;
		int j=0;

		while(i < N)
		{
			if(pat[j] == txt[i])
			{
				i++;
				j++;
			}

			if(j == M)
			{
				cout<<i-j;						// Java: System.out.println(i-j);

				j = lps[j-1];
			}
			else if(i<N && pat[j] != txt[i])
			{
				if(j == 0)
				{
					i++;
				}
				else
				{
					j = lps[j-1];
				}
			}
		}
	}


	Time Complexity:	O(n)		// n: length of text























Check if Strings are Rotations
----------------------------------------------------------------


1. My Solution

	void rotateAnticlockwise(string &str)
	{
	    int n = str.length();
	    
	    char temp = str[0];
	    for(int i=1; i<n; i++)
	    {
	        str[i-1] = str[i];			// O(n) operation
	    }
	    
	    str[n-1] = temp;
	}

	bool isRotation(string str1, string str2)
	{
	    if(str1.length() != str2.length())
	    {
	        return false;
	    }
	    
	    int n = str1.length();
	    
	    for(int i=0; i<n; i++)
	    {
	        rotateAnticlockwise(str2);
	        if(str2 == str1)
	        {
	            return true;
	        }
	    }
	    
	    return false;
	    
	}

	Time Complexity:	O(N^3)








2. Efficient Solution: O(n) time

	-> It is similar to Pattern searching problem
		1. We need to consider str2 as Pattern and str1 as text
		
		2. We need to search str2 in str1 in circular fashion


	-> To implement above steps we need to modify KMP Algorithm for pattern search in circular fashion,
		but it will be very complex

	-> One simple Implementation is to concatenate str1 to itself then do the pattern searching for str2


	2.1. C++ Implementation

		bool areRotations(string &str1, string &str2)
		{
			if(str1.length() != str2.length())
			{
				return false;
			}

			return ((str1+str1).find(str2) != string::npos);
		}



	2.2. Java Implementation

		boolean areRotations(String s1, String s2)
		{
			if(s1.length() != s2.length())
			{
				return false;
			}

			return ((s1+s2).indexOf(s2) >= 0);
		}





























Anagram Search
--------------------------------------------------------

-> Given a "text" and a "pattern", we need to find if pattern itself or any of the 
	permutations of pattern is present in the "text" or not


-> Two strings which permutations of each other are also called Anagram



-> Example 1: 
	i/p: txt = "geeksforgeeks"
		 pat = "frog"

	o/p: Yes


-> Example 2: 
	i/p: txt = "geeksforgeeks"
		 pat = "rseek"

	o/p: No




1. My Solution

	bool isAnagram(string txt, string pat)
	{
	    int n = txt.length();
	    int m = pat.length();
	    
	    sort(pat.begin(), pat.end());
	    
	    if(m > n)
	    {
	        return false;
	    }
	    
	    for(int i=0; i <= n-m; i++)
	    {
	        string str = txt.substr(i, m);
	        sort(str.begin(), str.end());
	        
	        if(str == pat)
	        {
	            return true;
	        }
	    }
	    
	    return false;
	}




2. Naive Solution
	
	-> Time Complexity:		O((n-m+1)*m)

	2.1. C++ Implementation

		bool areAnagram(string &pat, string &txt, int i)
		{
			int count[CHAR] = {0};

			for(int j=0; j<pat.length(); j++)
			{
				count[pat[j]]++;
				count[txt[i+j]]--;
			}

			for(int j=0; j<CHAR; j++)
			{
				if(count[j] != 0)
				{
					return false;
				}
			}

			return true;
		}

		bool isPresent(string &txt, string &pat)
		{
			int n = txt.length();
			int m = pat.length();

			for(int i=0; i <= n-m; i++)
			{
				if(areAnagram(pat, txt, i))
				{
					return true;
				}
			}

			return false;
		}



	2.2. Java Implementation

		boolean areAnagram(String pat, String txt, int i)
		{
			int count[] = new int[CHAR];

			for(int j=0; j < pat.length(); j++)
			{
				count[pat.charAt(j)]++;
				count[txt.charAt(i+j)]--;
			}

			for(int j=0; j < CHAR; j++)
			{
				if(count[j] != 0)
				{
					return false;
				}
			}

			return true;
		}






3. Efficient Solution

	-> This is a modification of Naive Approach
	-> We use the Sliding Window Technique

	const int CHAR = 256;

	bool areSame(int[] charFreqCountOfText, int[] charFreqCountOfPattern)
	{
		for(int i=0; i<CHAR; i++)
		{
			if(charFreqCountOfText[i] != charFreqCountOfPattern[i])
			{
				return false;
			}
		}

		return true;
	}


	bool isPresent(string &txt, string &pat)
	{
		int charFreqCountOfText[CHAR] = {0};
		int charFreqCountOfPattern[CHAR] = {0};

		for(int i=0; i<pat.length(); i++)
		{
			charFreqCountOfText[txt[i]]++;
			charFreqCountOfPattern[pat[i]]++;
		}

		for(int i = pat.length(); i < txt.length(); i++)
		{
			if(areSame(charFreqCountOfText, charFreqCountOfPattern))
			{
				return true;
			}

			charFreqCountOfText[txt[i]]++;
			charFreqCountOfText[txt[i - pat.length()]]--;
		}

		return false;
	}


	Time Complexity: 	O(m + (n-m)*CHAR)  O(n * CHAR)  O(n)
	Space Complexity:	O(CHAR)



























Lexicographic Rank of a String
--------------------------------------------------------------------------

-> Some Examples:
	1. i/p: str = "BAC"
	   o/p: 3

	2. i/p: str = "CBA"
  	   o/p: 6

  	3. i/p: str = "DCBA"
  	   o/p: 24

  	4. i/p: str = "STRING"
  	   o/p: 598



-> Explanation for example 1:

	ABC 	----------------------------------- 	1
	ACB 	----------------------------------- 	2
	BAC 	----------------------------------- 	3
	BCA 	----------------------------------- 	4
	CAB 	----------------------------------- 	5
	CBA 	----------------------------------- 	6





1. Naive Solution
	-> We generate the actual permutations of the given String and count the 
		Rank of the given String

	-> In the worst case it will take: n * (n!) time




2. Efficient Solution

	-> Basic idea: Count Lexicographically smaller strings 


	2.1. My Implementation

		long long factorial(int n)
		{
		    long long fact = 1;
		    
		    if(n == 0)
		    {
		        return 1;
		    }
		    
		    while(n>0)
		    {
		        fact *= n;
		        n--;
		    }
		    
		    return fact;
		}

		int lexicographicRank(string &str)
		{
		    int rank = 1;
		    
		    for(int i=0; i<str.length(); i++)
		    {
		        int countOfSmallerElements = 0;
		        
		        for(int j=i+1; j<str.length(); j++)
		        {
		            if(str[j] < str[i])
		            {
		                countOfSmallerElements++;
		            }
		        }
		        
		        rank += (countOfSmallerElements*factorial(str.length()-i-1));
		    }
		    
		    return rank;
		}



3. Efficient Solution Implementation

	-> Here we are assuming all characters of the String are different

	const int CHAR = 256;

	int lexRank(string &str)
	{
		int res = 1;

		int n = str.length();

		int mul = fact(n);			// We will preprocess the factorial of n, where n is string length

		int count[CHAR] = {0};

		for(int i=0; i<n; i++)
		{
			count[str[i]]++;
		}

		// to get the cumulative sum
		// We are calculating this cumulative array, so that we can find number of
			// smaller chars to the right of a given char
		for(int i=1; i<CHAR; i++)
		{
			count[i] += count[i-1];
		}

		for(int i=0; i < n-1; i++)
		{
			mul = mul/(n-i);

			res = res + count[str[i] - 1]*mul;

			for(int j=str[i]; j<CHAR; j++)
			{
				count[j]--;
			}
		}

		return res;

	}


	Time Complexity:	O(N * CHAR)
	Space Complexity:	O(CHAR)



























Longest Substring with Distinct Characters
-----------------------------------------------------------------

-> Substrings: consecutive characters


-> Sample Examples:
	1. i/p: str = "abcdabc"
	   o/p: 4

	2. i/p: str = "aaa"
	   o/p: 1

	3. i/p: str = ""
	   o/p: 0

	4. i/p: str = "abaacdbab"
	   o/p: 4



1. My Solution

	int lengthOfLongestSubstringWithDistinctCharacters(string &str)
	{
	    if(str.length() == 0)
	    {
	        return 0;
	    }
	    
	    unordered_set<char> s;
	    int count = 1;
	    
	    int windowLength = 1;
	    int i = 0;
	    s.insert(str[i]);
	    int j = i + windowLength;
	    
	    while(j < str.length())
	    {
	        if(s.find(str[j]) == s.end())
	        {
	            s.insert(str[j]);
	            j++;
	            windowLength = j-i;
	            count = max(count, windowLength);
	        }
	        else
	        {
	            if(str[j] == str[i])
	            {
	                // simply slide the window
	                j++;
	                i++;
	            }
	            else
	            {
	                // empty the window and start a new window
	                s.clear();
	                windowLength = 1;
	                i = j;
	                s.insert(str[i]);
	                j = i+1;
	            }
	        }
	    }
	    
	    return count;
	}


	Time Complexity:	O(N)
	Space Complexity: 	O(CHAR)




2. Naive Solution: O(N^3)

	-> We consider all the possible substrings and check if all the characters are distinct

	bool areDistinct(string str, int start, int end)
	{
		vector<bool> visited(256);

		for(int k=start; k <= end; k++)
		{
			if(visited[str[k]] == true)
			{
				return false;
			}

			visited[str[k]] = true;
		}

		return true;
	}


	int longestDistinct(string str)
	{
		int n = str.length();
		int res = 0;

		for(int start=0; start<n; start++)
		{
			for(int end=start; end<n; end++)
			{
				if(areDistinct(str, start, end))
				{
					res = max(res, end-start+1);
				}
			}
		}

		return res;
	}




3. Better Solution: O(N^2)

	-> In this solution as well, we consider all the strings

	int longestDistinct(string str)
	{
		int n = str.length();
		int res = 0;

		for(int i=0; i<n; i++)
		{
			vector<bool> visited(256);

			for(int j=i; j<n; j++)
			{
				if(visited[str[j]] == true)
				{
					break;
				}
				else
				{
					res = max(res, j-i+1);
					visited[str[j]] = true;
				}
			}
		}

		return res;
	}




4. Efficient Solution: O(N)

	-> Basic Idea:
		1. Let the char array is
			-> x(0), x(1), ...., x(i), ....., x(j-1), ....., x(j), ...., x(n-1)

		2. maxEnd(j): Length of the longest substring that has distinct characters 
						and ends with j

		3. res = max(maxEnd(j))			// "j = 0" to "j = n-1"

		4. maxEnd(j) is
			a. maxEnd(j-1) + 1 			// If str[j] is not present in maxEnd(j-1)

			b. j - prev(str[j]) + 1 	// Where prev(str[j]) is previous index of the character str[j]


		Note: 
			maxEnd(j) is calculated for every index j, where maxEnd(j) is the length of the longest substring
			that has all distinct characters and this substring ends at index j




	-> C++ Implementation

		int longestDis(string str)
		{
			int n = str.length();
			int res = 0;

			vector<int> prev(256, -1);

			int i=0;

			for(int j=0; j<n; j++)
			{
				i = max(i, prev[str[j]] + 1);

				int maxEnd = j-i+1;

				res = max(res, maxEnd);

				prev[str[j]] = j;
			}

			return res;  
		}



























































































































































#########################################################
11. Linked List
#########################################################


Problems with Array Data Structures
-----------------------------------------------------------------------------------

-> Linked List
	1. Sequential and Linear Data Structure



-> Problems with Arrays
	1. Either size is fixed or pre-allocated (in both fixed and variable sized arrays),
		OR- the worst case insertion at end is (n)

	2. Insertion in the middle(or beginning) is costly.

	3. Deletion is the middle(or beginning is costly).

	4. Implementation of data structures like queue and deque is complex with Arrays.




-> Some example problems which are not easy to implement with arrays
	1. How to implement Round Robin Scheduling?

	2. Given a sequence of items. Whenever we see an item x in the sequence, we need to 
		replace it with 5 instances of another item y.

	3. We have multiple sorted sequences and we need to merge them frequently.

	4. Problem when allocation Space during System Programming in case of fragmented memory.


























Simple Linked List Implementation in C++
------------------------------------------------------------------------

-> Linked List Implementation in C++

	struct Node 		// Self Referential Structure
	{
		int data;
		Node *next;

		// Constructor
		Node (int x)
		{
			data = x;
			next = NULL;
		}
	}


	int main()
	{
		Node *head = new Node(10);
		Node *temp1 = new Node(20);
		Node *temp2 = new Node(30);

		head->next = temp1;
		temp1->next = temp2;

		return 0;
	}




-> Alternate Implementation

	struct Node 		// Self Referential Structure
	{
		int data;
		Node *next;

		// Constructor
		Node (int x)
		{
			data = x;
			next = NULL;
		}
	}


	int main()
	{
		Node *head = new Node(10);
		head->next = new Node(20);
		head->next->next = new Node(30);

		return 0;
	}























Simple Linked List Implementation in Java
--------------------------------------------------------------

-> Simple Implementation 1

	class Node
	{
		int data;
		Node next;			// Self Referential Structure

		Node(int x)
		{
			data = x;
			next = null;
		}
	}


	class Test
	{
		public static void main(String[] args)
		{
			Node head = new Node(10);
			Node temp1 = new Node(20);
			Node temp2 = new Node(30);

			head.next = temp1;
			temp1.next = temp2;
		}
	}























Traversing a Linked List in C++
---------------------------------------------------------------------

1. Solution 1

	struct Node 	
	{
		int data;
		Node *next;

		// Constructor
		Node (int x)
		{
			data = x;
			next = NULL;
		}
	}

	void printList(Node* head)
	{
		Node* curr = head;

		while(curr != NULL)
		{
			cout<<curr->data<<" ";
			curr = curr->next;
		}
	}


	int main()
	{
		Node *head = new Node(10);
		head->next = new Node(20);
		head->next->next = new Node(30);
		head->next->next->next = new Node(40);

		printList(head);

		return 0;
	}




2. Solution 2

	struct Node
	{
	    int data;
	    Node* next;
	    
	    Node(int x)
	    {
	        data = x;
	        next = NULL;
	    }
	};

	Node* head = NULL;

	// funtion to insert a Node
	void insert(Node* p, int x)
	{
	    Node *temp = new Node(x);
	    if(p == NULL)
	    {
	        head = temp;
	    }
	    else
	    {
	        while(p->next != NULL)
	        {
	            p = p->next;
	        }
	        
	        p->next = temp;
	    }
	}

	void display(Node *p)
	{
	    cout<<"[ ";
	    while(p != NULL)
	    {
	        cout<<p->data<<" ";
	        p = p->next;
	    }
	    cout<<"]";
	}

	int main()
	{
	    insert(head, 10);
	    insert(head, 20);
	    insert(head, 30);
	    
	    display(head);

	    return 0;
	}




























Traversing a Linked List in Java
----------------------------------------------------------------------

1. Traversing a Singly Linked List in Java
	
	class Node
	{
		int data;
		Node next;

		Node(int x)
		{
			data = x;
			next = null;
		}
	}


	class Test
	{
		public static void main(String[] args)
		{
			Node head = new head(10);
			head.next = new head(20);
			head.next.next = new head(30);
			head.next.next.next = new head(40);

			printList(head);
		}

		public static void printList(Node head)
		{
			System.out.print("[ ");
			while(head != null)
			{
				System.out.print(head.data + " ");
				head = head.next;
			}
			System.out.print("]");
		}
	}















Recursive Traversal of Singly Linked List
--------------------------------------------------------------------------

1. My Solution

	void recursiveTraversal(Node* head)
	{
	    if(head != NULL)
	    {
	        cout<<head->data<<" ";
	        recursiveTraversal(head->next);
	    }
	}



2. C++ Implementation

	void recursivePrint(Node *head)				// Java: Node head
	{
		if(head == NULL)
			return;

		cout<<head->data<<" ";					// Java: System.out.print(head.data + " ");
		recursivePrint(head->next);				// Java: recursivePrint(head.next);
	}


	Time Complexity: 	O(n)
	Space Complexity:	O(n)



























Insert at the Begin of Singly Linked List
----------------------------------------------------------------------------

1. My Solution

	Node* insertAtBegin(Node* head, int x)
	{
	    Node* temp = new Node(x);
	    temp->next = head;
	    ::head = temp;          // Accessing the global variable
	    
	    //return temp;
	    return head;
	}



2. C++ Implementation

	struct Node
	{
		int data;
		Node* next;

		Node(int x)
		{
			data = x;
			next = NULL;
		}
	}

	Node* insertAtBegin(Node* head, int x)
	{
		Node* temp = new Node(x);
		temp->next = head;
		return temp;
	}

	int main()
	{
		Node* head = NULL;
		head = insertAtBegin(head, 30);
		head = insertAtBegin(head, 20);
		head = insertAtBegin(head, 10);

		return 0;
	}


	Time Complexity: 	O(1)






3. Java Implementation

	class Node
	{
		int data;
		Node next;

		Node(int x)
		{
			data = x;
			next = null;
		}
	}

	class Test
	{
		static Node insertAtBegin(Node head, int x)
		{
			Node temp = new Node(x);
			temp.next = head;
			return temp;
		}

		public static void main(String[] args)
		{
			Node head = null;
			head = insertAtBegin(head, 30);
			head = insertAtBegin(head, 20);
			head = insertAtBegin(head, 10);

			return 0;
		}
	}






























Insert at the End of Singly Linked List
-------------------------------------------------------------------------

1. My Solution

	void insertAtEnd(Node* p, int x)
	{
	    Node *temp = new Node(x);
	    if(p == NULL)
	    {
	        ::head = temp;		// head is a global variable here
	    }
	    else
	    {
	        while(p->next != NULL)
	        {
	            p = p->next;
	        }
	        
	        p->next = temp;
	    }
	}





2. C++ Implementation

	Node* insertAtEnd(Node *head, int x)		// Java: Node insert(Node head, int x)
	{
		Node* temp = new Node(x);				// Java: Node temp = new Node(x);

		if(head == NULL)						// Java: if(head == null)
		{
			return temp;
		}

		Node* curr = head;						// Java: Node curr = head;
		while(curr->next != NULL)				// Java: curr.next != null
		{
			curr = curr->next;					// Java: curr = curr.next
		}
		curr->next = temp;						// Java: curr->next = temp

		return head;
	}


	Time Complexity:	O(N)




























Delete First Node of Singly Linked List
-----------------------------------------------------------------------

-> Time Complexity:		O(1)

1. My Solution 

	void deleteFirstNode(Node *head)
	{
	    if(head == NULL)
	    {
	        return;
	    }
	    
	    Node *first = head;
	    ::head = head->next;
	    delete first;
	}



2. C++ Implementation

	Node* deleteHead(Node* head)
	{
		if(head == NULL)
		{
			return NULL;
		}
		else
		{
			Node* temp = head->next;
			delete head;

			return temp;
		}
	} 




3. Java Implementation

	Node deleteHead(Node head)
	{
		if(head == null)
		{
			return null;
		}
		else
		{
			return head.next;		// In Java, we don't need to worry about Memory de-allocation
		}
	}

	void main(String[] args)
	{
		Node head = null;
		head = deleteHead(head);
	}

























Delete Last Node of Singly Linked List
------------------------------------------------------------------

-> In Java, memory deallocation is done automatically

-> Time Complexity:	O(N)

1. My Solution

	void deleteLastNode(Node *head)
	{
	    if(head == NULL)
	    {
	        return;
	    }
	    else if(head->next == NULL)
	    {
	        delete head;
	        ::head = NULL;
	    }
	    else
	    {
	        while(head->next->next != NULL)
	        {
	            head = head->next;
	        }
	        
	        delete head->next;
	        head->next = NULL;
	    }
	}




2. C++ Implementation

	Node* deleteTailNode(Node* head)
	{
		if(head == NULL)
		{
			return NULL;
		}

		if(head->next == NULL)
		{
			delete head;
			return NULL;
		}

		Node* curr = head;
		while(curr->next->next != NULL)
		{
			curr = curr->next;
		}

		delete curr->next;
		curr->next = NULL;

		return head;
	}



3. Java Implementation

	Node deleteLastNode(Node head)
	{
		if(head == null)
		{
			return null;
		}

		if(head.next == null)
		{
			return null;
		}

		Node curr = head;
		while(curr.next.next != null)
		{
			curr = curr.next;
		}
		curr.next = null;

		return head;
	}






























Insert at given position in Singly Linked List
--------------------------------------------------------------------------------

1. My Solution

	void insertAtPosition(Node* head, int pos, int x)
	{
	    if(pos < 1)
	    {
	        return;
	    }
	    
	    if(pos == 1)
	    {
	        Node* temp = new Node(x);
	        temp->next = head;
	        ::head = temp;
	        return;
	    }
	    
	    while(pos-2 > 0)
	    {
	        if(head == NULL)
	        {
	            return;
	        }
	        head = head->next;
	        pos--;
	    }
	    
	    if(head == NULL)
	    {
	        return;
	    }
	    Node* temp = new Node(x);
	    temp->next = head->next;
	    head->next = temp;
	}




2. C++ Implementation

	Node* insertAtPos(Node* head, int pos, int data)			// Java: Replace Node* with Node
	{
		Node* temp = new Node(data);							// Java: Node temp = new Node(data);

		if(pos == 1)
		{
			temp->next = head;									// Java: temp.next = head;
			return temp;			// head is modified in this case
		}

		Node* curr = head;										// Java: Node curr = head;
		for(int i=1; (i <= pos-2) && (curr != NULL); i++)
		{
			curr = curr->next;									// Java: curr = curr.next;
		}

		if(curr == NULL)
		{
			return head;
		}

		temp->next = curr->next;								// Java: temp.next = curr.next;
		curr->next = temp;										// Java: curr.next = temp;


		return head;
	}































Search in a Linked List (Iterative and Recursive)
---------------------------------------------------------------------------------------

-> Time Complexity:	O(N)

1. My Solution

	1.1. Iterative Solution

		int search(Node* head, int x)
		{
		    int pos = -1;
		    int currPos = 1;
		    while(head != NULL)
		    {
		        if(head->data == x)
		        {
		            pos = currPos;
		            break;
		        }
		        currPos++;
		        head = head->next;
		    }
		    
		    return pos;
		}


	1.2. Recursive Solution

		int recursiveSearch(Node* head, int x)
		{
		    static int pos = 1;
		    if(head == NULL)
		    {
		        return -1;
		    }
		    else if(head->data == x)
		    {
		        return pos;
		    }
		    else
		    {
		        pos++;
		        return recursiveSearch(head->next, x);    
		    }

		}





2. C++ Implementation

	2.1. Iterative approach

		int search(Node* head, int x)
		{
			int pos = 1;
			Node* curr = head;

			while(curr != NULL)
			{
				if(curr->data == x)
				{
					return pos;
				}
				else
				{
					pos++;
					curr = curr->next;
				}
			}

			return -1;
		}


	2.2. Recursive Solution

		#Revise

		int recursiveSearch(Node* head, int x)
		{
			if(head == NULL)
			{
				return -1;
			}

			if(head->data == x)
			{
				return 1;
			}
			else
			{
				int res = recursiveSearch(head->next, x);
				if(res == -1)
				{
					return -1;
				}
				else
				{
					return res+1;
				}
			}
		}




-> There are some variation of Linked List which allows faster search, in case of 
	sorted list.
	These are advanced Linked List called "Skip List"
	For more details refer: https://www.geeksforgeeks.org/skip-list/





























Doubly Linked List in C++
---------------------------------------------------------------

-> Structure for a Doubly Linked List

	struct Node {
		int data;
		Node* prev;
		Node* next;

		Node(int data) {
			this.data = data;
			prev = NULL;
			next = NULL;
		}
	}



-> Sample funtion to create a doubly linked list of 3 nodes

	int main()
	{
		Node *head = new Node(10);
		Node *temp1 = new Node(20);
		Node *temp2 = new Node(30);

		head->next = temp1;

		temp1->prev = head;
		temp1->next = temp2;

		temp2->prev = temp1;
	}

























Doubly Linked List in Java
----------------------------------------------------------

-> Class for Doubly Linked List

	class Node {
		int data;
		Node prev;
		Node next;

		Node(int data)
		{
			this.data = data;
			prev = null;			// optional initialization
			next = null;			// optional initialization
		}
	}




-> Example Linked List creation with 3 Nodes

	void main(String[] args)
	{
		Node head = new Node(10);
		Node temp1 = new Node(20);
		Node temp2 = new Node(30);

		head.next = temp1;

		temp1.prev = head;
		temp1.next = temp2;

		temp2.prev = temp1;
	}






























Singly Vs Doubly Linked List (Advantages & Disadvantages)
-----------------------------------------------------------------------------------

1. Advantages
	-> Can be traversed in both directions

	-> given Node can be deleted in O(1) time if 
		reference/pointer to that Node is given.

	-> Insert/Delete before a given Node

	-> Insert/Delete from both ends in O(1) time by 
		maintaining "tail".


2. Disadvantages
	-> Extra space for "prev"

	-> Code becomes more complex





























Insert at Begin of Doubly Linked List
-----------------------------------------------------------------

1. My Solution

	#include <iostream>
	using namespace std;

	struct Node {
	    int data;
	    Node* prev;
	    Node* next;
	    
	    // Constructor
	    Node(int data)
	    {
	        this->data = data;
	        prev = NULL;
	        next = NULL;
	    }
	};

	Node* head = NULL;
	Node* tail = NULL;

	void insertAtBegin(Node* head, int x)
	{
	    Node* temp = new Node(x);
	    if(head == NULL)
	    {
	        ::tail = temp;
	        ::head = temp;
	        return;
	    }
	    temp->next = head;
	    head->prev = temp;
	    
	    ::head = temp;
	}

	void display(Node* head)
	{
	    cout<<"[ ";
	    while(head != NULL)
	    {
	        cout<<head->data<<" ";
	        head = head->next;
	    }
	    cout<<"]";
	}



	int main()
	{
	    insertAtBegin(head, 30);
	    insertAtBegin(head, 20);
	    insertAtBegin(head, 10);
	    display(head);

	    return 0;
	}




2. C++ Implementation

	struct Node
	{
		int data;
		Node* prev;
		Node* next;

		Node(int d)
		{
			data = d;
			prev = NULL:
			next = NULL;
		}
	};


	Node* insertAtBegin(Node* head, int data)
	{
		Node* temp = new Node(data);

		temp->next = head;

		if(head != NULL)
		{
			head->prev = temp;
		}

		return temp;
	}




3. Java Implementation

	class Node
	{
		int data;
		Node prev;
		Node next;

		Node(int d)
		{
			data = d;
			prev = null:
			next = null;
		}
	}


	Node insertAtBegin(Node head, int data)
	{
		Node temp = new Node(data);

		temp.next = head;

		if(head != null)
		{
			head.prev = temp;
		}

		return temp;
	}
























Reverse a Doubly Linked List
---------------------------------------------------------------

1. My Solution

	void reverseDoublyLinkedList(Node* head)
	{
	    ::tail = head;
	    
	    if(head==NULL || head->next == NULL)
	    {
	        return;
	    }
	    else
	    {
	        Node* p = NULL;
	        Node* q = head;
	        Node* r = head->next;
	        
	        while(r != NULL)
	        {
	            q->next = p;
	            q->prev = r;
	            
	            p = q;
	            q = r;
	            r = r->next;
	        }
	        
	        // Modify the last Node
	        q->next = p;
	        q->prev = r;
	        
	        ::head = q;
	    }
	}




2. C++ Implementation

	Node* reverseDLL(Node* head)
	{
		if(head == NULL || head->next == NULL)
		{
			return head;
		}

		Node* prev = NULL;
		Node* curr = head;

		while(curr != NULL)
		{
			prev = curr->prev;
			curr->prev = curr->next;
			curr->next = prev;
			curr = curr->prev;
		}

		return prev->prev;
	}


























Delete Head of a Doubly Linked List
-------------------------------------------------------------------

1. My Solution

	void deleteFirstNode(Node* head)
	{
	    if(head==NULL || head->next == NULL)
	    {
	        delete head;
	        ::head = NULL;
	    }
	    else
	    {
	        head->next->prev = NULL;
	        ::head = head->next;
	        delete head;   
	    }
	}




2. C++ Implementation

	Node* deleteHead(Node* head)
	{
		if(head == NULL)
		{
			return NULL;
		}

		if(head->next == NULL)
		{
			delete head;		// In C++, we need to deallocate the memory explicitly
			return NULL:
		}
		else
		{
			Node* temp = head;
			head = head->next;
			head->prev = NULL;
			delete temp;		// In C++, we need to deallocate the memory explicitly
			return head;
		}
	}




3. Java Implementation

	Node deleteHead(Node head)
	{
		if(head == null)
		{
			return null;
		}

		if(head.next == null)
		{
			return null;
		}
		else
		{
			head = head.next;
			head.prev = null;
			return head;
		}
	}






























Delete Last Node of a Doubly Linked List
---------------------------------------------------------------------

1. My Solution

	void deleteLastNode(Node* head)
	{
	    if(head==NULL || head->next==NULL)
	    {
	        ::head = NULL;
	        ::tail = NULL;
	        delete head;
	    }
	    else
	    {
	        while(head->next->next != NULL)
	        {
	            head = head->next;
	        }
	        
	        tail = head;
	        delete head->next;
	        tail->next = NULL;
	    }
	}




2. C++ Implementation

	Node* deleteLast(Node* head)
	{
		if(head == NULL)
		{
			return NULL;
		}

		if(head->next == NULL)
		{
			delete head;
			return NULL;
		}

		Node* curr = head;
		while(curr->next != NULL)
		{
			curr = curr->next;
		}

		curr->prev->next = NULL;

		delete curr;					// Java: this step is not required in java

		return head;
	}



























Insert at the End of Doubly Linked List
-------------------------------------------------------------------

1. My Solution

	struct Node {
	    int data;
	    Node* prev;
	    Node* next;
	    
	    // Constructor
	    Node(int data)
	    {
	        this->data = data;
	        prev = NULL;
	        next = NULL;
	    }
	};

	Node* head = NULL;
	Node* tail = NULL;


	void insertAtEnd(int x)
	{
	    // head and tail are global variables
	    Node *temp = new Node(x);
	    if(head==NULL)              // if(tail == NULL)
	    {
	        head = tail = temp;
	        return;
	    }
	    tail->next = temp;
	    temp->prev = tail;
	    tail = temp;
	}




2. C++ Implementation

	Node* insertAtEnd(Node* head, int data)
	{
		Node* temp = new Node(data);

		if(head == NULL)
		{
			return temp;
		}

		Node* curr = head;

		while(curr->next != NULL)
		{
			curr = curr->next;
		}

		curr->next = temp;
		temp->prev = curr;

		return head;
	}


























Circular Linked List in C++
---------------------------------------------------------

-> next of Last Node point to First Node

-> Structure of Circular Linked List is same as Singly Linked List


-> Structure of Circular Linked List

	struct Node{
		int data;
		Node* next;

		Node(int data)
		{
			this.data = data;
			next = NULL;
		}
	}



Note:
	A Circular Linked List can be Singly Circular or Doubly Circular.
	In our discussion, we are considering Singly Circular Linked List only.




1. Creating a Circular Linked List of 4 Nodes

	int main()
	{
		Node* head = new Node(10);
		head->next = new Node(5);
		head->next->next = new Node(20);
		head->next->next->next = new Node(15);

		head->next->next->next->next = head;	// Making the last Node points to First Node

		return 0;
	}




























Circular Linked List in Java
------------------------------------------------------------

-> class for the Node of a Circular Linked List

	class Node {
		int data;
		Node next;

		Node(int data) {
			this.data = data;
			next = null;
		}
	}



-> Simple Java Program to create a Circular Linked List with 4 Nodes

	class Test {
		public static void main(String args[]) {
			Node head = new Node(10);
			head.next = new Node(5);
			head.next.next = new Node(20);
			head.next.next.next = new Node(15);

			head.next.next.next.next = head;
		}
	}






























Circular Linked List (Advantages & Disadvantages)
--------------------------------------------------------------------------------

1. Advantages
	-> We can traverse the whole list starting from any Node

	-> Implementation of algorithms like "Round Robin"
		// Round Robin is a CPU scheduling algorithm that we generally study in "Operating Systems"

	-> We can insert at the beginning and end by just maintaining 
		one "tail" reference/pointer


2. Disadvantages
	-> Implementations of operations becomes complex 




























Circular Linked List Traversal in C++
------------------------------------------------------------------------------

1. My Solution

	struct Node {
	    int data;
	    Node* next;
	    
	    Node(int data) {
	        this->data = data;
	        next = NULL;
	    }
	};

	// Global Head and Tail Pointers
	// Node* head = NULL;   // We don't need head pointer, tail pointer is self sufficient
	Node* tail = NULL;

	void insertAtBegin(int x)
	{
	    if(tail == NULL)
	    {
	        tail = new Node(x);
	        tail->next = tail;
	    }
	    else
	    {
	        Node* temp = new Node(x);
	        temp->next = tail->next;
	        tail->next = temp;
	    }
	}

	void insertAtEnd(int x)
	{
	    if(tail == NULL)
	    {
	        tail = new Node(x);
	        tail->next = tail;
	    }
	    else
	    {
	        Node* temp = new Node(x);
	        temp->next = tail->next;
	        tail->next = temp;
	        tail = temp;
	    }
	}

	void display()
	{
	    cout<<"[ ";
	    if(tail == NULL)
	    {
	        cout<<"]"<<endl;
	        return;
	    }
	    else
	    {
	        Node* first = tail->next;
	        while(first->next != tail->next)
	        {
	            cout<<first->data<<" ";
	            first = first->next;
	        }
	        cout<<first->data<<" ";
	        cout<<"]"<<endl;
	    }
	}

	int main()
	{
	    display();
	    insertAtBegin(10);
	    display();
	    insertAtBegin(20);
	    display();
	    insertAtBegin(30);
	    display();

	    return 0;
	}








2. C++ Implementation - Method 1 (Using For Loop)

	void printList(Node* head)
	{
		if(head == NULL)
		{
			return;
		}

		cout<<head->data<<" ";

		for(Node* p = head->next; p != head; p = p->next)
		{
			cout<<p->data<<" ";
		}
	}





3. C++ Implementation - Method 2 (Using do-while Loop)

	void printList(Node* head)
	{
		if(head == NULL)
		{
			return;
		}

		Node* p = head;

		do {

			cout<<p->data<<" ";
			p = p->next;

		}while(p != head);
	}





























Circular Linked List Traversal in Java
------------------------------------------------------------------------


1. Java Implementation - Method 1 (Using For Loop)

	void printList(Node head)
	{
		if(head == null)
		{
			return;
		}

		System.out.print(head.data + " ");

		for(Node p = head.next; p != head; p = p.next)
		{
			System.out.print(p.data + " ");
		}
	}





2. Java Implementation - Method 2 (Using do-while Loop)

	void printList(Node head)
	{
		if(head == NULL)
		{
			return;
		}

		Node p = head;

		do {

			System.out.print(p.data + " ");
			p = p.next;

		}while(p != head);
	}






























Insert at Begin of Circular Linked List
---------------------------------------------------------------------

1. My Solution

	void insertAtBegin(int x)
	{
	    if(tail == NULL)
	    {
	        tail = new Node(x);
	        tail->next = tail;
	    }
	    else
	    {
	        Node* temp = new Node(x);
	        temp->next = tail->next;
	        tail->next = temp;
	    }
	}


	Time Complexity:	O(1)





2. Naive Solution: C++ Implementation

	-> In this case, we need to reach to the last Node so that we can make it point to 
		newly inserted Node at the beginning.

	Node* insertAtBegin(Node* head, int x)
	{
		Node* temp = new Node(x);

		if(head == NULL)
		{
			temp->next = temp;
		}
		else
		{
			Node* curr = head;

			while(curr->next != head)
			{
				curr = curr->next;
			}

			curr->next = temp;
			temp->next = head;
		}

		return temp;
	}


	Time Complexity:	O(n) 





3. Tricky Solution: 

	-> To insert a Node at begining in a Singly Circular Linked List in O(1) time, 
		when only head Node reference is given.

	-> Steps:
		a. Node temp = new Node(data);

		b. temp->next = head->next;

		c. swap(head->data, temp->data);

		d. head->next = temp;



	-> C++ Implementation

		Node *insertAtBegin(Node* head, int x)
		{
			Node* temp = new Node(x);

			if(head == NULL)
			{
				temp->next = temp;
				return temp;
			}
			else
			{
				temp->next = head->next;
				head->next = temp;

				int t = head->data;
				head->data = temp->data;
				temp->data = t;

				return head;
			}
		}


		Time Complexity:	O(1)




























Insert at the End of Circular Linked List
---------------------------------------------------------------------------------

1. My Solution

	void insertAtEnd(int x)
	{
	    if(tail == NULL)
	    {
	        tail = new Node(x);
	        tail->next = tail;
	    }
	    else
	    {
	        Node* temp = new Node(x);
	        temp->next = tail->next;
	        tail->next = temp;
	        tail = temp;
	    }
	}






2. Naive Solution: C++ Implementation

	Node* insertAtEnd(Node* head, int x)
	{
		Node* temp = new Node(x);

		if(head == NULL)
		{
			temp->next = temp;
			return temp;
		}
		else
		{
			Node* curr = head;

			while(curr->next != head)
			{
				curr = curr->next;
			}

			curr->next = temp;
			temp->next = head;

			return head;
		}
	}






3. Tricky Solution: 

	-> To insert a Node at End in a Singly Circular Linked List in O(1) time, 
		when only head Node reference is given.

	-> Steps:
		a. Node temp = new Node(data);

		b. temp->next = head->next;

		c. head->next = temp;

		d. swap(head->data, temp->data);

		e. head = temp;



	-> C++ Implementation

		Node *insertAtBegin(Node* head, int x)
		{
			Node* temp = new Node(x);

			if(head == NULL)
			{
				temp->next = temp;
				return temp;
			}
			else
			{
				temp->next = head->next;
				head->next = temp;

				int t = head->data;
				head->data = temp->data;
				temp->data = t;

				return temp;
			}
		}


		Time Complexity:	O(1)




























Delete Head of Circular Linked List
-------------------------------------------------------------------

1. My Solution

	void deleteFirstNode()
	{
	    if(tail == NULL)
	    {
	        return;
	    }
	    else if(tail->next == tail)
	    {
	        delete tail;
	        ::tail = NULL;
	    }
	    else
	    {
	        Node* temp = tail->next;
	        tail->next = tail->next->next;
	        delete temp;
	    }
	}




2. Naive Solution: C++ Implementation

	Node* deleteHead(Node* head)
	{
		if(head == NULL)
		{
			return NULL;
		}

		if(head->next == head)
		{
			delete head;
			return NULL;
		}

		Node* curr = head;

		while(curr->next != head)
		{
			curr = curr->next;
		}

		curr->next = head->next;
		delete head;

		return curr->next;
	}


	Time Complexity:	O(n)




3. Efficient Solution: C++ Implementation

	Node* deleteHead(Node* head)
	{
		if(head == NULL)
		{
			return NULL;
		}

		if(head->next == head)
		{
			delete head;
			return NULL;
		}

		head->data = head->next->data;

		Node* temp = head->next;

		head->next = head->next->next;

		delete temp;

		return head;
	}


	Time Complexity:	O(1)







































Delete Kth Node of a Circular Linked List
---------------------------------------------------------------------------------

1. My Solution

	void deleteKthNode(int k)
	{
	    if(tail == NULL || k<1)
	    {
	        return;
	    }
	    else if(tail->next == tail)
	    {
	        delete tail;
	        ::tail = NULL;
	    }
	    else
	    {
	        Node* p = NULL;
	        Node* q = tail;
	        
	        for(int i=1; i<=k; i++)
	        {
	            p = q;
	            q = q->next;
	        }
	        
	        p->next = q->next;
	        
	        // before deleting Node q check if it is tail Node
	        if(q == tail)
	        {
	            tail = p;
	        }
	        delete q;
	    }
	}




2. C++ Implementation

	Node* deleteKth(Node* head, int k)
	{
		if(head == NULL)
		{
			return head;
		}

		if(k == 1)
		{
			return deleteHead(head);
		}

		Node* curr = head;

		for(int i=0; i < k-2; i++)
		{
			curr = curr->next;
		}

		Node* temp = curr->next;
		curr->next = curr->next->next;

		delete temp;

		return head;
	}
































Circular Doubly Linked List
--------------------------------------------------------------------------

-> In Circular Doubly Linked List
	1. Previous of head is last Node
	2. Next of last Node is head Node

	3. An empty Circular Doubly Linked List => head = NULL or null



-> Advantages of Circular Doubly Linked List
	1. We get all advantages of circular and doubly linked list

	2. We can access last Node in constant time without maintaining 
		extra tail pointer/reference.





1. Important Operations on Doubly Circular Linked List

	struct Node {
	    int data;
	    Node* prev;
	    Node* next;
	    
	    Node(int data) {
	        this->data = data;
	        prev = NULL;
	        next = NULL;
	    }
	};

	Node* head = NULL;

	void insertAtBegin(int x)
	{
	    Node* temp = new Node(x);
	    if(head == NULL)
	    {
	        head = temp;
	        head->next = head;
	        head->prev = head;
	    }
	    else
	    {
	        Node* tail = head->prev;
	        temp->next = head;
	        temp->prev = tail;
	        tail->next = temp;
	        head->prev = temp;
	        head = temp;
	    }
	}


	void insertAtEnd(int x)
	{
	    Node* temp = new Node(x);
	    if(head == NULL)
	    {
	        head = temp;
	        head->prev = head->next = head;
	    }
	    else
	    {
	        Node* tail = head->prev;
	        
	        temp->next = head;
	        temp->prev = tail;
	        head->prev = temp;
	        tail->next = temp;
	    }
	}





	void display()
	{
	    cout<<"[ ";
	    if(head == NULL)
	    {
	        cout<<"]\n";
	    }
	    else
	    {
	        Node* temp = head;
	        do{
	            cout<<temp->data<<" ";
	            temp = temp->next;
	        }while(temp!=head);
	        
	        cout<<"]\n";
	    }
	}





2. Insert at Head: C++ Implementation

	void insertAtHead(Node* head, int x)
	{
		Node* temp = new Node(x);

		if(head == NULL)
		{
			temp->next = temp;
			temp->prev = temp;
			return temp;
		}

		head->prev->next = temp;
		temp->next = head;
		head->prev = temp;

		return temp;
	}



3. Insert at End: C++ Implementation

	void insertAtEnd(Node* head, int x)
	{
		Node* temp = new Node(x);

		if(head == NULL)
		{
			temp->next = temp;
			temp->prev = temp;
			return temp;
		}

		head->prev->next = temp;
		temp->next = head;
		head->prev = temp;

		return head;
	}






























Sorted Insert in a Singly Linked List
-----------------------------------------------------------------

1. My Solution

	void sortedInsert(int x)
	{
	    Node* temp = new Node(x);
	    
	    if(head == NULL)
	    {
	        head = temp;
	    }
	    else if(x <= head->data)
	    {
	        temp->next = head;
	        head = temp;
	    }
	    else
	    {
	        Node* p = NULL;
	        Node* q = head;
	        while((q != NULL) && (q->data < x))
	        {
	            p = q;
	            q = q->next;
	        }
	        p->next = temp;
	        temp->next = q;
	    }
	}





2. C++ Implementation

	Node* sortedInsert(Node* head, int x)
	{
		Node* temp = new Node(x);

		if(head == NULL)
		{
			return temp;
		}

		if(x < head->data)
		{
			temp->next = head;
			return temp;
		}

		Node* curr = head;
		while((curr->next != NULL) && (curr->next->data < x))
		{
			curr = curr->next;
		}

		temp->next = curr->next;
		curr->next = temp;

		return head;
	}


	Time Complexity:	O(position_Of_Insert) 






























Middle of Linked List
-----------------------------------------------------------

-> If there are two middle elements, then we have to print the 2nd element

-> When there is no element, then print nothing


1. My Naive Solution

	void printMiddleInTwoTraversal()
	{
	    if(head == NULL)
	    {
	        cout<<"\nLinked List is Empty\n";
	    }
	    else
	    {
	        int size = 0;
	        
	        Node* temp = head;
	        while(temp != NULL)
	        {
	            size++;
	            temp = temp->next;
	        }
	        
	        int pos = size/2 + 1;
	        
	        Node* mid = head;
	        
	        for(int i=1; i<pos; i++)
	        {
	            mid = mid->next;
	        }
	        
	        cout<<"\nMiddle Element of the List is: "<<mid->data<<endl;
	    }
	}



2. My Efficient Solution

	void printMiddleInOneTraversal()
	{
	    if(head == NULL)
	    {
	        cout<<"\nLinked List is Empty\n";
	    }
	    else
	    {
	        Node* p = NULL;
	        Node* q = head;
	        
	        while(q != NULL)
	        {
	            if(p == NULL)
	            {
	                p = head;
	            }
	            else
	            {
	                p = p->next;
	            }
	            q = q->next;
	            if(q == NULL)
	            {
	                cout<<"\nMiddle Element of the List is: "<<p->data<<endl;
	                return;
	            }
	            q = q->next;
	        }
	        
	        cout<<"\nMiddle Element of the List is: "<<p->next->data<<endl;
	    }
	}




3. Naive Solution: Uses Two traversals of the Linked List

	-> The idea of Naive Solution is first we count the number of Nodes in Linked List

	void printMiddle(Node* head)
	{
		if(head == NULL)
		{
			return;
		}

		int count = 0;

		Node* curr;
		for(curr = head; curr != NULL; curr = curr->next)
		{
			count++;
		}

		curr = head;
		for(int i=0; i < count/2; i++)
		{
			curr = curr->next;
		}
		cout<<curr->data;
	}




4. Efficient Solution: Uses only one traversal of the Linked List

	-> The solution is based on the idea of "Slow" and "Fast" pointers/references.
		a. "Slow" moves one node at a time

		b. "Fast" moves two nodes at a time


	void printMiddle(Node* head)
	{
		if(head == NULL)
		{
			return;
		}

		Node* slow = head;
		Node* fast = head;

		while((fast != NULL) && (fast->next != NULL))
		{
			slow = slow->next;
			fast = fast->next->next;
		}

		cout<<slow->data;
	}






























Nth Node from end of Linked List
--------------------------------------------------------------

1. My Solution

	void printNthNodeFromEnd(int n)
	{
	    if((head == NULL) || (n < 1))
	    {
	        cout<<"\nNode doesn't exist\n";
	    }
	    else
	    {
	        int size = 0;
	        Node* t = head;

	        // 1st traversal
	        while(t != NULL)
	        {
	            size++;
	            t = t->next;
	        }
	        
	        if(n > size)
	        {
	            cout<<"\nNode doesn't exist\n";
	        }
	        else
	        {
	            int pos = size-n+1;
	            t = head;
	            
	            // 2nd traversal
	            for(int i=1; i<pos; i++)
	            {
	                t = t->next;
	            }
	            cout<<"\nNth Node from end is: "<<t->data<<endl;
	        }
	    }
	}



2. My 2nd Solution

	void printNthNodeFromEndMethod2(int n)
	{
	    if(n < 1)
	    {
	        cout<<"\nNode doesn't exist\n";
	        return;
	    }
	    if(head == NULL)
	    {
	        cout<<"\nNode doesn't exist\n";
	    }
	    else
	    {
	        Node* p = head;
	        Node* q = head;
	        
	        for(int i=1; i<n; i++)
	        {
	            if(q == NULL)
	            {
	                cout<<"\nNode doesn't exist\n";
	                return;
	            }
	            q = q->next;
	        }
	        
	        if(q == NULL)
	        {
	            cout<<"\nNode doesn't exist\n";
	            return;
	        }
	        
	        while(q->next != NULL)
	        {
	            p = p->next;
	            q = q->next;
	        }
	        cout<<"\nNth Node from end is: "<<p->data<<endl; 
	    }
	}





3. Method 1: Using Length of Linked List

	void printNthFromEndInTwoTraversal(Node* head, int n)
	{
		int len = 0;
		for(Node* curr = head; curr != NULL; curr = curr->next)
		{
			len++;
		}

		if(n > len)
		{
			return;
		}

		Node* curr = head;
		for(int i=1; i < len-n+1; i++)
		{
			curr = curr->next;
		}
		cout<<curr->data<<endl;
	} 




4. Method 2: Using Two Pointers/References

	-> Idea/Steps
		a. Move "first pointer" N positions ahead

		b. Start "second pointer" from head

		c. Move both "first" and "second" at same speed. When "first" 
			reaches NULL, "second" reaches the required Node.



	-> C++ Implementation

		void printNthEnd(Node* head, int n)
		{
			if(head == NULL)
			{
				return;
			}

			Node* first = head;
			for(int i=0; i<n; i++)
			{
				if(first == NULL)
				{
					return;
				}
				first = first->next;
			}

			Node* second = head;
			while(first != NULL)
			{
				second = second->next;
				first = first->next;
			}

			cout<<second->data<<endl;

		}































Reverse a Linked List Iterative
--------------------------------------------------------------------------------

1. My Solution

	void iterativeReverse()
	{
	    if(head == NULL || head->next == NULL)
	    {
	        return;
	    }
	    
	    Node* p = NULL;
	    Node* q = head;
	    while(q != NULL)
	    {
	        Node* r = q->next;
	        q->next = p;
	        p = q;
	        q = r;
	    }
	    head = p;
	}




2. Naive Solution
	
	-> C++ Implementation

		Node* revList(Node* head)
		{
			vector<int> arr;

			for(Node* curr = head; curr != NULL; curr = curr->next)
			{
				arr.push_back(curr->data);
			}

			for(Node* curr = head; curr != NULL; curr = curr->next)
			{
				curr->data = arr.back();
				arr.pop_back();
			}

			return head;
		}


	-> Java Implementation

		Node revList(Node head)
		{
			ArrayList<Integer> arr = new ArrayList<Integer>();

			for(Node curr = head; curr != NULL; curr = curr.next)
			{
				arr.add(curr.data);
			}

			for(Node* curr = head; curr != NULL; curr = curr->next)
			{
				curr.data = arr.remove(arr.size()-1);
			}

			return head;
		}






3. Efficient Solution

	Node* reverse(Node* head)
	{
		Node* curr = head;
		Node* prev = NULL;

		while(curr != NULL)
		{
			Node* next = curr->next;
			curr->next = prev;
			prev = curr;
			curr = next;
		}

		return prev;		// prev is new head
	}	



























Recursive reverse a Linked List (Part 1) -> Method 1
-------------------------------------------------------------------------
#Repeat

1. My Solution

	1.1. C++ Implementation-1

		Node* recursiveReverse(Node* head, Node* prev)
		{
		    if(head == NULL)
		    {
		        return prev;
		    }
		    
		    Node* p = head->next;
		    head->next = prev;
		    return recursiveReverse(p, head);
		}



		int main()
		{
		    insertAtEnd(head, 3);
		    insertAtEnd(head, 20); 
		    display(head);
		    
		    cout<<"\n===================After Recursive Reverse=======================\n";
		    head = recursiveReverse(head, NULL);
		    display(head);

		    return 0;
		}	


	1.2. C++ Implementation-2

		Node* recursiveReverse(Node* head, Node* prev = NULL)
		{
		    if(head == NULL)
		    {
		        return prev;
		    }
		    
		    Node* p = head->next;
		    head->next = prev;
		    return recursiveReverse(p, head);
		}



		int main()
		{
		    insertAtEnd(head, 3);
		    insertAtEnd(head, 20); 
		    display(head);
		    
		    cout<<"\n===================After Recursive Reverse=======================\n";
		    head = recursiveReverse(head);
		    display(head);

		    return 0;
		}	





2. Recursive Reverse (Method - 1)

	-> Idea: We will recursively last "n-1" Nodes, then we will link current Node to the already 
			 reversed Linked List

	Node* recRevL(Node* head)
	{
		if((head == NULL) || (head->next == NULL))
		{
			return head;
		}

		Node* rest_head = recRevL(head->next);
		Node* rest_tail = head->next;
		rest_tail->next = head;
		head->next = NULL;
		return rest_head;
	}





























Recursive reverse a Linked List (Part 2) -> Method 2
-------------------------------------------------------------------------

1. My Solution

	1.1. C++ Implementation-1

		Node* recursiveReverse(Node* head, Node* prev)
		{
		    if(head == NULL)
		    {
		        return prev;
		    }
		    
		    Node* p = head->next;
		    head->next = prev;
		    return recursiveReverse(p, head);
		}



		int main()
		{
		    insertAtEnd(head, 3);
		    insertAtEnd(head, 20); 
		    display(head);
		    
		    cout<<"\n===================After Recursive Reverse=======================\n";
		    head = recursiveReverse(head, NULL);
		    display(head);

		    return 0;
		}	


	1.2. C++ Implementation-2

		Node* recursiveReverse(Node* head, Node* prev = NULL)
		{
		    if(head == NULL)
		    {
		        return prev;
		    }
		    
		    Node* p = head->next;
		    head->next = prev;
		    return recursiveReverse(p, head);
		}



		int main()
		{
		    insertAtEnd(head, 3);
		    insertAtEnd(head, 20); 
		    display(head);
		    
		    cout<<"\n===================After Recursive Reverse=======================\n";
		    head = recursiveReverse(head);
		    display(head);

		    return 0;
		}	





2. Recursive Solution (Method-2)

	-> Idea: We will first recursively reverse the first "n-1" Nodes and then
			 we will link the Nth node to the Reverse Linked List.


	Node* recRevL(Node* curr, Node* prev)
	{
		if(curr == NULL)
		{
			return prev;
		}

		Node* next = curr->next;
		curr->next = prev;

		return recRevL(next, curr);
	}


























Remove duplicates from a sorted Singly Linked List
----------------------------------------------------------------------------

1. My Solution

	void removeDuplicatesFromSortedList()
	{
	    Node* p = head;
	    
	    while(p != NULL)
	    {
	        if(p->next != NULL && p->next->data == p->data)
	        {
	            Node* temp = p->next;
	            p->next = p->next->next;
	            delete temp;
	        }
	        else
	        {
	            p = p->next;
	        }
	    }
	}





2. C++ Implementation

	void removeDups(Node* head)
	{
		Node* curr = head;

		while(curr != NULL && curr->next != NULL)
		{
			if(curr->data == curr->next->data)
			{
				Node* temp = curr->next;
				curr->next = curr->next->next;
				delete temp;
			}
			else
			{
				curr = curr->next;
			}
		}
	}






























Reverse a Linked List in groups of size K
-----------------------------------------------------------------------
#Repeat
#Revise


1. Recursive Solution

	Node* reverseInGroupsOfK(Node* head, int k)
	{
		Node* curr = head;
		Node* prev = NULL;
		Node* next = NULL;

		int count = 0;

		while(curr != NULL && count < k)
		{
			next = curr->next;
			curr->next = prev;
			prev = curr;
			curr = next;
			count++;
		}

		if(next != NULL)
		{
			Node* rest_head = reverseInGroupsOfK(next, k);
			head->next = rest_head;
		}

		return prev;		// prev is new head 
	}


	Time Complexity:	O(n)
	Space Complexity:	O(n/k)





2. Iterative Solution

	Node* reverseInGroupsOfK(Node* head, int k)
	{
		Node* curr = head;
		Node* prevFirst = NULL;
		bool isFirstPass = true;

		while(curr != NULL)
		{
			Node* first = curr;
			Node* prev = NULL;

			int count = 0;
			while(curr != NULL && count < k)
			{
				Node* next = curr->next;
				curr->next = prev;
				prev = curr;
				curr = next;
				count++;
			}

			if(isFirstPass)
			{
				head = prev;
				isFirstPass = false;
			}
			else
			{
				prevFirst->next = prev;
			}

			prevFirst = first;
		}

		return head;
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)




























Detect Loop
-------------------------------------------------------------------

1. My Solution

	bool isLoopPresent()
	{
	    Node* p = head;
	    Node* q = head;
	    
	    while(p != NULL && q != NULL)
	    {
	        q = q->next;
	        
	        if(q == NULL)
	            return false;
	        else    
	            q = q->next;
	            
	        if(p == q)
	            return true;
	        else    
	            p = p->next;
	    }
	    
	    return false;
	}




2. Method 1: Naive Solution - (Time Complexity: O(N^2))
	
	-> For each Node at ith position, we will run a loop till (i-1)th position
		and we will check if Node reference is same as the "next" of ith Node.




3. Method 2: - (Time Complexity: O(N))

	-> If modification to linked list structure is allowed


	-> Structure of Linked List Node for this solution

		struct Node 
		{
			int data;
			Node* next;
			bool visited;

			Node(int x)
			{
				data = x;
				next = NULL;
				visited = false;
			}
		}






4. Method 3: - (Time Complexity: O(N)) 

	-> Modifications to Linked List Pointers/References

	-> Using a Dummy Node

	bool isLoop(Node* head)
	{
		Node* temp = new Node;
		Node* curr = head;

		while(curr != NULL)
		{
			if(curr->next == NULL)
			{
				return false;
			}

			if(curr->next == temp)
			{
				return true;
			}

			Node* curr_next = curr->next;
			curr->next = temp;
			curr = curr_next;
		}

		return false;
	}






5. Method 4: - (Time Complexity: O(N))  

	-> Using Hashing

	-> Doesn't modify the structure or References/Pointers


	-> C++ Implementation

		bool isLoop(Node* head)
		{
			unordered_set<Node*> s;				// Java: HashSet<Node> s = new HashSet<Node>();

			for(Node* curr = head; curr != NULL; curr = curr-next)
			{
				if(s.find(curr) != s.end())		// Java: if(s.contains(curr))
				{
					return true;
				}

				s.insert(curr);
			}

			return false;
		}


		Time Complexity: 	O(N)
		Space Complexity:	O(N)






























Detect Loop using Floyd Cycle Detection
---------------------------------------------------------------------------

-> Algorithm
	
	1. Initialize slowPointer = head, fastPointer = head

	2. Move slowPointer by one and fastPointer by two. If these 
		pointers meet, then there is a loop.



-> Some Important points about the Algorithm

	1. fastPointer will enter into the loop before (or at same time as slowPointer)

	2. Let fastPointer be K distance ahead of slowPointer, when slowPointer enters the loop
		where K >= 0

	3. This distance keeps on increasing "by one" in every movement of both pointers

	4. When distance becomes length of cycle, they meet



1. C++ Implementation

	bool isLoop(Node* head)
	{
		Node* slowPointer = head;
		Node* fastPointer = head;

		while(fastPointer != NULL && fastPointer->next != NULL)
		{
			slowPointer = slowPointer->next;
			fastPointer = fastPointer->next->next;

			if(slowPointer == fastPointer)
			{
				return true;
			}
		}

		return false;
	}


	Time Complexity:	O(n)
	Space Complexity:	O(1)































Detect and Remove loop in Linked List
-----------------------------------------------------------------------------

-> Idea behind the Algorithm

	1. Detect loop using Floyd's loop detection algorithm

	2. Move "slowPointer" to the beginning(head) of Linked List and keep "fastPointer" at the 
		meeting point

	3. Now one by one move slowPointer and fastPointer(at same speed).
		The point where they meet now is the first Node of the loop.





1. C++ Implementation

	void detectAndRemoveLoop(Node* head)
	{
		Node* slowPointer = head;
		Node* fastPointer = head;

		while(fastPointer != NULL && fastPointer->next != NULL)
		{	
			slowPointer = slowPointer->next;
			fastPointer = fastPointer->next->next;

			if(slowPointer == fastPointer)
			{
				break;
			}
		}

		if(slowPointer != fastPointer)
		{
			return;
		}

		slowPointer = head;
		while(slowPointer->next != slowPointer->next)
		{
			slowPointer = slowPointer->next;
			fastPointer = fastPointer->next;
		}

		fastPointer->next = NULL;
	}





-> Working of the Algorithm

	1. Before the First Meeting Point:
		-> (Distance travelled by "slow")*2 = (Distance travelled by "fast")

		-> (m + k + x*n)*2 = (m + k + y*n)

			-> x: No. of iterations made by "slow" before the first meeting point
			-> y: No. of iterations made by "fast" before the first meeting point
			-> n: Cycle/Loop length

		-> (m + k) = n(y - 2x) => (m + k) is a multiple of n


	2. After the First Meeting Point:
		-> If (m + k) is a multiple of n, then second meeting point is going to be
			the first Node of the Loop/Cycle.




-> Some other Variations based on this Algorithm commonly asked in Interviews

	1. Find length of loop.					// Variation of Loop detection Problem

	2. Find the first Node of the loop.		// Variation of Loop removal Problem





























Delete Node with only Pointer given to it
--------------------------------------------------------------------------------------

-> Trick Interview question
	1. Assumption: Node to be deleted is never last Node of the list.


1. C++ Implementation

	void deleteSomeRandomNode(Node* ptr)
	{
		Node* temp = ptr->next;
		ptr->data = temp->data;
		ptr->next = temp->next;

		delete temp;
	}

































Segregate Even and Odd Nodes in C++
------------------------------------------------------------------------------------

1. My Solution

	void segragateEvenAndOddNodes()
	{
	    Node *hd = head;
	    
	    // First we will find firstEvenReference and firstOddReference
	    Node* firstEvenReference = NULL;
	    Node* firstOddReference = NULL;
	    
	    while(hd != NULL)
	    {
	        if(firstEvenReference!=NULL && firstOddReference!=NULL)
	        {
	            break;
	        }
	        
	        if(firstEvenReference == NULL && hd->data % 2 == 0)
	        {
	            firstEvenReference = hd;
	        }
	        
	        if(firstOddReference == NULL && hd->data % 2 != 0)
	        {
	            firstOddReference = hd;
	        }
	        
	        hd = hd->next;
	    }
	    
	    if(firstEvenReference==NULL || firstOddReference==NULL)
	    {
	        // This implies that the List contails only odd or only even elements
	        return;
	    }
	    
	    hd = head;
	    Node* p = firstEvenReference;
	    Node* q = firstOddReference;
	    while(hd != NULL)
	    {
	        if(hd->data%2 == 0 && hd != firstEvenReference)
	        {
	            p->next = hd;
	            p = hd;
	            hd = hd->next;
	        }
	        else if(hd->data%2 != 0 && hd != firstOddReference)
	        {
	            q->next = hd;
	            q = hd;
	            hd = hd->next;
	        }
	        else
	        {
	            hd = hd->next;    
	        }
	    }
	    
	    p->next = firstOddReference;
	    q->next = NULL;
	    
	    head = firstEvenReference;
	}




2. Naive Solution

	-> Requires Two Traversals

	-> Time Complexity:		O(n)
	-> Space Complexity:	O(1)

	-> Steps:
		1. Find the last node reference/pointer by doing a traversal

		2. Traverse the linked list again. For every odd node, insert it after
			the last node and make the newly inserted node as the new last node






3. Efficient Solution

	-> Idea for the One Traversal Solution

		1. We maintain 4 variables(pointers/references)
			-> es: Reference/Pointer to start of the even sublist
			-> ee: Reference/Pointer to end of the even sublist
			-> os: Reference/Pointer to start of the odd sublist
			-> oe: Reference/Pointer to end of the odd sublist

			Note: All of the above are initialized as NULL(C++)/null(Java)/None(Python)


		2. While Traversing
			a. If current node is even, we insert it after ee and update ee.
				Also update es if this is the first node.

			b. Similar to "a", for odd nodes.


		3. After the loop, connect the two lists. 
			-> ee->next = os;







4. C++ Implementation of Efficient Solution

	Node* segragate(Node* head)
	{
		Node *es = NULL, *ee = NULL, *os = NULL, *oe = NULL;

		for(Node* curr = head; curr != NULL; curr = curr->next)
		{
			int x = curr->data;
			if(x%2 == 0)
			{
				if(es == NULL)
				{
					es = ee = curr;
				}
				else
				{
					ee->next = curr;
					ee = ee->next;		// ee = curr;
				}
			}
			else
			{
				if(os == NULL)
				{
					os = oe = NULL;
				}
				else
				{
					oe->next = curr;
					oe = oe->next; 		// oe = curr;
				}
			}
		}

		if((os == NULL) || (es == NULL))
		{
			return head;
		}

		ee->next = os;
		oe->next = NULL;

		return es;
	}































Intersection of two Linked List
--------------------------------------------------------------------

1. Method 1 - (Time Complexity = O(m+n), Space Complexity = O(m+n))

	Steps:
		a. Create an empty HashSet/unordered_set, hs.

		b. Traverse the first list and put all of its Nodes(Nodes References/Pointers)
			into the hs.

		c. Traverse the second list and look for every Node if it is already present in 
			the HashSet, As soon as we find a Node present in the HashSet, we return 
			its Value.


	-> Time Complexity:		O(m+n)
	-> Space Complexity:	O(m+n)





2. Method 2 - (Time Complexity = O(m+n), Space Complexity = O(1))

	Steps:
		a. Count Nodes in both the lists. Let count be m and n

		b. Traverse the bigger list abs(m-n) times.

		c. Traverse both the lists simultaneously until we see a common Node.


	-> Time Complexity:		O(m+n)
	-> Space Complexity:	O(1)



























Pairwise Swap Nodes of Linked List in C++
---------------------------------------------------------------------------------

1. Naive Solution  

	-> Idea for Naive Solution

		1. Run a loop while we have at least one Node ahead

			a. Swap data of current Node with its next Node
			b. Move current two nodes ahead



	-> C++ Implementation

		// This function does not modify the head of the Linked List
		Node* pairWiseSwap(Node* head)
		{
			Node* curr = head;
			while(curr != NULL && curr->next != NULL)
			{
				swap(curr->data, curr->next->data);
				curr = curr->next->next;
			}

			return head;
		}


		-> Time Complexity:	O(n)



2. Efficient Solution

	Node* pairwiseSwap(Node* head)
	{
		if(head == NULL && head->next == NULL)
		{
			return head;
		}

		Node* curr = head->next->next;
		Node* prev = head;

		head = head->next;
		head->next = prev;

		while(curr != NULL && curr->next != NULL)
		{
			prev->next = curr->next;
			prev = curr;

			Node* next = curr->next->next;
			curr->next->next = curr;
			curr = next;
		}

		prev->next = curr;			// It will take care of Even and Odd Number of Nodes both

		return head;
	} 


	-> Time Complexity:		O(n)
	-> Space Complexity:	O(1)





























Clone a Linked List with Random Pointer in C++
-----------------------------------------------------------------------------------
#Revise

1. Method-1 (Using Hashing)
	
	-> Time Complexity:		O(n)
	-> Space Complexity:	O(n)


	-> Steps:
		a. Create an unordered_map: m

		b. Do following for every Node "curr" in the given list
			m[curr] = new Node(curr->data);

		c. Traverse the given list again and do following for every Node "curr"
			m[curr]->next = m[curr->next];
			m[curr]->random = m[curr->random];

		d. return m[h1]



	-> C++ Implementation

		Node* clone(Node* h1)
		{
			unordered_map<Node*, Node*> m;

			for(Node* curr = h1; curr != NULL; curr = curr->next)
			{
				m[curr] = new Node(curr->data);
			}

			for(Node* curr = h1; curr != NULL; curr = curr->next)
			{
				m[curr]->next = m[curr->next];
				m[curr]->random = m[curr->random];
			}

			return m[h1];
		}






2. Method-2

	-> Time Complexity:		O(n)
	-> Space Complexity:	O(1)


	-> Hint: We will temporarily modify the original List, then after cloning we will restore the 
				original list.


	-> Steps:
		a. Create clone Nodes and Insert in the given list at alternate positions.

		b. Connect the clone Nodes.

		c. Separate the original and clone Nodes.



	-> C++ Implementation

		Node* clone(Node* h1)
		{
			// Step-1: Insert clone Nodes alternatively
			Node* curr = h1;
			while(curr != Null)
			{
				Node* next = curr->next;
				curr->next = new Node(curr->data);
				curr->next->next = next;
				curr = next;
			}


			// Step-2: Connect clone Nodes with Random
			for(Node* curr = h1; curr != NULL; curr = curr->next->next)
			{
				if(curr->random == NULL)
				{
					curr->next->random = NULL;
				}
				else
				{
					curr->next->random = curr->random->next;
				}
			}


			// Step-3: Separate original and clone Nodes
			Node* h2 = h1->next;
			Node* clone = h2;
			for(Node* curr = h1; curr != NULL; curr = curr->next)
			{
				curr->next = curr->next->next;
				// clone->next = clone->next ? clone->next->next : NULL;
				if(clone->next != NULL)
				{
					clone->next = clone->next->next;
				}
				else
				{
					clone->next = NULL; 
				}
				clone = clone->next;
			}


			return h2;
		}



































LRU Cache Design
---------------------------------------------------------------------

-> LRU: Least Recently Used

-> Popular Interview Question


-> LRU used the concept of "Temporal Locality"
	-> The concept is, the item which is access now is very likely to be
		accessed in near future. 

	-> In LRU, we keep the recently accessed item in the cache and we remove 
		the least recent items when we need space in the small size memory.


-> In Cache memory
	1. If something is not there in the "cache", we call it a "Miss"

	2. If we are accessing something, which is already there in the cache
		we call it a "hit"




1. Simple Implementation of LRU design using Array

	-> If "n" is the capacity of "cache"
		a. Time Complexity - Hit: 	O(n)
		b. Time Complexity - Miss: 	O(n)



2. Efficient Implementation

	-> We will use a combined data structure of HashMap and Doubly Linked List
		a. Hashing 				-   For quick search and insert
		b. Doubly Linked List 	-   To maintain the "recency" order



	-> Psuedo Code

		Refer(x)
		{
			Look for x in HashTable

				a. If found (Hit), find the reference of the node in Doubly Linked List.
				   Move the node to the front of Doubly Linked List.

				b. If Not Found (Miss)
					i)  Insert a new node at the front of Doubly Linked List.
					ii) Insert an entry into the HashTable
		}



	-> If "n" is the capacity of "cache"
		a. Time Complexity - Hit: 	O(1)
		b. Time Complexity - Miss: 	O(1)
































Merge two sorted Linked Lists
------------------------------------------------------------------------

1. C++ Implementation

	Node* sortedMerge(Node* a, Node* b)
	{
		if(a == NULL)
			return b;

		if(b == NULL)
			return a;


		Node* head = NULL;
		Node* tail = NULL;

		if(a->data <= b->data)
		{
			head = tail = a;
			a = a->next;
		}
		else
		{
			head = tail = b;
			b = b->next;
		}

		while(a != NULL && b != NULL)
		{
			if(a->data <= b->data)
			{
				tail->next = a;
				tail = a;
				a = a->next;
			}
			else
			{
				tail->next = b;
				tail = b;
				b = b->next;
			}
		}

		if(a == NULL)
		{
			tail->next = b;
		}
		else
		{
			tail->next = a;
		}


		return head;
	}


	Time Complexity:	O(m+n)
	Space Complexity:	O(1)






























Palindrome Linked List
------------------------------------------------------------------

1. Naive Solution: Using Stack data structure

	
	-> C++ Implementation

		bool isPalindrome(Node*head)
		{
			stack<char> st;

			for(Node* curr = head; curr != NULL; curr = curr->next)
			{
				st.push(curr->data);
			}

			for(Node* curr = head; curr != NULL; curr = curr->next)
			{
				if(st.top() != curr->data)
				{
					return false;	
				}

				st.pop();
			}

			return true;
		}



	-> Java Implementation

		boolean isPalindrome(Node head)
		{
			Deque<character> stack = new ArrayDeque<character>();

			for(Node curr = head; curr != null; curr = curr.next)
			{
				stack.push(curr.data);
			}

			for(Node curr = head; curr != null; curr = curr.next)
			{
				if(stack.pop() != curr.data)
				{
					return false;
				}
			}

			return true;
		}


		Time Complexity:	O(n)
		Space Complexity:	O(n)






2. Efficient Solution
	
	-> Time Complexity:		O(n)
	-> Space Complexity:	O(1)


	-> Steps:
		a. Find the Second Half and Reverse the Linked List after the second half

		b. then one by one compare first half and reversed second half




	-> C++ Implementation

		bool isPalindrome(Node* root)
		{
			if(head == NULL)
			{
				return true;
			}

			// Finding middle of Node
			Node* slow = head;
			Node* fast = head;
			while(fast->next != NULL && fast->next->next != NULL)
			{
				slow = slow->next;
				fast = fast->next->next;
			}

			Node* mid = slow

			Node* rev = reverseList(mid->next);

			Node* curr = head;
			while(rev != NULL)
			{
				if(rev->data != curr->data)
				{
					return false;
				}

				rev = rev->next;
				curr = curr->next;
			}

			return true;
		}



	-> Note:
		Our implementation modifies the Original Linked List, however if we want original Linked List 
		we can again reverse linked list after the middle Node. 






























































































































































#########################################################
12. Stack
#########################################################


Stack Data Structure
-----------------------------------------------------------------

-> Important Points
	1. Insertion operation on a Stack is called "push"
	2. Removal operation on a Stack is called "pop"



-> Stack Operations
	
	1. isEmpty()
		-> Returns true if stack is empty, else false.

	2. push(x)
		-> Inserts an item to the top of the stack

	3. pop()
		-> Removes an item from the top 

	4. peek()
		-> Returns the top item

	5. size()
		-> Returns the size of stack



-> Stack Corner conditions

	1. Underflow
		-> When pop() or peek() called on empty stack

	2. Overflow
		-> When push() called on a full stack

































Array Implementation of Stack in C++
--------------------------------------------------------------------------

1. Using Struct (Array based Implementation)

	struct MyStack
	{
		int* arr;
		int cap;
		int top;

		MyStack(int c)
		{
			cap = c;
			arr = new int[cap];
			top = -1;	
		}

		void push(int x)
		{
			top++;
			arr[top] = x;
		}

		int pop()
		{
			int res = arr[top];
			top--;
			return res;
		}

		int peek()
		{
			return arr[top];
		}

		int size()
		{
			return (top+1);
		}

		bool isEmpty()
		{
			return (top == -1);
		}

	};		// end of structure MyStack	




	-> Problem with our implementation

		1. Does not handle "overflow" and "underflow"

		2. We need to provide capacity initilly. No dynamic resizing




2. Dynamic implementation of Stack data Sturcture (Using stl vector)

	struct MyStack
	{
		vector<int> v;

		void push(x)
		{
			v.push_back(x);
		}

		int pop()
		{
			int res = v.back();
			v.pop_back();
			return res;
		}

		int size()
		{
			return v.size();
		}

		bool isEmpty()
		{
			return v.empty();
		}

		int peek()
		{
			return v.back();
		}

	};	// end of Structure

































Array Implementation of Stack in Java
-----------------------------------------------------------------------------------

1. Fixed Size Implementation

	class MyStack
	{
		int arr[];
		int cap;
		int top;

		MyStack(int c)
		{
			top = -1;
			cap = c;
			arr = new int[cap];
		}

		void push(int x)
		{
			top++;
			arr[top] = x;
		}

		int pop()
		{
			int res = arr[top];
			top--;
			return res;
		}

		int size()
		{
			return top+1;
		}

		boolean isEmpty()
		{
			return (top == 1);
		}

	}


	Worst Case Time Complexity:	O(1)




2. Dynamic size Implementation

	class MyStack
	{
		ArrayList<Integer> al = new ArrayList<Integer>();

		void push(int x)
		{
			al.add(x);
		}

		int pop()
		{
			int res = al.get(al.size() - 1);
			al.remove(al.size() - 1);
			return res;
		}

		int peek()
		{
			return al.get(al.size() - 1);
		}

		bool isEmpty()
		{
			return al.isEmpty();
		}

		int size()
		{
			return al.size();
		}
	}


	Amortized Time Complexity: O(1)	


































Linked List Implementation of Stack in C++
--------------------------------------------------------------------------

1. Linked List implementation

	struct Node
	{
		int data;
		Node* next;

		Node(int d)
		{
			data = d;
			next = NULL;
		}
	};

	struct MyStack
	{
		Node* head;
		int sz;

		MyStack()
		{
			head = NULL;
			sz = 0;
		}

		void push(int x)
		{
			Node* temp = new Node(x);
			temp->next = head;
			head = temp;
			sz++;
		}

		int pop()
		{
			if(head == NULL)
			{
				return INT_MAX;
			}

			int res = head->data;
			Node* temp = head;			// required in C++ only
			head = head->next;
			delete temp;				// requird in C++ only
			sz--;

			return res;
		}

		int size()
		{
			return sz;
		}

		bool isEmpty()
		{
			return (head == NULL);
		}

		int peek()
		{
			if(head == NULL)
			{
				return INT_MAX;
			}

			return head->data;
		}

	};	// end of structure


	Time Complexity:	O(1)




































Linked List Implementation of Stack in Java
----------------------------------------------------------------------------------

1. Stack implementation using Linked List

	class Node
	{
		int data;
		Node next; 

		Node(int data)
		{
			this.data = data;
			next = null;
		}
	}


	class MyStack
	{
		Node head;
		int sz;

		MyStack()
		{
			head = null;
			sz = 0;
		}

		int size()
		{
			return sz;
		}

		boolean isEmpty()
		{
			return (head == null);
		}

		void push(int x)
		{
			Node temp = new Node(x);
			temp.next = head;
			head = temp;
			sz++;
		}

		int pop()
		{
			if(head == null)
			{
				return Math.Integer.MAX_VALUE;
			}

			int res = head.data;
			head = head.next;
			sz--;

			return res;
		}

		int peek()
		{
			if(head == null)
			{
				return Math.Integer.MAX_VALUE;
			}

			return head.data;
		}
	}


	Time Complexity:	O(1)




































Stack Applications
---------------------------------------------------------------------

-> Stack Application
	1. Function Calls
		-> Most of the programming languages use "Stack" to implement 
			Function call

	2. Checking for Balanced Paranthesis

	3. Reversing Items

	4. Infix to Prefix/Postfix

	5. Evaluation of Postfix/Prefix

	6. Stock span problem and its variations
		-> Popular Interview Question
		-> Most Important Interview Question on Stack data structure

	7. Undo/Redo OR Forward/Backward





































Stack in C++ STL
-----------------------------------------------------------------

-> Declaration of stack in stl

	1. #include <stack>
	2. stack<int> s;			// can be any data type



-> Important functions in stl "stack"

	1. void push()

	2. "T" pop()

	3. "T" top()

	4. int size()

	5. bool empty()

	Note: All the functions above have time complexity as O(1)




-> Example

	#include <iostream>
	#include <stack>

	using namespace std;

	int main()
	{
		stack<int> s;
		s.push(10);
		s.push(20);
		s.push(30);
		cout<<s.size()<<endl;		// o/p: 3
		cout<<s.top()<<endl;		// o/p: 30

		s.pop();
		cout<<s.top()<<endl;		// o/p: 20

		return 0;
	}





-> Stack can be implemented on any of underlying contained that provides 
	following operations
		1. back()
		2. size()
		3. empty()
		4. push_back()
		5. pop_back()

	-> list, vector and deque, all provides the above mentioned functionalities,
		so "stack" can be implemented using any of these three containers.

	-> By default, stl "stack" is implemented using deque container

	-> Since, "stack" is implemented using other containers and work as an "interface", 
		It is also called "Container Adapter".

	-> Some other examples of "Container Adapters" are "queue" and "priority queue"



































Stack in Java Collections
----------------------------------------------------------------------------

-> In Java Collections, Stack is supported using two classes

	1. ArrayDeque Class
		-> ArrayDeque class implements Deque Interface
		-> Deque Interface is a child interface of Queue Interface
		-> Queue Interface is a child interface of Collection Interface

	2. Stack Class
		-> Stack class extends the Vector Interface
		-> Vector class implents the List Interface
		-> List Interface is a child interface of Collection Interface



Q. Which one among "Stack" and "ArrayDeque" should be used for stack data structure.
	
	-> ArrayDeque should be used, especially in a Single Threaded environment

	-> Because, Stack class inherits from Vector class which is a "thread safe class", 
		also, the Vector class is a legacy class i.e., it was there before Collection Framework.



-> Example

	class Test
	{
		public static void main(String args[])
		{
			// Stack<Integer> stack = new Stack<>();
			ArrayDeque<Integer> st = new ArrayDeque<>();
			st.push(10);
			st.push(20);
			st.push(30);
			System.out.println(st.peek());		// o/p: 30
			System.out.println(st.pop());		// o/p: 30
			System.out.println(st.peek());		// o/p: 20
			System.out.println(st.isEmpty());	// o/p: false
		}
	}



-> Note
	In Java, both implementations of stack i.e., Vector and ArrayDeque implementations,
	they both are Array Implementations




































Balanced Parenthesis
------------------------------------------------------------------------------

1. My Solution

	bool isBalanced(string &str)
	{
	    stack<char> st;
	    
	    for(char c: str)
	    {
	        if(c == '(' || c == '{' || c == '[')
	        {
	            st.push(c);
	        }
	        else
	        {
	            if(st.empty())
	            {
	                return false;
	            }
	            
	            if(c == ')')
	            {
	                if(st.top() == '(')
	                {
	                    st.pop();
	                }
	                else
	                {
	                    return false;
	                }
	            }
	            else if(c == '}')
	            {
	                if(st.top() == '{')
	                {
	                    st.pop();
	                }
	                else
	                {
	                    return false;
	                }
	            }
	            else if(c == ']')
	            {
	                if(st.top() == '[')
	                {
	                    st.pop();
	                }
	                else
	                {
	                    return false;
	                }
	            }
	        }
	    }
	    
	    if(st.empty())
	    {
	        return true;
	    }
	    
	    return false;
	}	



2. C++ Implementation

	// Utility function
	bool matching(char a, char b)
	{
		return ( (a == '(' && b == ')') || (a == '{' && b == '}') || (a == '[' && b == ']') );
	}


	bool isBalanced(string &str)
	{
		stack<char> s;				// Java: Deque<character> s = new ArrayDeque<>();

		for(char x: str)			// Java: we can't use for each loop with strings
		{
			if(x == '(' || x == '{' || x == '[')
			{
				s.push(x);
			}
			else
			{
				if(s.empty())
				{
					return false;
				}
				else if(matching(s.top(), x) == false)
				{
					return false;
				}
				else
				{
					s.pop();
				}
			}
		}

		return (s.empty() == true);
	}


	Time Complexity:	O(n)
	Space Complexity:	O(n)





































Implement two Stacks in an Array
----------------------------------------------------------------------------------

1. Naive Solution

	-> Idea/Approach for the solution
		1. We divide the array from middle, use the First Half for stack 1 and 
			Second Half for stack 2

		2. Inefficient use of Space
			-> If we fill all the indexes in the first half and no fill in second half,
				then we can not any more items to stack 1 even if we have space in 
				the array.




2. Efficient Solution

	-> Idea for the efficient solution
		1. Begin both stacks from the two corners/ends of the Array.

		2. Now we can insert items in any stack as long as we have space.


	-> Java Implementation

		class TwoStacks
		{
			int arr[];						// C++: int* arr;
			int cap;
			int top1;
			int top2;

			TwoStack(int n)
			{
				cap = n;
				top1 = -1;
				top2 = n;
				arr = new int[n];
			}

			boolean push1(int x)
			{
				if(top1 < top2-1)
				{
					top1++;
					arr[top1] = x;
					return true;
				}

				return false;
			}

			boolean push2(int x)
			{
				if(top1+1 < top2)
				{
					top2--;
					arr[top2] = x;
					return true;
				}

				return false;
			}

			Integer pop1()
			{
				if(top1 >= 0)
				{
					int x = arr[top1];
					top1--;
					return x;
				}

				return null;
			}

			Integer pop2()
			{
				if(top2 < cap)
				{
					int x = arr[top2];
					top2++;
					return x;
				}

				return null;
			}

			int size1()
			{
				return (top1 + 1);
			}

			int size2()
			{
				return (cap - top2);
			}
		}



	-> C++ Implementation

		#include <bits/stdc++.h>
		using namespace std;

		struct TwoStacks { 
		    int* arr; 
		    int cap; 
		    int top1, top2; 
		    
		    TwoStacks(int n)  
		    { 
		        cap = n; 
		        arr = new int[n]; 
		        top1 = -1; 
		        top2 = cap; 
		    } 
		  
		    void push1(int x) 
		    { 
		        if (top1 < top2 - 1) { 
		            top1++; 
		            arr[top1] = x; 
		        } 
		        else { 
		            cout << "Stack Overflow"; 
		            exit(1); 
		        } 
		    } 
		  
		    void push2(int x) 
		    { 
		        if (top1 < top2 - 1) { 
		            top2--; 
		            arr[top2] = x; 
		        } 
		        else { 
		            cout << "Stack Overflow"; 
		            exit(1); 
		        } 
		    } 
		  
		    int pop1() 
		    { 
		        if (top1 >= 0) { 
		            int x = arr[top1]; 
		            top1--; 
		            return x; 
		        } 
		        else { 
		            cout << "Stack UnderFlow"; 
		            exit(1); 
		        } 
		    } 
		  
		    int pop2() 
		    { 
		        if (top2 < cap) { 
		            int x = arr[top2]; 
		            top2++; 
		            return x; 
		        } 
		        else { 
		            cout << "Stack UnderFlow"; 
		            exit(1); 
		        } 
		    } 
		};






































Implement K Stacks in an Array in C++
----------------------------------------------------------------------------
#Repeat
#Revise

1. Naive Solution
	
	-> Divide the given array in "K" equal parts



2. Efficient Solution
	
	struct KStacks
	{
		int* arr;
		int* top;
		int* next;

		int k;
		int free_top;
		int cap;

		// Constructor
		KStacks(int k, int cap)
		{
			this.k = k;
			this.cap = cap;

			free_top = 0;

			arr = new int[cap];
			top = new int[k];
			next = new int[cap];   

			fill(top, top+k, -1);			// Initialize all the indexes of top[] = -1

			for(int i=0; i < cap-1; i++)
			{
				next[i] = i+1;
			}

			next[cap - 1] = -1;
		}


		void push(int stackNumber, int x)
		{
			int i = free_top;
			free_top = next[i];
			next[i] = top[stackNumber];
			top[stackNumber] = i;
			arr[i] = x;
		}


		int pop(int stackNumber)
		{
			int i = top[stackNumber];
			top[stackNumber] = next[i];
			next[i] = free_top;
			free_top = i;
			return arr[i];
		}

	};	// End of structure



































Previous Greater Element
------------------------------------------------------------------------------------

-> Problem Statement:
	Given an "array of distinct integer", find closest (position wise) greater on left of 
	every element. If there is no greater element on left, then print -1



1. My Solution

	void previousGreaterElement(int* arr, int n)
	{
	    stack<int> st;
	    
	    for(int i=0; i<n; i++)
	    {
	        while((!st.empty()) && (st.top() < arr[i]))
	        {
	            st.pop();
	        }
	        
	        if(st.empty())
	        {
	            cout<<-1<<" ";
	            st.push(arr[i]);
	        }
	        else
	        {
	            cout<<st.top()<<" ";
	            st.push(arr[i]);
	        }
	    }
	}




2. Naive Solution

	void printPrevGreater(int arr[], int n)
	{
		for(int i=0; i<n; i++)
		{
			int j;

			for(j = i-1; j >= 0; j--)
			{
				if(arr[j] > arr[i])
				{
					cout<<arr[j]<<" ";
					break;
				}
			}

			if(j == -1)
			{
				cout<<-1<<" ";
			}
		}
	}


	Time Complexity:	O(n^2)





3. Efficient Solution

	void printPrevGreater(int arr[], int n)
	{
		stack<int> s;
		s.push(arr[0]);
		cout<<-1<<" ";

		for(int i=1; i<n; i++)
		{
			while(s.empty() == false && s.top() <= arr[i])
			{
				s.pop();
			}

			int prevGreat = (s.empty()) ? -1 : s.top();
			cout<<prevGreat<<" ";
			s.push(arr[i]);
		}
	}


	Time Complexity:	O(n)




































Next Greater Element
-----------------------------------------------------------------------

-> Popular Interview Question


-> Problem Statement
	Given an array of integers, find Next Greater (position-wise closest and on right side)
	for every array element.



1. My Solution

	void nextGreaterElement(int arr[], int n)
	{
	    stack<int> st;
	    list<int> v;
	    
	    for(int i=n-1; i>=0; i--)
	    {
	        while(!st.empty() && st.top() <= arr[i])
	            st.pop();
	        
	        if(st.empty())
	            v.push_front(-1);
	        else
	            v.push_front(st.top());
	            
	        st.push(arr[i]);
	    }
	    
	    for(int i: v)
	    {
	        cout<<i<<" ";
	    }
	}



2. Naive Solution
	
	void nextGreater(int arr[], int n)
	{
		for(int i=0; i<n; i++)
		{
			int j;

			for(j = i+1; j<n; j++)
			{
				if(arr[j] > arr[i])
				{
					cout<<arr[j]<<" ";
					break;
				}
			}

			if(j == n)
			{
				cout<<-1<<" ";
			}
		}
	}


	Time Complexity:	O(n^2)



3. Efficient Solution

	void nextGreater(int arr[], int n)
	{
		stack<int> s;						// Java: Stack<Integer> s = new Stack<Integer>();
		s.push(arr[n-1]);
		cout<<-1<<" ";

		for(int i = n-2; i >= 0; i--)
		{
			while(s.empty() == false && s.top() <= arr[i])
			{
				s.pop();
			}

			int nextGreater = (s.empty()) ? (-1) : (s.top());
			cout<<nextGreater<<" ";
			s.push(arr[i]);
		}         
	}


	-> Prints the output in reverse order from the required output


	-> Time Complexity: 	O(n)


































Stock span problem
-----------------------------------------------------------------------------

1. Naive Solution

	void printSpan(int arr[], int n)
	{
		for(int i=0; i<n; i++)
		{
			int span = 1;

			for(int j = i-1; j >= 0 && arr[j] <= arr[i]; j--)
			{
				span++;
			}

			cout<<span<<" ";
		}
	}


	Time Complexity:	O(n^2)


	-> Worst Case: when array is sorted in increasing order  




2. Efficient Solution

	-> Span = (Index of current element) - (Index of closest greater element on left side)

	-> Span = (Index of current element) - (Index of previousGreaterElement)

	-> If there is no greater element of left side, then
		Span = Index of current element + 1



	-> C++ Implementation

		void printSpan(int arr[], int n)
		{
			stack<int> st;
			st.push(0);			// first index of the array
			cout<<1<<" ";

			for(int i=1; i<n; i++)
			{
				while(st.empty() == false && arr[st.top()] <= arr[i])
				{
					st.pop();
				}

				span = st.empty() ? i+1 : i-st.top();

				cout<<span<<" ";

				st.push(i);
			}
		}


		Time Complexity:	O(n)
		Space Complexity:	O(n)


		-> This is linear time solution because, every item is pushed into stack only once, 
			and pop() operation takes place at most n times.
			Hence, at most 2n operations will take place on Stack

		-> Push and Pop operations on Stack are of time complexity: O(1)



































Largest Rectangle Area in a Histogram (Part-1)
----------------------------------------------------------------------------------

1. Naive Solution

	int getMaxArea(int arr[], int n)
	{
		int res = 0;

		for(int i=0; i<n; i++)
		{
			int curr = arr[i];

			for(int j = i-1; j >= 0; j--)
			{
				if(arr[j] >= arr[i])
				{
					curr += arr[i];
				}
				else
				{
					break;
				}
			}

			for(int j = i+1; j<n; j++)
			{
				if(arr[j] >= arr[i])
				{
					curr += arr[i];
				}
				else
				{
					break;
				}
			}

			res = max(res, curr);
		}

		return res;
	}


	Time Complexity:	O(n^2)




2. Better Solution - O(n) Time

	-> Requires Three traversals
		a. For populating array of previous smaller element
		b. For populating array of next smaller element
		c. For propressing all the elements of original array.


	-> Steps:	
		a. Initialise: res = 0

		b. Find "Previous Smaller Element" for every element

		c. Find "Next Smaller Element" for every element

		d. Do following for every element arr[i]

			curr = arr[i];

			curr += (i - previousSmaller[i] - 1) * arr[i];

			curr += (nextSmaller[i] - i - 1) * arr[i];

			res = max(res, curr);

		e. return res



	-> C++ Implementation

		int getMaxArea(int arr[],int n)
		{
		    int res=0;
		    int ps[n],ns[n];
		    
		    stack <int> s;
		    s.push(0);
		    for(int i=0;i<n;i++){
		        while(s.empty()==false && arr[s.top()]>=arr[i])
		            s.pop();
		        int pse=s.empty()?-1:s.top();
		        ps[i]=pse;
		        s.push(i);
		    }
		    
		    while(s.empty()==false){
		        s.pop();
		    }
		    
		    s.push(n-1);
		    for(int i=n-1;i>0;i--){
		        while(s.empty()==false && arr[s.top()]>=arr[i])
		            s.pop();
		        int nse=s.empty()?n:s.top();
		        ns[i]=nse;
		        s.push(i);
		    }
		    
		    for(int i=0;i<n;i++){
		        int curr=arr[i];
		        curr+=(i-ps[i]-1)*arr[i];
		        curr+=(ns[i]-i-1)*arr[i];
		        res=max(res,curr);
		    }


		    return res;
		}


		Time Complexity:	O(n)
		Space Complexity:	O(n)





























Largest Rectangular Area in a Histogram (Part-2)
-----------------------------------------------------------------------------------------------
#Repeat
#Revise

1. C++ Implementation (Pseudo code)

	int getMaxArea(int arr[], int n)
	{
		stack<int> st;

		int res = 0;

		for(int i=0; i<n; i++)
		{
			while(!st.empty() && arr[st.top()] > arr[i])
			{
				tp = st.top();
				curr = arr[tp] * (st.empty() ? i : (i - st.top() - 1));
				res = max(res, curr);
			}

			s.push(i);
		}

		while(!s.empty())
		{
			tp = s.pop();
			curr = arr[tp] * (s.empty() ? n : (n - s.top() - 1));
			res = max(res, curr);
		}

		return res;
	}

































Largest Rectangle with all 1's
-------------------------------------------------------------------------------------------

-> Given binary Matrix, we have to find largest Rectangular sub-matrix(consisting of all 1's) into it.


1. Naive/SuperNaive Solution

	-> Steps:
		a. Consider every Cell as a starting point

		b. Consider all sizes of rectangles with current Cell as a starting point

		c. For the current rectangle, check if it has all 1's. If yes, then update 
			the "res" if the current size is more


	-> Time Complexity: O(R^3 * C^3)





2. Efficient Solution

	-> This solution is based on "Largest Rectangular Area in a Histogram"

	-> Time Complexity: O(R * C)


	-> Steps:

		Run a loop from 0 to R-1
			1. Update the histogram for the curren Row
			2. Find the largest area in the histogram and update the result if required



	-> C++ Implementation (Pseudo Code)

		int getMaxArea(int arr[],int n)
		{
		    stack <int> s;
		    int res=0;
		    int tp;
		    int curr;
		    
		    for(int i=0;i<n;i++){
		        while(s.empty()==false && arr[s.top()]>=arr[i]){
		            tp=s.top();s.pop();
		            curr=arr[tp]* (s.empty() ? i : i - s.top() - 1);
		            res=max(res,curr);
		        }
		        s.push(i);
		    }
		    while(s.empty()==false){
		        tp=s.top();s.pop();
		        curr=arr[tp]* (s.empty() ? n : n - s.top() - 1);
		        res=max(res,curr);
		    }
		    
		    return res;
		    
		}


		int maxRectangle(int mat[R][C])
		{
			int res = getMaxArea(mat[0], C);

			for(int i=1; i<R; i++)
			{
				for(int j=0; j<C; j++)
				{
					if(mat[i][j] == 1)
					{
						mat[i][j] += mat[i-1][j];
					}
				}

				res = max(res, getMaxArea(mat[i], C));
			}

			return res;
		}


		Space Complexity:	O(C)



































Stack with getMin() in O(1) time
-----------------------------------------------------------------------

-> Design a Stack that supports getMin() in O(1)


-> Idea:
	a. We can have one extra stack "Auxiliary Stack (as)" along with "Main Stack (ms)"

	b. push(x)

			ms.push(x);
			if(ms.top() <= as.top())
			{
				as.push(x);
			}

	c. pop()

			if(ms.top() == as.top())
			{
				as.pop();
			}
			ms.pop();



	-> Space Complexity:	O(n)




1. C++ Implementation

	struct MyStack 
	{
	    stack<int> ms;
	    stack<int> as;
	 
		void push(int x) 
		{
		 
	      if(ms.empty()) 
	      {
	          ms.push(x);as.push(x);return;
	      }
	      
	      ms.push(x);
	      
	      if(as.top()>=ms.top())
	        as.push(x);
	    }
		 
		void pop() 
		{
		 
		    if(as.top()==ms.top())
		        as.pop();
		    ms.pop();
		    
		}

		int top() 
		{
	     	return ms.top();
		}
		 
		int getMin() 
		{
	      	return as.top();
	    }
	};



































Design a Stack with getMin() in O(1) time And O(1) Space
------------------------------------------------------------------------------------

1. First Method (Assuming all elements positive)

	-> Works only for +ve numbers.

		Stack s;

		int min;

		void push(int x)
		{
			if(s.empty())
			{
				min = x;
				s.push(x);
			}
			else if(x <= min)
			{
				s.push(x - min);
				min = x;
			}
			else
			{
				s.push(x);
			}
		}

		int pop()
		{
			int t = s.pop();

			if(t <= 0)
			{
				res = min;
				min = min - t;
				return res;
			}
			else
			{
				return t;
			}
		}

		int getMin()
		{
			return min;
		}

		int peek()
		{
			int t = s.peek();
			return (t <= 0) ? (min) : (t);
		}




2. Second Method(Handles Negative Numbers also)

	Stack s;
	int min;

	void push(int x)
	{
		if(s.empty())
		{
			s.push(x);
			min = x;
		}
		else if(x <= min)
		{
			s.push(2*x - min);
			min = x;
		}
		else
		{
			s.push(x);
		}
	}


	int pop()
	{
		int t = s.top();

		if(t <= min)
		{	
			int res = min;
			min = 2*min - t;
			return res;
		}
		else
		{
			return t;
		}
	}

	int getMin()
	{
		return min;
	}

	int peek()
	{
		int t = s.peek();
		return (t < min) ? (min) : (t);
	}



-> Note 1: Working?
	We push "2*x - min" only when "x <= min", So "2*x - min" is always going to 
	be less than or equal to x.
	And x is going to be our new min.


-> Note 2: 
	t = 2*currMin - prevMin
	prevMin = 2*currMin - t;





































Infix, Prefix and Postfix Introduction
-------------------------------------------------------------------------------

-> Advantages of Prefix and Postfix

	1. Do not require parenthesis, precedence rules and associativity rules.

	2. Can be evaluated by writing a program that traverses the given expression exactly once.


-> Example 1

	1. Infix: 		x + y
	2. Postfix:		xy+
	2. Prefix: 		+xy



-> Example 2

	1. Infix: 		x + y * z
	2. Prefix:		+x*yz
	3. Postfix:		xyz*+


-> Example 3

	1. Infix:		(x + y) * z
	2. Prefix:		*+xyz
	3. Postfix:		xy+z*


























Infix to Postfix (Efficient Solution)
----------------------------------------------------------------------------

-> Stack based Algorithm for Infix to Postfix conversion


-> Steps
	
	1. Create an empty stack, st

	2. Traverse i/p from left to right, and do the following for every character 'x'

		if(x is operand)
			cout<<x

		if(x is left parenthesis)
			st.push(x)

		if(x is right parenthesis)
			while(st.top() != '(')
				cout<<st.pop;

		if(x is operator)
		{
			if(st.empty())
				st.push(x);
			else
			{
				if(precedence(x) > precedence(st.top()))
				{
					st.push(x);
				}
				else if(precedence(x) < precedence(st.top()))
				{
					while(precedence(st.top()) < precedence(x))
					{
						cout<<st.pop();
					}

					st.push(x);
				}
				else if(precedence(x) == precedence(st.top()))
				{
					-> Use Associativity
				}
			}
		}


	3. Pop and output evertything from stack, st.



-> Time Complexity:	O(n)		// n is the length of i/p string or expression



































Evaluation of Postfix
-----------------------------------------------------------------------------------

-> Algorithm for evaluation of Postfix

	1. Create an empty stack, st.

	2. Traverse through every symbol 'x' of given postfix expression

		a. If 'x' is an operand, push to stack.

		b. Else if(x is an operator)

			-> op1 = st.pop()

			-> op2 = st.pop()

			-> Compute op2 'x' op1 and push the result to stack

	3. Return st.top()







































Infix to Prefix (Simple Solution)
-------------------------------------------------------------------------------

-> Operators with same precedence always have the same Associativity


















Infix to Prefix (Efficient Solution)
-------------------------------------------------------------------------------

-> Algorithm for Infix to Prefix using Stack

	1. Create an empty stack, st.

	2. Create an empty string, prefix.

	3. "Traverse from Right to Left" and do the following for every character 'c'

	4. If 'c' is

		a. Operand: Push it to prefix

		b. Right Parenthesis: Push to st

		c. Left Parenthesis: Pop from st, until right parenthesis is found. Append the 
							 popped characters to prefix.

		d. Operator: If st is empty, push 'c' to st.

					 Else, compare with st top.

					 	i)   Higher Precedence(than st top):	Push 'c' to st.

					 	ii)  Lower Precedence: Pop st top and append the popped item to prefix until a higher precedence 
					 		  				   operator is found(Or, st becomes empty).
					 		  				   Push 'c' to st.

					 	iii) Equal Precedence: Use Associativity


	5. Pop peverything from st and append to prefix.

	6. Return reverse of prefix.






























Evaluation of Prefix
-----------------------------------------------------------------

-> Evaluation is similar to Postfix evaluation using Stack, only difference is 
	we will be traversing from Right to Left for evaluation.































































































































































#########################################################
13. Queue
#########################################################



Queue Data Structure
-------------------------------------------------------------------------------

-> FIFO : First In First Out


-> Operations
	1. enqueue(x)

	2. dequeue()

	3. getFront()

	4. getRear()

	5. size()

	6. isEmpty()


































Application of Queue Data Structure
-----------------------------------------------------------------------------------

-> Applications

	1. Single Resource and Multiple Consumers

	2. Synchronization between slow and fast devices

	3. In Operating Systems (Semaphores, FCFS Scheduling, Spooling, buffers for devices like keyboard)

	4. In Computer Network (Routers/Switches and Mail Queues)

	5. Variations: Deque, Priority Queue and Doubly Ended Priority Queue



-> FCFS: First Come First Serve

-> Spooling is used in Printers


-> Deque 
	a. Doubly Ended Queue

	b. Using "Deque", we can implement "Stack" and "Queue" both data structures.


-> Priority Queue
	a. Queue with priority

	b. Implemented using "Heap data structure"




































Implementation of Queue Data Structure
----------------------------------------------------------------------------

1. C++ Implementation (Simple Implementation)

	-> Time Complexity(Enque): 		O(1)
	-> Time Complexity(Dequeue):	O(n)

	struct Queue
	{
		int size;
		int cap;
		int* arr;

		Queue(int c)
		{
			cap = c;
			size = 0;
			arr = new int[cap];
		}

		bool isFull()
		{
			return (size == cap);
		}

		bool isEmpty()
		{
			return (size == 0);
		}

		void enque(x)
		{
			if(isFull())
				return;

			arr[size] = x;
			size++;
		}

		void deque()
		{
			if(isEmpty())
				return;

			for(int i=0; i < size-1; i++)
			{
				arr[i] = arr[i+1];
			}

			size--;
		}

		// returns the index of "front"
		int getFront()
		{
			if(isEmpty())
			{
				return -1;
			}

			return 0;
		}

		// returns the index of "rear"
		int getRear()
		{
			if(isEmpty())
			{
				return -1;
			}

			return size-1;
		}
	}





2. C++ Implementation (Efficient Implementation)

	-> We can improve time complexity of dequeue operation by using 
		"Circular Array"

	-> Time Complexity(Dequeue): O(1)

	-> deque():
		front = (front + 1) % cap;
		size--;

	-> enque(x):
		rear = (front + size -1) % cap;
		rear = (rear + 1) % cap;
		arr[rear] = x;
		size++;


	struct Queue
	{
		int size;
		int cap;
		int front;
		int* arr;

		Queue(int c)
		{
			cap = c;
			size = 0;
			front = 0;
			arr = new int[cap];
		}

		bool isFull()
		{
			return (size == cap);
		}

		bool isEmpty()
		{
			return (size == 0);
		}

		int getRear()
		{
			if(isEmpty())
			{
				return -1;
			}
			else
			{
				return (front + size - 1) % cap;
			}
		}

		void enque(int x)
		{
			if(isFull())
			{
				return;
			}

			int rear = getRear();

			rear = (rear + 1) % cap;

			arr[rear] = x;

			size++;
		}

		void deque()
		{
			if(isEmpty())
			{
				return;
			}

			front = (front + 1) % cap;

			size--;
		}
		
	}

































Implementation of Queue using Linked List
-----------------------------------------------------------------------------------

1. C++ Implementation

	struct Node
	{
		int data;
		Node* next;

		Node(int x)
		{
			data = x;
			next = NULL;
		}
	};


	struct Queue
	{
		Node* front;
		Node* rear;
		int size;

		Queue()
		{
			front = NULL;
			rear = NULL;
			size = 0;
		}


		void enque(int x)
		{
			Node *temp = new Node(x);
			size++;

			if(rear == NULL)			// if(front == NULL)
			{
				front = rear = temp;
			}
			else
			{
				rear->next = temp;
				rear = temp;
			}
		}


		void deque()
		{
			if (front == NULL)
			{
				return;
			}

			Node* temp = front;
			front = front->next;

			if(front == NULL)
			{
				rear = NULL;		// Corner Case: When there is only one Node/item remaining in the Queue
			}

			delete (temp);
			size--;
		}

		int getSize()
		{
			return size;
		}
	};




































Queue in C++ STL
-----------------------------------------------------------------------------------

-> Important Functions available in stl queue

	1. push()
	2. pop()
	3. front()
	4. back()
	5. empty()
	6. size()



-> Example Program

	#include <iostream>
	#include <queue>
	using namespace std;

	int main()
	{
		queue<int> q;
		q.push(10);
		q.push(20);
		q.push(30);
		cout<<q.front()<<" "<<q.back()<<endl;		// o/p: 10 30

		q.pop();
		cout<<q.front()<<" "<<q.back()<<endl;		// o/p: 20 30

		return 0;
	}




-> Queue can be implemented on any underlying container that provides the following functions.
		a. empty()
		b. size()
		c. front()
		d. back()
		e. push_back()
		f. push_front()

	-> list and dequeue are the two containers which provides all the above functions
	   in O(1) time complexity.

	-> Please note the vector container is not suitable here, because vector does not
	   provide push_front() in O(1) time.

	-> By default, queue is implemented using "deque" container

	-> "queue" is a container adapter



































Queue in Java
-------------------------------------------------------------------------------------

-> Queue is an Interface in Java, which is implemented by following classes
	
	1. LinkedList
		-> It's a doubly linked list implementation

	2. ArrayDeque
		-> Array implementation of Queue


-> Queue Interface inherits from Collection Interface



-> Example Programme

	class Test
	{
		public static void main(String args[])
		{
			// Queue<Integer> q = new LinkedList<Integer>();

			Queue<Integer> q = new ArrayDeque<Integer>();

			q.offers(10);		// Adds an item to "last" of the queue
			q.offers(20);
			q.offers(30);

			System.out.println(q.size());		// o/p: 3

			System.out.println(q.isEmpty());	// o/p: false

			System.out.println(q);				// o/p: [10, 20, 30]

			System.out.println(q.peek());		// o/p: 10

			System.out.println(q.poll());		// o/p: 10

			System.out.println(q.peek());		// o/p: 20
		}
	}



-> Important Methods in Queue

	1. q.offers(data)
		-> Adds an item to "last" of the Queue

	2. q.peek()
		-> It gives the next item which will be removed from the Queue, i.e., the "first" item of the Queue

	3. q.poll()
		-> Removes the "first" item and returns it



-> Functions/Methods that Do not Throw Exceptions
	1. peek()
	2. offer()
	3. poll()


-> Counterpart to above Functions/Methods that Throw Exceptions
	1. element()
	2. add()
	3. remove()





































Implementing Stack using Queue
-------------------------------------------------------------------------------------

-> C++ Implementation

	struct Stack
	{
		queue<int> q1;
		queue<int> q2;	// Auxiliary queue to perform "push" operation on the Stack

		int top()
		{
			return q1.fron();
		}

		int size()
		{
			return q1.size();
		}

		int pop()
		{
			int ans = q1.front();
			q1.pop();
			return ans;
		}

		void push(int x)
		{
			while(q1.empty() == false)
			{
				q2.push(q1.front());
				q1.pop();
			}

			q1.push(x);

			while(q2.empty() == false)
			{
				q1.push(q2.front());
				q2.pop();
			}
		}
	}




-> Other Variations of this Problem

	1. Implement Stack using Queue by making pop operation costly

	2. Implement Stack using only one Queue.
		-> Hint: Use recursion call stack

	3. Implement Queue using Stack
		a. by making enque() operation costly
		b. by making deque() operation costly
		c. by using one stack (And one recursion call Stack)






































Reversing a Queue
-----------------------------------------------------------------------------------------

1. Iterative Solution

	void reverseQueue(queue<int> &q)		// &q - to prevent copying of queue 
	{
		stack<int> s;

		while(!q.empty())
		{
			s.push(q.front());
			q.pop();
		}

		while(!s.empty())
		{
			q.push(s.top());
			s.pop();
		}
	}




2. Recursive Solution

	-> Internally we use Function call Stack in this solution

	void reverseQueue(queue<int> q)
	{
		if(q.empty())
		{
			return;
		}

		int x = q.front();
		q.pop();
		reverseQueue(q);
		q.push(x);
	}

































Generate numbers with given digits
--------------------------------------------------------------------------------

-> Problem Statement:
	Given a number "n", print "first n numbers" (in increasing/sorted order) such that all 
	these numbers have digits in set {5, 6}


	-> Examples:

		i/p: n = 10
		o/p: 5, 6, 55, 56, 65, 66, 555, 556, 565, 566

		i/p: n = 4
		o/p: 5, 6, 55, 56  

	-> Note:
		"n" can be a big number and the result values might not fit in basic data types
		like "long int" or "long long int"




-> C++ Implementation 

	void printFirstN(int n)
	{
		queue<string> q;			// Java: Queue<String> q = new LinkedList<String>();

		q.push("5");
		q.push("6");

		for(int count=0; count<n; count++)
		{
			string curr = q.front();
			cout<<curr<<" ";
			q.pop();
			q.push(curr + "5");
			q.push(curr + "6");
		}
	}































































































































































#########################################################
14. Deque
#########################################################


Deque Data Structure
------------------------------------------------------------------------------

-> Deque: Doubly Ended Queue
	We can do Insertion and Deletion at both ends


-> Operations on Deque
	1. insertFront()
	2. insertRear();
	3. deleteFront();
	4. deleteRear();


-> Some Additional Operations on Deque
	1. getFront()
	2. getRear()
	3. isFull()
	4. isEmpty()
	5. size()




-> Implementation of Deque
	
	1. Linked List
		-> Doubly linked list with front and rear pointers in C++ (references in Java)

	2. Array
		-> Circular array with front and rear indexes. We can also use front and size
			and get rear using size





-> Applications of "Deque" data structure
	
	1. A Deque can be used as both "Stack" and "Queue"

	2. Maintain history of actions
		-> Example: browser history

	3. A Steal Process Scheduling Algorithm
		-> used when there are Multiple processors, and these processors have their 
			own different Queues

	4. Implementing a Priority Queue with two types of priorities

	5. Maximum/Minimum of all subarrays of size k in an array



































Array Implementation of Deque
----------------------------------------------------------------------------

1. Simple Implementation
	
	-> We maintain "front" always at index 0 and "rear" will be at index "size - 1"


	struct Deque
	{
		int size;
		int cap;
		int* arr;

		Deque(int c)
		{
			size = 0;
			cap = c;
			arr = new int[cap];
		}


		isFull()
		{
			return (size == cap);
		}

		bool isEmpty()
		{
			return (size == 0);
		}


		void insertRear(int x)
		{
			if(isFull())
			{
				return;
			}

			arr[size] = x;
			size++;
		}

		void deleteRear()
		{
			if(isEmpty())
			{
				return;
			}

			size--;
		}

		// Returns the index of Rear
		int getRear()
		{
			if(isEmpty())
			{
				return -1;
			}
			else
			{
				return (size-1);
			}
		}

		// O(n) time complexity
		void insertFront(int x)
		{
			if(isFull())
			{
				return;
			}

			for(int i = size; i > 0; i--)
			{
				arr[i] = arr[i-1];
			}

			arr[0] = x;
			size++;
		}


		// O(n) time complexity
		void deleteFront()
		{
			if(isEmpty())
			{
				return;
			}

			for(int i=0; i < size-1; i++)
			{
				arr[i] = arr[i+1];
			}

			size--;
		}

		// Returns index of Front
		int getFront
		{
			if(isEmpty())
			{
				return -1;
			}
			else
			{
				return 0;
			}
		}
	}





2. Efficient Implementation

	a. deleteFront()
		front = (front + 1) % cap;

	b. insertRear(x)
		rear = (rear + 1) % cap;

	c. insertFront(x)
		front = (front - 1 + cap) % cap;

	d. deleteRear()
		rear = (rear - 1 + cap) % cap;

	Note:
		rear is always: rear = (front + size - 1) % cap 



	struct Deque
	{
		int* arr;
		int front;
		int cap;
		int size;

		Deque(int c)
		{
			arr = new int[c];
			cap = c;
			front = 0;
			size = 0;	
		}

		void deleteFront()
		{
			if(isEmpty())
			{
				return;
			}

			front = (front + 1) % cap;

			size--;
		}

		void insertRear(int x)
		{
			if(isFull())
			{
				return;
			}

			int rear = (front + size - 1) % cap;
			int new_rear = (rear + 1) % cap;
			arr[rear] = x;
			size++;
		}

		void insertRearMethod2(int x)
		{
			if(isFull())
			{
				return;
			}

			int new_rear = (front + size) % cap;
			arr[new_rear] = x;
			size++;
		}

		void insertRearMethod3(int x)
		{
			if(isFull())
			{
				return;
			}

			size++;
			int rear = (front + size - 1) % cap;
			arr[rear] = x;
		}

		int getFront()
		{
			if(isEmpty())
			{
				return -1;
			}
			else
			{
				return front;
			}
		}

		void insertFront(int x)
		{
			if(isFull())
			{
				return;
			}

			front = (front - 1 + cap) % cap;
			arr[front] = x;
			size++;
		}

		void deleteRear()
		{
			if(isEmpty())
			{
				return;
			}

			size--;
		}

		int getRear()
		{
			if(isEmpty())
			{
				return -1;
			}
			else
			{
				return (front + size - 1) % cap;
			}
		}
	}






























Deque in C++ STL
---------------------------------------------------------------------------------------
#Revise

-> "deque" provides functionality of both "stack" and "queue"


-> "deque" in C++ STL

	1."deque" in C++ STL is generally implemented in a different way from other languages.

	2. In most of the other languages it's implemeted using Doubly Linked List

	3. But, C++ STL guarantees few extra things, like
		a. Random access
		b. Arbitrary number of insertions in O(1) time




-> Example Programme 1

	#include <iostream>
	#include <deque>
	using namespace std;

	int main()
	{
		deque<int> dq = {10, 20, 30};		// If not initialized, it creates an empty "deque"

		dq.push_front(5);
		dq.push_back(50);

		for(auto x : dq)
		{
			cout<< x << " ";					// o/p: 5, 10, 20, 30, 50
		}

		cout<<dq.front()<<" "<<dq.back();		// o/p: 5, 50

		return 0;
	}




-> Example Programme 2

	#include <iostream>
	#include <deque>
	using namespace std;

	int main()
	{
		deque<int> dq = {10, 15, 30, 5, 12};

		auto it = dq.begin();		// returns an iterator pointing to first element

		it++;

		dq.insert(it, 20);			// dq = {10, 20, 15, 30, 5, 12};

		dq.pop_front();				// dq = {20, 15, 30, 5, 12};

		dq.pop_back();				// dq = {20, 15, 30, 5};

		cout<<dq.size();			// o/p: 4

		return 0;
	}




-> Internal Working of "deque"

	-> Revise from the video tutorial



































Deque in Java
---------------------------------------------------------------------------------------

-> Some important methods in "Deque" interface (which doesn't throw Exception)

	1. dq.offerFirst(x)
		-> adds an element to front 
		-> returns "true" if the item gets successfully added, otherwise returns "false"

	2. dq.offerLast(x)
		-> adds an element to rear
		-> returns "true" if the item gets successfully added, otherwise returns "false"

	3. dq.pollFirst()
		-> deletes an items from front
		-> returns "null" if the "Deque" is empty

	4. dq.pollLast()
		-> deletes an item from end
		-> returns "null" if the "Deque" is empty

	5. dq.peekFirst()
		-> returns the element at front
		-> returns "null" if the "Deque" is empty

	6. dq.peekLast()
		-> returns the element at end
		-> returns "null" if the "Deque" is empty



-> Alternatives to above mentioned methods in "Deque" interface (throws Exception)

	1. dq.addFirst(x)
		-> adds an element to front

	2. dq.addLast(x)
		-> adds an item to the end of deque

	3. dq.removeFirst()
		-> deletes an item from front

	4. dq.removeLast()
		-> deletes an item from end

	5. dq.getFirst()
		-> returns the element at front

	6. dq.getLast()
		-> returns the element at the end






-> Example Programme 1

	#import java.util.*;

	class Test
	{
		public static void main(String args[])
		{
			Deque<Integer> dq = new LinkedList<Integer>();

			dq.offerFirst(10);
			dq.offerLast(20);
			dq.offerFirst(5);
			dq.offerLast(15);

			System.out.println(dq.peekFirst());			// o/p: 5
			System.out.println(dq.peekLast());			// o/p: 15

			dq.pollFirst();
			dq.pollLast();

			System.out.println(dq.peekFirst());			// o/p: 10
			System.out.println(dq.peekLast());			// o/p: 20
		}
	}





-> Example Programme 2

	#import java.util.*;

	class Test
	{
		public static void main(String args[])
		{
			Deque<Integer> dq = new LinkedList<Integer>();

			dq.addFirst(10);
			dq.addLast(20);
			dq.addFirst(5);
			dq.addLast(15);

			System.out.println(dq.getFirst());			// o/p: 5
			System.out.println(dq.getLast());			// o/p: 15

			dq.removeFirst();
			dq.removeLast();

			System.out.println(dq.getFirst());			// o/p: 10
			System.out.println(dq.getLast());			// o/p: 20
		}
	}	





-> Traversing a Deque

	#import java.util.*;

	class Test
	{
		public static void main(String args[])
		{
			Deque<Integer> dq = new LinkedList<Integer>();

			dq.addFirst(10);
			dq.addLast(20);
			dq.addFirst(5);
			dq.addLast(15);

			// Traversal Method 1
			Iterator it = dq.iterator();
			while(it.hasNext())
			{
				System.out.println(it.next() + " ");		// o/p: 5, 10, 20, 15
			}

			System.out.println();

			// Traversal Method 2
			for(int x : dq)
			{
				System.out.println(x + " ");				// o/p: 5, 10, 20, 15
			}

			System.out.println();

			// Reverse Traversal Method 1
			Iterator it = dq.descendingIterator();
			while(it.hasNext())
			{
				System.out.println(it.next() + " ");		// o/p: 15, 20, 10, 5
			}
		}
	}	




-> Note:
	a. "Deque" interface in Java extends "Queue" interface.



























ArrayDeque in Java
----------------------------------------------------------------------------------

-> ArrayDeque
	
	1. "ArrayDeque class" implements "Deque interface"

	2. "Deque interface" is a sub interface of "Queue interface"

	3. "Queue interface" is a sub interface of "Collection interface"




-> ArrayDeque as "Stack"
	
	import java.util.ArrayDeque;

	class Test
	{
		public static void main(String args[])
		{
			ArrayDeque<Integer> ad = new ArrayDeque<Integer>();	

			ad.push(10);
			ad.push(20);

			System.out.println(ad.peek());				// o/p: 20
			System.out.println(ad.pop());				// o/p: 20
			System.out.println(ad.peek());				// o/p: 10

			ad.push(40);

			System.out.println(ad.peek());				// o/p: 40
		}
	}





-> ArrayDeque as "Queue"
	
	import java.util.ArrayDeque;

	class Test
	{
		public static void main(String args[])
		{
			ArrayDeque<Integer> ad = new ArrayDeque<Integer>();

			ad.offer(10);
			ad.offer(20);

			System.out.println(ad.peek());				// o/p: 10
			System.out.println(ad.poll());				// o/p: 10
			System.out.println(ad.peek());				// o/p: 20

			ad.offer(40);

			System.out.println(ad.peek());				// o/p: 20
		}
	}



-> Important methods in Queue interface implemented by ArrayDeque
	
	1. Methods that throws Exception
		a. add()
		b. remove()
		c. element()

	2. Methods that Returns null/false
		a. offer()
		b. poll()
		c. peek()





-> ArrayDeque as "Deque"

	import java.util.ArrayDeque;

	class Test
	{
		public static void main(String args[])
		{
			ArrayDeque<Integer> ad = new ArrayDeque<Integer>();

			ad.offerFirst(10);
			ad.offerLast(20);
			ad.offerFirst(30);
			ad.offerLast(40);

			System.out.println(ad.peekFirst());			// o/p: 30
			System.out.println(ad.peekLast());			// o/p: 40
			System.out.println(ad.pollFirst());			// o/p: 30
			System.out.println(ad.peekFirst());			// o/p: 10
			System.out.println(ad.pollLast());			// o/p: 40
			System.out.println(ad.peekLast());			// o/p: 20
		}
	}






-> Important methods in Deque interface implemented by ArrayDeque
	
	1. Methods that throws Exception
		a. addFirst()
		b. addLast()
		c. removeFirst()
		d. removeLast()
		e. getFirst()
		f. getLast()

	2. Equivalent Methods that Returns null/false
		a. offerFirst()
		b. offerLast()
		c. pollFirst()
		d. pollLast()
		e. peekFirst()
		f. peekLast()



-> Redundant Functions/Methods in ArrayDeque class

	1. 	add()					addLast()

	2.	remove()				removeFirst()

	3. 	poll()					pollFirst()

	4. 	offer()					offerLast()

	5. 	element()				getFirst()

	6. 	peek()					peekFirst()

	7. 	push()					addFirst()

	8. 	pop()					removeFirst()  
































Design a Data Structure with Min and Max operations
---------------------------------------------------------------------------------------

-> Problem Statement:
	Design a data structure that supports following operations in O(1) time complexity.

	1. insertMin(x)			// We can assume, the inserted inserted item is always smaller than existing items

	2. insertMax(x)			// We can assume, the inserted inserted item is always greater than existing items

	3. getMin()

	4. getMax()

	5. extractMin()			// This operation should remove the current min

	6. extractMax()			// This operation should remove the current max





-> C++ Implementation

	struct MyDs
	{
		deque<int> dq;

		void insertMin(int x)
		{
			dq.push_front(x);
		}

		void insertMax(int x)
		{
			dq.push_back(x);
		}

		int getMin()
		{
			return dq.front();
		}

		int getMax()
		{
			return dq.back();
		}

		int extractMin()
		{
			int x = dq.front();
			dq.pop_front();
			return x;
		}

		int extractMax()
		{
			int x = dq.back();
			dq.pop_back();
			return x;
		}
	};




































Maximum of all subarrays of size k
--------------------------------------------------------------------------------------

-> Given "n" as the size of array and "k" <= "n", we have "n - k + 1" number of 
	subarrays of size k



1. Naive Solution

	void printMaxK(int arr[], int n, int k)
	{
		for(int i=0; i < n-k+1; i++)
		{
			int mx = arr[i];

			for(int j = i+1; j < i+k; j++)
			{
				mx = max(arr[j], mx);
			}

			cout<<mx<<" ";
		}
	} 


	Time Complexity:	O(n^2)





2. Efficient Solution

	-> Idea: Use a "deque" of size "k" and maintain front element as the maximum

	void printMaxK(int arr[], int n, int k)
	{
		deque<int> dq;

		for(int i=0; i<k; i++)
		{
			while(!dq.empty() && arr[i] >= arr[dq.back()])
			{
				dq.pop_back();
			}

			dq.push_back(i);
		}

		for(int i=k; i<n; i++)
		{
			cout<<arr[dq.front()]<<" ";

			while(!dq.empty() && dq.front() <= i-k)
			{
				dq.pop_front();
			}

			while(!dq.empty() && arr[i] >= arr[dq.back()])
			{
				dq.pop_back();
			}

			dq.push_back();
		}

		cout<<arr[dq.front()]<<" ";  
	}


	Time Complexity:	O(n)


































First Circular Tour
------------------------------------------------------------------------------------
#Repeat
#Revise

-> Problem Statement
	Suppose there is a circle. There are N petrol pumps on that circle. You will be given two sets of data.

		1. The amount of petrol that every petrol pump has.
		2. Distance from that petrol pump to the next petrol pump.

	Find a starting point where the truck can start to get through the complete circle without exhausting its petrol in between.
	Note :  Assume for 1 litre petrol, the truck can go 1 unit of distance.


	-> Example 1
		Input:
			N = 4
			Petrol = 4 6 7 4
			Distance = 6 5 3 5

		Output: 1

		Explanation: There are 4 petrol pumps with amount of petrol and distance to next petrol pump 
		value pairs as {4, 6}, {6, 5}, {7, 3} and {4, 5}. The first point from where truck 
		can make a circular tour is 2nd petrol pump. Output in this case is 1 (index of 2nd petrol pump).



1. Naive Solution

	int firstPetrolPump(int petrol[], int dist[], int n)
	{

		for(int start = 0; start < n; start++)
		{
			int curr_petrol = 0;
			int end = start;

			while(true)
			{
				curr_petrol += (petrol[end] - dist[end]);

				if(curr_petrol < 0)
				{
					break;
				}

				end = (end + 1) % n;

				if(end == start)
				{
					return (start + 1);
				}
			}
		}

		return -1;
	}


	Time Complexity:	O(n^2)
	Space Complexity:	O(1)



2. Better Solution

	-> Use a "deque"

	-> Idea: We maintain a "deque" of current set of petrol pumps that can be visited
		1. Keep adding items to the end of "deque" while curr_petrol is greater than equal to 0
		2. Keep removing items from the front of "deque" while curr_petrol is negative


	-> Time Complexity: 	O(n)
	-> Space Complexity:	O(n)


	

3. Optimized Better Solution

	-> We can use the given arrow as "deque" by maintaining start and end pointers

	-> Time Complexity: 	O(n)
	-> Space Complexity:	O(1)

	-> Requires two traversal




4. Efficient/Best Solution

	-> Single Traversal

	-> If curr_petrol becomes negative at p(i), then none of the petrol pumps 
		from p(0) to p(i) can be a solution

		-> Let p(i) be the first petrol pump where current petrol becomes negative, then

						    i
			curr_petrol =     (petrol[j] - dist[j])
						   j=0



	-> C++ Implementation

		int firstPetrolPump(int petrol[], int dist[], int n)
		{
			int start = 0;
			int curr_petrol = 0;
			int prev_petrol = 0;

			for(int i=0; i<n; i++)
			{
				curr_petrol += (petrol[i] - dist[i]);

				if(curr_petrol < 0)
				{
					start = i+1;
					prev_petrol += curr_petrol;
					curr_petrol = 0;
				}
			}

			return ( (curr_petrol + prev_petrol) >= 0 ) ? (start + 1) : -1;
		}


		Time Complexity:	O(n)
		Space Complexity:	O(1)

































































































































































#########################################################
15. Tree
#########################################################


Tree Data Structure
--------------------------------------------------------------------------------------------------------

-> Can be used to store Hierarchy, for eg.
	
	1. Organisational structure

	2. Folder structure



-> Tree data structure is Recursive in nature

-> Degree of a Node is the number of "children" it has.


-> Leaf Nodes: Nodes which has degree 0

-> Internal Nodes: Nodes having degree greater than 0































Applications of Tree
--------------------------------------------------------------------------------------------------------

-> Applications of Tree

	1. To represent hierarchical data
		-> Organisation Structure
		-> Folder Structure
		-> XML/HTML content (JSON Objects)
		-> In OOP (Inheritance)

	2. Binary Search trees

	3. Binary Heap
		-> Used for Priority Queue

	4. B and B+ Trees in DBMS

	5. Spanning and Shortest path trees in computer networks
		-> Bridges use Spanning Tree to forward the packets
		-> Routers use Shortest path Tree 

	6. Parse Tree, Expression Tree in Compilers
		-> Parse trees and Expression trees are used in compilers to 
			parse the source code

	7. Trie
		-> Used to represent "Dictionaries"
		-> Also supports operations like "prefix search"

	8. Suffix Tree
		-> Used to perform fast searching in Strings

	9. Binary Index Tree
		-> Used for ranged query searches
		-> Faster for a limited set of operations

	10. Segment Tree
		-> Used for ranged query searches
		-> More powerful

































Binary Tree
-----------------------------------------------------------------------------------------------------

-> Every Node has at most two children


-> Binary Search Tree is the most used Tree Data Structure




-> C++ implementation of Binary Tree representation

	struct Node
	{
		int key;
		Node* left;
		Node* right;

		Node(int k)
		{
			key = k;
			left = right = NULL;
		}
	}

	int main()
	{
		Node* root = new Node(10);
		root->left = new Node(20);
		root->right = new Node(30);

		root->left->left = new Node(40);
	}






-> Java Implementation of Binary Tree representation

	class Node()
	{
		int key;
		Node left;
		Node right;

		Node(int k)
		{
			key = k;
		}
	}

	class Test
	{
		public static void main(String[] args)
		{
			Node root = new Node(10);
			root.left = new Node(20);
			root.right = new Node(30);
			root.left.left = new Node(40);
		}
	}




-> For an empty tree, "root" is NULL/null.





























Tree Traversal
--------------------------------------------------------------------------------------------------------

-> Tree traversal can be mainly categorized in two parts

	1. Breadth First
		-> Level Order Traversal

	2. Depth First
		-> Inorder Traversal (Left, Root, Right)
		-> Preorder Traversal (Root, Left, Right)
		-> Postorder Traversal (Left, Right, Root)























Implementation of Inorder Traversal
-----------------------------------------------------------------------------------------------------------

1. My Implementation

	struct Node
	{
	    int key;
	    Node* left;
	    Node* right;
	    
	    Node(int k)
	    {
	        key = k;
	        left = right = NULL;
	    }
	};

	void inorderTraversal(Node* root)
	{
	    if(root != NULL)
	    {
	        inorderTraversal(root->left);
	        cout<<root->key<<" ";
	        inorderTraversal(root->right);
	    }
	}

	void preorderTraversal(Node* root)
	{
	    if(root != NULL)
	    {
	        cout<<root->key<<" ";
	        preorderTraversal(root->left);
	        preorderTraversal(root->right);
	    }
	}

	void postorderTraversal(Node* root)
	{
	    if(root != NULL)
	    {
	        postorderTraversal(root->left);
	        postorderTraversal(root->right);
	        cout<<root->key<<" ";
	    }
	}

	int main()
	{
	    Node* root = new Node(10);
	    root->left = new Node(20);
	    root->right = new Node(30);
	    root->right->left = new Node(40);
	    root->right->right = new Node(50);
	    
	    cout<<"Inorder Traversal: [ "; inorderTraversal(root); cout<<"]"<<endl;
	    cout<<"Preorder Traversal: [ "; preorderTraversal(root); cout<<"]"<<endl;
	    cout<<"Postorder Traversal: [ "; postorderTraversal(root); cout<<"]"<<endl;

	    return 0;
	}	





2. C++ Implementation of Inorder Traversal

	void inorder(Node* root)
	{
		if(root != NULL)
		{
			inorder(root->left);
			cout<<(root->key)<<" ";
			inorder(root->right);
		}
	}


	Time Complexity:	O(N)		// N - number of nodes in tree
	Space Complexity:	O(H)		// H - height of tree

























Implementation of Preorder Traversal
------------------------------------------------------------------------------------------------------------

-> C++ Implementation of Preorder traversal

	void preorder(Node* root)
	{
		if(root != NULL)
		{
			cout<<(root->key)<<" ";
			preorder(root->left);
			preorder(root->right);
		}
	}	


	Time Complexity:	O(N)		// N - number of nodes in tree
	Space Complexity:	O(H)		// H - height of tree



























Implementation of Postorder Traversal
-------------------------------------------------------------------------------------------------------------

-> C++ Implementation of Postorder traversal

	void postorder(Node* root)
	{
		if(root != NULL)
		{
			postorder(root->left);
			postorder(root->right);
			cout<<(root->key)<<" ";
		}
	}	


	Time Complexity:	O(N)		// N - number of nodes in tree
	Space Complexity:	O(H)		// H - height of tree

































Height of Binary Tree
----------------------------------------------------------------------------------------------------------------

-> Height of a binary tree is maximum number of nodes from root to a leaf path.


1. C++ Implementation

	int height(Node* root)
	{
		if(root == NULL)
		{
			return 0;
		}
		else
		{
			return max( height(root->left), height(root->right) ) + 1;
		}
	}


	Time Complexity: 	O(n)
	Space Complexity:	O(h)





2. Java Implementation

	int height(Node root)
	{
		if(root == null)
		{
			return 0;
		}
		else
		{
			return Math.max( height(root.left), heigth(root.right) ) + 1;
		}
	}
































Print Nodes at K distance
-----------------------------------------------------------------------------------------------------------------

-> To print the Nodes which are at a distance of K from the root

-> We mainly need to print the (K+1)th Level of the binary tree



1. My Solution 

	-> Assuming the root as Level-0

	void printNodesAtKDistance(Node* root, int k)
	{
	    if(root != NULL)
	    {
	        if(k == 0)
	        {
	            cout<<root->key<<" ";
	        }
	        
	        printNodesAtKDistance(root->left, k-1);
	        printNodesAtKDistance(root->right, k-1);
	    }
	}	




2. C++ Solution

	void printKDist(Node* root, int k)
	{
		if(root == NULL)
		{
			return;
		}

		if(k == 0)
		{
			cout<<(root->key)<<" ";
		}
		else
		{
			printKDist(root->left, k-1);
			printKDist(root->right, k-1);
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(h)




























Level Order Traversal
-----------------------------------------------------------------------------------------------------------------
 
-> Breadth First Search(BFS) of binary tree


1. My Solution (Iterative)

	void levelorderTraversal(Node* root)
	{
	    if(root == NULL)
	    {
	        cout<<"[ ]";
	        return;
	    }
	    
	    queue<Node*> q;
	    cout<<"[ ";
	    cout<<root->key<<" ";
	    q.push(root);
	    while(!q.empty())
	    {
	        Node* curr = q.front();
	        q.pop();
	        if(curr->left != NULL)
	        {
	            cout<<curr->left->key<<" ";
	            q.push(curr->left);
	        }
	        
	        if(curr->right != NULL)
	        {
	            cout<<curr->right->key<<" ";
	            q.push(curr->right);
	        }
	    }
	    cout<<"]";
	    
	}




2. C++ Implementation of Level Order Traversal

	void printLevel(Node* root)
	{
		if(root == NULL)
		{
			return;
		}

		queue<Node*> q;
		q.push(root);

		while(q.empty() == false)
		{
			Node* curr = q.front();
			q.pop();
			cout<<(curr->key)<<" ";

			if(curr->left != NULL)
			{
				q.push(curr->left);
			}

			if(curr->right != NULL)
			{
				q.push(curr->right);
			}
		}
	}



	Time Complexity:	O(n)
		-> Each Node goes into the "queue" exactly once and comes out of the "queue" exactly once

	Space Complexity:	O(n)		
		-> More precisely Space Complexity = (w), w is width of binary tree


	





3. Java Implementation of Level Order Traversal

	void printLevel(Node root)
	{
		if(root != null)
		{
			return;
		}

		Queue<Node> q = new LinkedList<Node>();
		q.add(root);

		while(q.isEmpty() == false)
		{
			Node curr = q.poll();

			System.out.print(curr.key + " ");

			if(curr.left != null)
			{
				q.add(curr.left);
			}

			if(curr.right != null)
			{
				q.add(curr.right); 
			}
		}
	}



































Level Order Traversal Line by Line (Part 1)
--------------------------------------------------------------------------------------------------------------

1. My Solution

	void levelorderTraversalLineByLine(Node* root)
	{
	    if(root == NULL)
	    {
	        cout<<"[ ]"<<endl;
	        return;
	    }
	    
	    queue<Node*> q;
	    Node* flag;
	    q.push(root);
	    q.push(flag);
	    
	    while(!q.empty())
	    {
	        Node* curr = q.front();
	        q.pop();
	        
	        if(curr == flag)
	        {
	            continue;
	        }
	        else if(q.front() == flag)
	        {
	            cout<<curr->key<<endl;
	            if(curr->left != NULL)
	            {
	                q.push(curr->left);
	            }
	            if(curr->right != NULL)
	            {
	                q.push(curr->right);
	            }
	            
	            q.push(flag);
	        }
	        else
	        {
	            cout<<curr->key<<" ";
	            if(curr->left != NULL)
	            {
	                q.push(curr->left);
	            }
	            if(curr->right != NULL)
	            {
	                q.push(curr->right);
	            }
	        }
	    }
	}






2. My Solution-2

	void levelorderTraversalLineByLine(Node* root)
	{
	    if(root == NULL)
	    {
	        cout<<"[ ]"<<endl;
	        return;
	    }
	    
	    queue<Node*> q;
	    Node* flag;
	    q.push(root);
	    q.push(flag);
	    
	    while(!q.empty())
	    {
	        Node* curr = q.front();
	        q.pop();
	        Node* next = q.front();
	        
	        if(curr == flag)
	        {
	            continue;
	        }
	        
	        cout<<curr->key<<" ";
	        if(curr->left != NULL)
	        {
	            q.push(curr->left);
	        }
	        if(curr->right != NULL)
	        {
	            q.push(curr->right);
	        }
	        
	        if(next == flag)
	        {
	            cout<<endl;
	            q.push(flag);
	        }
	    }
	}





3. C++ Solution

	void printLevelOrderLine(Node* root)
	{
		if(root == NULL)
		{
			return;
		}

		queue<Node*> q;
		q.push(root);
		q.push(NULL);

		while(q.size() > 1)
		{
			Node* curr = q.front();
			q.pop();

			if(curr == NULL)
			{
				cout<<"\n";
				q.push(NULL);
				continue;
			}

			cout<<(curr->key)<<" ";

			if(curr->left != NULL)
			{
				q.push(curr->left);
			}

			if(curr->right != NULL)
			{
				q.push(curr->right);
			}
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(n)  



























Level Order Traversal Line By Line (Part 2)
------------------------------------------------------------------------------------------------------------------

1. C++ Implementation

	void printLevelOrderLine(Node* root)
	{
		if(root == NULL)
		{
			return;
		}

		queue<Node*> q;
		q.push(root);

		while(q.empty() == false)
		{
			int count = q.size();

			for(int i=0; i<count; i++)
			{
				Node* curr = q.front();
				q.pop();

				cout<<(curr->key)<<" ";

				if(curr->left != NULL)
				{
					q.push(curr->left);
				}

				if(curr->right != NULL)
				{
					q.push(curr->right);
				}
			}

			cout<<"\n";
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(n)
































Size of Binary Tree
----------------------------------------------------------------------------------------------------------------

-> Size of a Binary Tree is equal to Total number of Nodes present in the Binary Tree


1. My Solution

	int countNodes(Node* root)
	{
	    if(root == NULL)
	    {
	        return 0;
	    }
	    
	    int x = countNodes(root->left);
	    int y = countNodes(root->right);
	    
	    return x+y+1;
	}



2. C++ Solution (Recursive)

	int getSize()
	{
		if(root == NULL)
		{
			return 0;
		}
		else
		{
			return ( 1 + getSize(root->left) + getSize(root->right) );
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(h)





Note:
	To count the number of nodes Iteratively we can use traverse the tree in Level Order Fashion































Maximum in Binary Tree
--------------------------------------------------------------------------------------------------------------------

1. My Solution

	int getMax(Node* root)
	{
	    if(root == NULL)
	    {
	        return -1;
	    }
	    
	    int maximum = root->key;
	    queue<Node*> q;
	    q.push(root);
	    
	    while(!q.empty())
	    {
	        Node* curr = q.front();
	        q.pop();
	        
	        maximum = max(maximum, curr->key);
	        
	        if(curr->left != NULL)
	        {
	            q.push(curr->left);
	        }
	        
	        if(curr->right != NULL)
	        {
	            q.push(curr->right);
	        }
	    }
	    
	    return maximum;
	}






2. C++ Implementation

	int getMax(Node* root)
	{
		if(root == NULL)
		{
			return INT_MIN;
		}
		else
		{
			return max( root->key, max( getMax(root->left), getMax(root->right) ) );
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(h)
































Print Left View of Binary Tree
---------------------------------------------------------------------------------------------------------------

1. My Solution-1

	-> Idea is to do "Level Order Traversal" and print only the first element of each level

	void printLeftView(Node* root)
	{
	    if(root == NULL)
	    {
	        return;
	    }
	    queue<Node*> q;
	    q.push(root);
	    
	    while(!q.empty())
	    {
	        int count = q.size();
	        for(int i=0; i<count; i++)
	        {
	            Node* temp = q.front();
	            q.pop();
	            
	            if(i == 0)
	            {
	                cout<<temp->key<<" ";
	            }
	            
	            if(temp->left != NULL)
	            {
	                q.push(temp->left);
	            }
	            
	            if(temp->right != NULL)
	            {
	                q.push(temp->right);
	            }
	        }
	    }
	}





2. C++ Solution (Recursive)

	-> The idea is when we do "preorder traversal", It always first visits the left most Node of a given Level.


	-> Source Code:

		int maxLevel = 0;

		void printLeft(Node* root, int level)
		{
			if(root == NULL)
			{
				return;
			}

			if(maxLevel < level)
			{
				cout<<(root->key)<<" ";
				maxLevel = level;
			}

			printLeft(root->left, level+1);
			printLeft(root->right, level+1);
		
		}

		void printLeftView(Node* root)
		{
			printLeft(root, 1);
		}


		Time Complexity:	O(n)
		Space Complexity:	O(h)




3. C++ Solution (Iterative)

	-> based on "Level Order Traversal"

	void printLeft(Node* root)
	{
		if(root == NULL)
		{
			return;
		}

		queue<Node*> q;
		q.push(root);

		while(q.empty() == false)
		{
			int count = q.size();
			for(int i=0; i<count; i++)
			{
				Node* curr = q.front();
				q.pop();

				if(i == 0)
				{
					cout<<(curr->key)<<" ";
				}

				if(curr->left != NULL)
				{
					q.push(curr->left);
				}

				if(curr->right != NULL)
				{
					q.push(curr->right);
				}
			}
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(n)  O(w)


































Children Sum Property
-----------------------------------------------------------------------------------------------------------------

-> Children Sum Property
	For each Node, sum of values of left child and right child should be equal to Node's value



1. My Solution

	bool validChildrenSum(Node* root)
	{
	    bool res = true;
	    if(root == NULL)
	    {
	        return (res && true);
	    }
	    
	    if(root->left == NULL && root->right == NULL)
	    {
	        return (res && true);
	    }
	    
	    int currSum = 0;
	    if(root->left != NULL)
	    {
	        currSum += root->left->data;
	    }
	    
	    if(root->right != NULL)
	    {
	        currSum += root->right->data;
	    }
	    
	    if(currSum != root->data)
	    {
	        return (res && false);
	    }
	    
	    res = (res && validChildrenSum(root->left));
	    res = (res && validChildrenSum(root->right));
	    return res;
	}




2. C++ Solution

	bool isChildrenSum(Node* root)
	{
		if(root == NULL)
		{
			return true;
		}

		if(root->left == NULL && root->right == NULL)
		{
			return true;
		}

		int sum = 0;
		if(root->left != NULL)
		{
			sum += root->left->key;
		}
		if(root->right != NULL)
		{
			sum += root->right->key;
		}

		bool check1 = (sum == root->key);
		bool check2 = isChildrenSum(root->left);
		bool check3 = isChildrenSum(root->right);

		return (check1 && check2 && check3);
	}


	Time Complexity:	O(n)
	Space Complexity:	O(h)		// Space required for Recursion call stacks





































Check for Balanced Binary Tree
-------------------------------------------------------------------------------------------------------------

-> To check if the given binary tree is "height balanced"

-> A binary tree is height balanced if the difference b/w heights of left sub-tree and right sub-tree, 
	should not be more than one and this condition should be true for each and every Node.



1. My Solution

	// Utility/Helping Function
	int height(Node* root)
	{
	    if(root == NULL)
	    {
	        return 0;
	    }
	    
	    int heightOfLeftSubTree = height(root->left);
	    int heightOfRightSubTree = height(root->right);
	    
	    return (1 + max(heightOfLeftSubTree, heightOfRightSubTree));
	}

	// Utility/Helping Function
	bool checkForBalance(Node* root)
	{
	    int heightOfLeftSubTree = height(root->left);
	    int heightOfRightSubTree = height(root->right);
	    
	    if(abs(heightOfLeftSubTree-heightOfRightSubTree) > 1)
	    {
	        return false;
	    }
	    
	    return true;
	}

	// Desired/Called Function
	bool isBalanced(Node* root)
	{
	    if(root == NULL)
	    {
	        return true;
	    }
	    
	    bool check1 = checkForBalance(root);
	    bool check2 = checkForBalance(root->left);
	    bool check3 = checkForBalance(root->right);
	    
	    return (check && check1 && check2);
	}





2. Naive Solution: O(n^2)

	bool isBalanced(Node* root)
	{
		if(root == NULL)
		{
			return true;
		}

		int leftHeight = height(root->left);
		int rightHeight = height(root->right);

		bool check1 = ( abs(leftHeight - rightHeight) <= 1 );
		bool check2 = isBalanced(root->left);
		bool check3 = isBalanced(root->right);

		return (check1 && check2 && check3);
	}


	Time Complexity:	O(n^2)		// For each Node, we are calling "height() function" which takes O(n) time




3. Efficient Solution: O(n)

	-> The idea is that each function call will tell if the sub-tree is balanced and the height of sub-trees

	-> Implementation

		int isBalanced(Node* root)
		{
			if(root == NULL)
			{
				return 0;		
			}

			// Check for left Subtrees, also get the left height
			int leftHeight = isBalanced(root->left);
			if(leftHeight == -1)
			{
				return -1;
			}

			// Check for right Subtrees, also get the right height
			int rightHeight = isBalanced(root->right);
			if(rightHeight == -1)
			{
				return -1;
			}

			if(abs(leftHeight - rightHeight) > 1)
			{
				return -1;
			}
			else
			{
				return (1 + max(leftHeight, rightHeight));
			}
		}


		Time Complexity:	O(n)




































Maximum Width of Binary Tree
----------------------------------------------------------------------------------------------------------

1. My Solution

	int maxWidth(Node* root)
	{
	    if(root == NULL)
	    {
	        return 0;
	    }
	    queue<Node*> q;
	    q.push(root);
	    int mxwd = 0;
	    while(!q.empty())
	    {
	        int currentLevelWidth = q.size();
	        mxwd = max(currentLevelWidth, mxwd);
	        
	        for(int i=0; i<currentLevelWidth; i++)
	        {
	            Node* temp = q.front();
	            q.pop();
	            if(temp->left != NULL)
	            {
	                q.push(temp->left);
	            }
	            
	            if(temp->right != NULL)
	            {
	                q.push(temp->right);
	            }   
	        }
	    }
	    
	    return mxwd;
	}





2. C++ Solution

	int maxWidth(Node* root)
	{
		if(root == NULL)
		{
			return 0;
		}

		queue<Node*> q;
		q.push(root);

		int res = 0;

		while(q.empty() == false)
		{
			int count = q.size();
			res = max(res, count);

			for(int i=0; i<count; i++)
			{
				Node* curr = q.top();
				q.pop();

				if(curr->left != NULL)
				{
					q.push(curr->left);
				}

				if(curr->right != NULL)
				{
					q.push(curr->right);
				}
			}
		}

		return res;
	}


	Time Complexity:	O(n)
	Auxiliary Space: 	O(maxWidth)





































Convert Binary Tree to Doubly Linked List
----------------------------------------------------------------------------------------------------------------

-> To Convert a given Binary Tree into Doubly Linked List In-Place 

-> Use left pointer/reference as "prev" and right pointer/reference as "next"

-> The Order of the Doubly Linked List should be In-Order traversal order of the Binary Tree



1. C++ Implementation

	Node* prev = NULL;

	Node* binaryTreeToDoublyLinkedList(Node* root)
	{
		if(root == NULL)
		{
			return root;
		}

		Node* head = binaryTreeToDoublyLinkedList(root->left);

		if(prev == NULL)
		{
			head = root;
		}
		else
		{
			root->left = prev;
			prev->right = root;
		}
		prev = root;

		binaryTreeToDoublyLinkedList(root->right);

		return head;
	}


	Time Complexity:	O(n)
	Space Complexity:	O(h)
































Construct Binary Tree from Inorder and Preorder
-------------------------------------------------------------------------------------------------------------

-> We can construct a binary tree only if following two traversals are given
	1. Inorder traversal 
		-> Without Inorder traversal a unique binary tree can never be constructed

	2. Either Preorder or Postorder traversal is given 


-> So possible combination of traversals for which the binary tree can be constructed is
	1. Inorder + Preorder traversals
	2. Inorder + Postorder traversals 



-> We need to construct the binary tree from the given Inorder and Preorder traversals and return 
	the Node of the binary tree.


-> Here, we are going to construct the tree from Inorder & Preorder traversal


1. C++ Implementation

	-> Idea is, we construct the tree in Preorder fashion


	int preIndex = 0;

	Node* constructTree(int in[], int pre[], int is, int ie)
	{
		if(is > ie)
		{
			return NULL;
		}

		Node* root = new Node(pre[preIndex++]);



		int inIndex;					// index of the root element in the Inorder Array 
		for(int i=is; i <= ie; i++)
		{
			if(in[i] == root->key)
			{
				inIndex = i;
				break;
			}
		}

		root->left = constructTree(in, pre, is, inIndex-1);
		root->right = constructTree(in, pre, inIndex+1, ie);

		return root; 
	}


	Time Complexity
		1. Without Hashing:	O(n^2)
		2. With Hashing:	O(n)


	-> Note: 
		When calling we will initialize "is = 0" and "ie = array.size()-1"






























Tree Traversal in Spiral Form
-----------------------------------------------------------------------------------------------------------------

-> To perform Level Order Traversal in Spiral Form


1. My Solution 

	void spiralTraversal(Node* root)
	{
	    if(root == NULL)
	    {
	        return;
	    }
	    
	    queue<Node*> q;
	    q.push(root);  
	    int level = 0;
	    
	    while(!q.empty())
	    {
	        int count = q.size();
	        
	        if(level%2 == 0)
	        {
	            for(int i=0; i<count; i++)
	            {
	                Node* temp = q.front();
	                q.pop();
	                cout<<temp->data<<" ";
	                
	                if(temp->left != NULL)
	                {
	                    q.push(temp->left);
	                }
	                if(temp->right != NULL)
	                {
	                    q.push(temp->right);
	                }
	            }
	            cout<<endl;
	        }
	        else
	        {
	            vector<int> vec;
	            for(int i=0; i<count; i++)
	            {
	                Node* temp = q.front();
	                q.pop();
	                vec.push_back(temp->data);
	                
	                if(temp->left != NULL)
	                {
	                    q.push(temp->left);
	                }
	                if(temp->right != NULL)
	                {
	                    q.push(temp->right);
	                }
	            }
	            
	            reverse(vec.begin(), vec.end());
	            for(int i=0; i<vec.size(); i++)
	            {
	                cout<<vec[i]<<" ";
	            }
	            cout<<endl;
	        }
	        
	        level++;
	    }
	}


2. Beautifying the above code

	void spiralTraversal(Node* root)
	{
	    if(root == NULL)
	    {
	        return;
	    }
	    
	    queue<Node*> q;
	    q.push(root);  
	    int level = 0;
	    
	    while(!q.empty())
	    {
	        int count = q.size();
	        
	        vector<int> vec;
	        for(int i=0; i<count; i++)
	        {
	            Node* temp = q.front();
	            q.pop();
	            vec.push_back(temp->data);
	            
	            if(temp->left != NULL)
	            {
	                q.push(temp->left);
	            }
	            if(temp->right != NULL)
	            {
	                q.push(temp->right);
	            }
	        }
	        
	        if(level%2 != 0)
	            reverse(vec.begin(), vec.end());
	        for(int i=0; i<vec.size(); i++)
	        {
	            cout<<vec[i]<<" ";
	        }
	        cout<<endl;
	        
	        level++;
	    }
	}


3. My Efficient Solution

	void spiralTraversal(Node* root)
	{
	    if(root == NULL)
	    {
	        return;
	    }
	    
	    deque<Node* > dq;
	    dq.push_back(root);
	    int level = 0;
	    
	    while(!dq.empty())
	    {
	        int count = dq.size();
	        if(level%2 == 0)
	        {
	            for(int i=0; i<count; i++)
	            {
	                Node* temp = dq.front();
	                dq.pop_front();
	                cout<<temp->data<<" ";
	                if(temp->left != NULL)
	                {
	                    dq.push_back(temp->left);
	                }
	                
	                if(temp->right != NULL)
	                {
	                    dq.push_back(temp->right);
	                }
	            }
	            cout<<endl;
	        }
	        else
	        {
	            for(int i=0; i<count; i++)
	            {
	                Node* temp = dq.back();
	                dq.pop_back();
	                cout<<temp->data<<" ";
	                if(temp->right != NULL)
	                {
	                    dq.push_front(temp->right);
	                }
	                
	                if(temp->left != NULL)
	                {
	                    dq.push_front(temp->left);
	                }
	            }
	            cout<<endl;
	        }
	        
	        level++;
	    }
	    
	}




3. Method-1

	void printSpriral(Node* root)
	{
		if(root == NULL)
		{
			return;
		}

		queue<Node*> q;
		stack<int> s;
		bool reverse = false;
		q.push(root);

		while(q.empty() == false)
		{
			int count = q.size();

			for(int i=0; i<count; i++)
			{
				Node* curr = q.front();
				q.pop();

				if(reverse)
				{
					s.push(curr->key);
				}
				else
				{
					cout<<(curr->key)<<" ";
				}

				if(curr->left != NULL)
				{
					q.push(curr->left);
				}

				if(curr->right != NULL)
				{
					q.push(curr->right);
				}
			}

			if(reverse)
			{
				while(s.empty() == false)
				{
					cout<<s.top()<<" ";
					s.pop();
				}
			}

			reverse = !reverse;
			cout<<endl;
		}
	}


	Time Complexity:	O(4n)



4. Method-2

	-> Idea of this efficient solution is to use "2 stacks"

		1. Push root to the stack s1

		2. While any of the two stacks is not empty
				while s1 is not empty
					a. Take out a Node, print it
					b. Push children of the taken out node into s2

				while s2 is not empty
					a. Take out a node, print it
					b. Push children of the taken out node into s1 in reverse order
						-> Reverse order means we push right child before the left child

	
	-> Time Complexity: O(2n)
































Diameter of a Binary Tree
---------------------------------------------------------------------------------------------------------------------------

-> Diameter of a Binary Tree is the Number of Nodes on its longest path, between two leaf Nodes. 


-> Idea for Naive Solution:
	
	Find the following value for every node: "1 + leftHeight + rightHeight"
	and return the maximum: max(1 + leftHeight + rightHeight)




1. My Implementation

	int maxDiameter = 0;

	int height(Node* root)
	{
	    if(root == NULL)
	    {
	        return 0;
	    }
	    
	    return 1 + max(height(root->left), height(root->right));
	}


	void diameter(Node* root)
	{
	    if(root == NULL)
	    {
	        return;
	    }
	    
	    int leftHeight = height(root->left);
	    int righHeight = height(root->right);
	    
	    int currDiameter = 1+leftHeight+righHeight;
	    maxDiameter = max(currDiameter, maxDiameter);
	    
	    diameter(root->left);
	    diameter(root->right);
	}


	int maximumDiameter(Node* root)
	{
		diameter(root);

		return maxDiameter;
	}




2. Naive Solution: 	O(n^2)

	int height(Node* root)
	{
		if(root == NULL)
		{
			return 0;
		}
		else
		{
			return 1 + max(height(root->left), height(root->right));
		}
	}

	int diameter(Node* root)
	{
		if(root == NULL)
		{
			return 0;
		}

		int d1 = 1 + height(root->left) + height(root->right);
		int d2 = diameter(root->left);
		int d3 = diameter(root->right);

		return max(d1, max(d2, d3));
	}





-> Idea for Better Solution: O(n)

	1. Precompute height of every node and store it in a map.

	2. In C++, we can use "unordered_set<Node*, int> us"

	3. In Java we can use "HashMap<Node, int> hashMap"




-> Idea for Efficient Solution
	
	1. Time Complexity: O(n)
	2. No overhead of map

	-> We can achieve it by simply modifying the "height" function for binary tree


	-> C++ Implementation // This function returns height, but sets the "res" variable to have "maxDiameter"

		int res = 0;

		int height(Node* root)
		{
			if(root == NULL)
			{
				return 0;
			}

			int leftHeight = height(root->left);
			int rightHeight = height(root->right);

			int currentDiameter = 1 + leftHeight + rightHeight;

			res = max(res, currentDiameter);

			return 1 + max(leftHeight, rightHeight);		// returns the height of the current Node
		}


		Note:
			This function returns height, but sets the "res" variable to have "maxDiameter"





































LCA of Binary Tree (Part 1)
--------------------------------------------------------------------------------------------------------------------

-> Lowest Common Ancestor 

-> Using "Lowest Common Ancestor" we can find distance b/w two given Nodes in a binary tree.



1. Naive Solution

	-> Idea

		1. We form two arrays "path1[]" and "path2[]"
				"path1[]" consists the Nodes form "root" to "givenNode1"
				"path2[]" consists the Nodes form "root" to "givenNode2"

		2. Then we will traverse the Array in forward direction i.e., left to right
			-> The last common Node will be the "Lowest Common Ancestor"





	1.1. My Naive Implementation

			vector<Node*> path1;
			vector<Node*> path2;

			// Function to check if we can reach "n", starting from the given Node
			bool containsKey(Node* root, int n)
			{
			    if(root == NULL)
			    {
			        return false;
			    }
			    
			    bool check1 = root->data == n;
			    bool check2 = containsKey(root->left, n);
			    bool check3 = containsKey(root->right, n);
			    
			    return check1 || check2 || check3;
			}

			// Function to build "path" array
			void buildPathArray(Node* root, int pathNumber, int n)
			{
			    if(root == NULL)
			    {
			        return;
			    }
			    
			    bool check1 = root->data == n;
			    bool check2 = containsKey(root->left, n);
			    bool check3 = containsKey(root->right, n);
			    
			    if(check1 || check2 || check3)
			    {
			        if(pathNumber == 1)
			        {
			            path1.push_back(root);
			        }
			        else
			        {
			            path2.push_back(root);
			        }
			    }
			    
			    buildPathArray(root->left, pathNumber, n);
			    buildPathArray(root->right, pathNumber, n);
			}

			// Function to find "Lowest Common Ancestor" of "a" and "b"
			Node* lowestCommonAncestor(Node* root, int a, int b)
			{
			    if(root == NULL)
			    {
			        return root;
			    }
			    
			    buildPathArray(root, 1, a);
			    buildPathArray(root, 2, b);

			    
			    int i=0;
			    while(i<path1.size() && i<path2.size())
			    {
			        if(path1[i] != path2[i])
			        {
			            break;
			        }
			        
			        i++;
			    }
			    
			    return path1[i-1];
			}



	1.2. C++ Implementation

		bool findPath(Node* root, vector<Node*> &p, int n)
		{
			if(root == NULL)
			{
				return false;
			}

			p.push_back(root);

			if(root->key == n)
			{
				return true;
			}

			if(findPath(root->left, p, n) || findPath(root->right, p, n))
			{
				return true;
			}

			p.pop_back();
			return false;
		}


		Node* lca(Node* root, int n1, int n2)
		{
			vector<Node*> path1, path2;

			if((findPath(root, path1, n1) == false) || (findPath(root, path2, n2) == false))
			{
				return NULL;
			}

			for(int i=0; i<path1.size()-1 && i<path2.size()-1; i++)
			{
				if(path1[i+1] != path2[i+1])
				{
					return path1[i];
				}
			}

			return NULL;
		}


		Time Complexity:	O(n)		// Requires 3 traversals
		Space Complexity:	O(n)











LCA of Binary Tree (Part 2)
----------------------------------------------------------------------------------------------------------------


2. Efficient Solution

	-> Requires one traversal and O(h) extra space for the recursive traversal

	-> Assumes that both n1 and n2 exist in the tree. Does not give correct result 
		when one(n1 or n2) exists.


	-> Idea : We do normal recursive traversal. We have the following cases for every Node

		1. If it is same as n1 or n2

		2. If one of its subtrees contains n1 and other contains n2

		3. If one of its subtrees contains both n1 and n2

		4. If none of its subtrees contain any of n1 and n2




	2.1. C++ Implementation

		Node* lca(Node* root, int n1, int n2)
		{
			if(root == NULL)
			{
				return NULL;
			}

			if(root->key == n1 || root->key == n2)
			{
				return root;
			}


			Node* lca1 = lca(root->left, n1, n2);
			Node* lca2 = lca(root->right, n1, n2);

			if(lca1 != NULL && lca2 != NULL)
			{
				return root;
			}
			

			if(lca1 != NULL)			// both the keys are present in left-subtree
			{
				return lca1;
			}
			else 						// both the keys are present in right-subtree
			{
				return lca2;
			}
		}


		Time Complexity:	O(n)
		Space Complexity:	O(h)






































Burn a Binary Tree from a Leaf
----------------------------------------------------------------------------------------------------------------

-> Given a binary tree and a leaf node, We need to find out, time to burn the whole binary tree, if we initially burn
	the given leaf node.

-> At 0th second the leaf node is burnt, the next second all its adjacent nodes are burnt and so on.

-> We have to find out the time it will take to burn the whole tree  


-> If the given leaf node is not present then return -1



-> The idea to solve the problem is, we just need to "find out the farthest Node from the given leaf"
	The distance b/w the leaf node and the farthest node from the leaf node will be our output.



-> The farthest node must be reachable through one of the "Ancestors"




1.1. C++ Implementation

	-> Note:
			a. res is shared by all function calls
			b. Initially dist = -1 in C++ and dist.val = -1 in Java


	-> Two Things are done
		1. Return height 
		2. Set "dist" if given leaf is a descendant


	-> Implementation

		int res = 0;

		int burnTime(Node* root, int leaf, int &dist)
		{
			if(root == NULL)
			{
				return 0;					// If the node is NULL, then return height as 0
			}

			if(root->data == leaf)			// We are assuming that we are always provided with correct leaf node
			{
				dist = 0;
				return 1;					// If the node is a leaf node, then the height is 1
			}

			int leftDistance = -1;
			int rightDistance = -1;

			int leftHeight = burnTime(root->left, leaf, leftDistance);
			int rightHeight = burnTime(root->right, left, rightDistance);

			if(leftDistance != -1)					// Checking if the given leaf node is a decendent of this root or not
			{
				dist = leftDistance + 1;
				res = max(res, dist + rightHeight);
			}
			else if(rightDistance != -1)			// Checking if the given leaf node is a decendent of this root or not
			{
				dist = rightDistance + 1;
				res = max(res, dist + leftHeight);
			}

			return max(leftHeight, rightHeight) + 1;		// returning the height of the current node
		}





1.2. Java Implementation

	class Distance
	{
		int val;
		Distance(int d)
		{
			val = d;
		}
	}

	int res = 0;

	int burnTime(Node root, int leaf, Distance dist)
	{
		if(root == null)
		{
			return 0;
		}

		if(root.data == leaf)
		{
			dist.val = 0;
			return 1;
		}

		Distance leftDistance = new Distance(-1);
		Distance rightDistance = new Distance(-1);

		int leftHeight = burnTime(root.left, leaf, leftDistance);
		int rightHeight = burnTime(root.right, leaf, rightDistance);

		if(leftDistance.val != -1)
		{
			dist.val = leftDistance.val + 1;
			res = Math.max(res, rightHeight + dist.val);
		}
		else if(rightDistance.val != -1)
		{
			dist.val = rightDistance.val + 1;
			res = Math.max(res, dist.val + leftHeight);
		}


		return Math.max(leftHeight, rightHeight);
	}































Count nodes in a Complete Binary Tree
--------------------------------------------------------------------------------------------------------------------

-> A binary tree is called "Complete Binary Tree", if it is completely filled except possibly the last level and the last level 
	has to filled from left to right



1. Naive Solution

	int countNodes(Node* root)
	{
		if(root == NULL)
		{
			return 0;
		}
		else
		{
			return (1 + countNodes(root->left) + countNodes(root->right));
		}
	}


	Time Complexity:	O(n)



2. Efficient Solution
	
	2.1. My implementation

		int countNodes(Node* root)
		{
		    int leftHeight = 0;
		    Node* temp = root;
		    while(temp != NULL)
		    {
		        leftHeight++;
		        temp = temp->left;
		    }
		    
		    int rightHeight = 0;
		    Node* tmp = root;
		    while(tmp != NULL)
		    {
		        rightHeight++;
		        tmp = tmp->right;
		    }
		    
		    if(leftHeight == rightHeight)
		    {
		        return pow(2, leftHeight) - 1;
		    }
		    else
		    {
		        return 1 + countNodes(root->left) + countNodes(root->right);
		    }
		}


	2.2. Tutor implementation

		int countNodes(Node* root)
		{
			int leftHeight = 0;
			int rightHeight = 0;

			Node* curr = root;
			while(curr != NULL)
			{
				leftHeight++;
				curr = curr->left;
			}

			curr = root;
			while(curr != NULL)
			{
				rightHeight++;
				curr = curr->right;
			}

			if(leftHeight == rightHeight)
			{
				return pow(2, leftHeight) - 1;
			}

			return 1 + countNodes(root->left) + countNodes(root->right);
		}



		Time Complexity:

			1. Best case: The best cases arises when the given complete binary tree is also a "Perfect binary tree" or
			   "fully filled binary tree"
					-> Time Complexity: O(h)

			2. Other cases: 
					-> Time Complexity:	O(log(n) * log(n))



































Serialize and Deserialize a Binary Tree
-----------------------------------------------------------------------------------------------------------------------

-> Serialization means to convert the binary tree into "String" or "Array" in such a way that the Binary tree 
	can be constructed back from the "String" of "Array" and this process of reconstruction of binary tree from 
	Serialized "String" or "Array" is called "Deserialization"


1. Naive Solution

	-> We can store "inorder traversal" and one other traversal in an array and reconstruct the tree back
	   using these two traversals if required. 



2. Efficient Solution

	-> Idea is to use any Marker to specify "NULL", for e.g., -1

	-> Here, we will use -1 for NULL, under the assumption that -1 is not present in tree as data

	-> In our implementation, we are going to use Preorder traversal for "Serialization" and "Deserialization" of the binary tree.


	2.1. My Implementation

		void serialize(Node* root, vector<int> &vec)
		{
		    if(root == NULL)
		    {
		        vec.push_back(-1);
		        return;
		    }
		    
		    vec.push_back(root->data);
		    serialize(root->left, vec);
		    serialize(root->right, vec);
		}


		-> Deserialization (Method-1)

			int currIndex = 0;
			Node* deserialize(vector<int> &vec, Node* root)
			{
			    if(currIndex >= vec.size())
			    {
			        return root;
			    }
			    
			    if(currIndex < vec.size() && vec[currIndex] == -1)
			    {
			        currIndex++;
			        return NULL;
			    }
			    else if(currIndex < vec.size())
			    {
			        root = new Node(vec[currIndex]);
			        currIndex++;
			        root->left = deserialize(vec, root->left);
			        root->right = deserialize(vec, root->right);  
			    }

			    return root;
			}
		

		-> Deserialization (Method-2)

			int currIndex = 0;
			Node* deserialize(vector<int> &vec)
			{
			    if(currIndex >= vec.size())
			    {
			        return NULL;
			    }
			    
			    if(vec[currIndex] == -1)
			    {
			        currIndex++;
			        return NULL;
			    }
			    
			    Node* root = new Node(vec[currIndex]);
			    currIndex++;
			    root->left = deserialize(vec);
			    root->right = deserialize(vec);  
			    return root;
			}			



	2.2. Tutor Implementation

		2.2.1. C++ Implementation

			-> Serialization

				const int EMPTY = -1;
				void serialize(Node* root, vector<int> &arr)
				{
					if(root == NULL)
					{
						arr.push_back(EMPTY);
						return;
					}

					arr.push_back(root->data);
					serialize(root->left, arr);
					serialize(root->right, arr);
				}


				Time Complexity: 	O(n)
				Space Complexity:	O(n)

							-> Note: If there are "n" nodes then there will be "n+1" number of NULL's
									 In total the vector size will be "2n + 1"


			-> Deserialization

				const int EMPTY = -1;
				int index = 0;
				Node* deSerialize(vector<int> &arr)
				{
					if(index == arr.size())
					{
						return NULL;
					}

					int val = arr[index];
					index++;

					if(val == EMPTY)
					{
						return NULL;
					}

					Node* root = new Node(val);
					root->left = deSerialize(arr);
					root->right = deSerialize(arr);

					return root;
				}


				Time Complexity:	O(n)
				Space Complexity:	




		2.2.2. Java Implementation

			-> Serialization

				static final int EMPTY = -1;
				void serialize(Node root, ArrayList<Integer> arr)
				{
					if(root == null)
					{
						arr.add(EMPTY);
						return;
					}

					arr.add(root.data);
					serialize(root.left, arr);
					serialize(root.right, arr);
				}


			-> Deserialization

				static final int EMPTY = -1;
				int index = 0;

				Node deSerialize(ArrayList<Integer> arr)
				{
					if(index == arr.size())
					{
						return null;
					}

					int val = arr[index];
					index++;
				}





























Iterative Inorder Traversal
---------------------------------------------------------------------------------------------------------------------

1. C++ Implementation

	void iterativeInorder(Node* root)
	{
		stack<Node*> st;

		Node* curr = root;

		while(curr!=NULL || st.empty()==false)
		{
			while(curr != NULL)
			{
				st.push(curr);
				curr = curr->left;
			}

			curr = st.top();
			st.pop();
			cout<<curr->data<<" ";
			curr = curr->right;
		}
	}


	Time Complexity:	O(n)			// n: number of nodes in the binary tree
	Space Complexity:	O(h)			// h: height of binary tree



2. Java Implementation

	void iterativeInorder(Node root)
	{
		Stack<Node> st = new Stack<Node>();

		Node curr = root;
		while(curr!=null && st.isEmpty()==false)
		{
			while(curr != null)
			{
				st.push(curr);
				curr = curr.left;
			}

			curr = st.pop();
			System.out.print(curr.data + " "); 
			curr = curr.right;
		}
	}































Iterative Preorder Traversal (Simple)
-----------------------------------------------------------------------------------------------------------------

1. My Implementation

	void iterativePreorderTraversal(Node* root)
	{
	    stack<Node*> st;
	    Node* curr = root;
	    
	    while(curr!=NULL || !st.empty())
	    {
	        while(curr != NULL)
	        {
	            cout<<curr->data<<" ";
	            st.push(curr);
	            curr = curr->left;
	        }
	        
	        curr = st.top();
	        st.pop();
	        curr = curr->right;
	    }
	}



2. C++ Implementation

	-> Idea is similar to "BFS" i.e., "Level Order Traversal"

	void iterativePreorder(Node* root)
	{
		if(root == NULL)
		{
			return;
		}

		stack<Node*> st;
		st.push(root);

		while(st.empty() == false)
		{
			Node* curr = st.top();
			cout<<(curr->data)<<" ";
			st.pop();

			if(curr->right != NULL)
			{
				st.push(curr->right);
			}

			if(curr->left != NULL)
			{
				st.push(curr->left);
			}
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(n)				// Space for "Stack"





























Iterative Preorder Traversal (Space Optimized)
----------------------------------------------------------------------------------------------------------------------

-> Algorithm for Space optimized solution

	0. The idea is to store only right children into the stack

	1. Create an empty stack, st

	2. st.push(root);

	3. curr = root;

	4. 	while(st is not empty)
		{
			while(curr is not "NULL")
			{
				print(curr's key)

				if(curr's right is not "NULL")
				{
					st.push(curr's right)
				}

				curr = cuur's left;
			}

			curr = st.top();
		}



1. C++ Implementation

	void iterativePreorder(Node* root)
	{
		if(root == NULL)
		{
			return;
		}

		stack<Node*> st;
		Node* curr = root;

		while(curr!=NULL || st.empty()==false)
		{
			while(curr != NULL)
			{
				cout<<(curr->data)<<" ";

				if(curr->right != NULL)
				{
					st.push(curr->right);
				}

				curr = curr->left;
			}

			if(st.empty() == false)
			{
				curr = st.top();
				st.pop();
			}
		}
	}


	Time Complexity:	O(n)
	Space Complexity:	O(h)































































































































































#########################################################
16. Binary Search Tree
#########################################################



Binary Search Tree(Background)
--------------------------------------------------------------------------------------------------------------------------

						Array(Unsorted)			Array(Sorted)			Linked List 		BST(Balanced)			HashTable
_______________________________________________________________________________________________________________________________________

Search 						O(n)				  O(logn)				   O(n)				   O(logn)				  O(1)

Insert 						O(1)				  O(n)					   O(1)				   O(logn)				  O(1)

Delete 						O(n)				  O(n)					   O(n)				   O(logn)				  O(1)

Find Closest 				O(n)				  O(logn)				   O(n)				   O(logn)				  O(n)				  

Sorted Traversal 			O(nlogn)			  O(n)					   O(nlogn)			   O(n)					  O(nlogn)
																	   O(n) in case of
																	  sorted Linked List
									

























Binary Search Tree(Introduction)
---------------------------------------------------------------------------------------------------------------------------

-> Important Points of BST

	1. For each and every Node, keys in left side are smaller and keys in right side are greater

	2. All keys are typically considered as "distinct"

	3. Like linked list, it is a linked data structure

	4. Implemented in C++ as "map", "set", "multimap" and "multiset", in particular Self Balancing Binary Tree

	5. Implemented in Java as "TreeSet" and "TreeMap", in particular Self Balancing Binary Tree



































Search in BST (Introduction)
-------------------------------------------------------------------------------------------------------------------------








Search in BST (C++)
--------------------------------------------------------------------------------------------------------------------------

1. Recursive C++ Implementation

	bool search(Node* root, int x)
	{
		if(root == NULL)
		{
			return false;
		}
		else if(x < root->data)
		{
			return search(root->left, x);
		}
		else
		{
			return search(root->right, x);
		}
	}


	Time Complexity:	O(h)
	Space Complexity:	O(h)				// space is required for function call stack




2. Iterative C++ Implementation

	bool search(Node* root, int x)
	{
		while(root != NULL)
		{
			if(root->data == x)
			{
				return true;
			}
			else if(x < root->data)
			{
				root = root->left;
			}
			else 
			{
				root = root->right;
			}
		}

		return false;
	}


	Time Complexity:	O(h)
	Space Complexity:	O(1)






































Insert in BST
----------------------------------------------------------------------------------------------------------------------------

1. My Solution (Iterative)

	Node* iterativeInsertInBST(Node* root, int key)
	{
	    if(root == NULL)
	    {
	        root = new Node(key);
	        return root;
	    }
	    
	    Node* prev = NULL;
	    Node* curr = root;
	    while(curr != NULL)
	    {
	        if(curr->data == key)
	        {
	            return root;            // key is already present, no need to insert
	        }
	        else if(curr->data < key)
	        {
	            prev = curr;
	            curr = curr->right;
	        }
	        else 
	        {
	            prev = curr;
	            curr = curr->left;
	        }
	    }
	    
	    // If we reach till here, it means the key is not present
	    if(key < prev->data)
	    {
	        prev->left = new Node(key);
	    }
	    else 
	    {
	        prev->right = new Node(key);
	    }
	    
	    return root;
	}




2. My Solution (Recursive)

	Node* recursiveInsertInBST(Node* root, int key)
	{
	    if(root == NULL)
	    {
	        root = new Node(key);
	        return root;
	    }
	    
	    if(root->data == key)
	    {
	        return root;
	    }
	    else if(root->data < key)
	    {
	        // key will be on right side of current root
	        root->right = recursiveInsertInBST(root->right, key);
	    }
	    else 
	    {
	        root->left = recursiveInsertInBST(root->left, key);
	    }
	    
	    return root;
	}































Insert in BST C++
------------------------------------------------------------------------------------------------------------------------------

1. Recursive Implementation

	Node* insert(Node* root, int x)
	{
		if(root == NULL)
		{
			return new Node(x);
		}
		else if(root->key < x)
		{
			root->right = insert(root->right, x);
		}
		else if(root->key > x)
		{
			root->left = insert(root->left, x);
		}

		return root;
	}


	Time Complexity:	O(h)
	Space Complexity:	O(h)



2. Iterative Implementation
	
	Node* insert(Node* root, int x)
	{
		Node* temp = new Node(x);
		Node* parent = NULL;
		Node* curr = root;

		while(curr != NULL)
		{
			parent = curr;

			if(curr->key > x)
			{
				curr = curr->left;
			}
			else if(curr->key < x)
			{
				curr = curr->right;
			}
			else
			{
				return root;
			}
		}

		if(parent == NULL)
		{
			return temp;
		}

		if(parent->key > x)
		{
			parent->left = temp;
		}
		else
		{
			parent->right = temp;
		}


		return root;
	}


	Time Complexity:	O(h)
	Space Complexity:	O(1)































Deletion in BST
---------------------------------------------------------------------------------------------------------------------------

-> There are three scenarios while deleting a Node from a binary tree

	1. Node to be deleted is a leaf Node
		-> In this case we can simply delete the leaf Node

	2. Node to be deleted has only one child
		-> In this case we also we can simply attach the Node's child to it's parent Node and delete the Node

	3. Node to be deleted has more than one children
		-> In this case we can replace the Node to be deleted by "Closest Lower value" or "Closest greater value"



-> Closest greater value of a Node in the binary tree is the "Inorder successor" of that Node
	-> We can get the Inorder Successor by: "left most Node of the Right Child"


-> Closest smaller value of a Node in the binary tree is the "Inorder predecessor" of that Node
	-> We can get the Inorder Predecessor by: "right most Node of the Left Child"































BST deletion in C++
-------------------------------------------------------------------------------------------------------------------------

1. C++ Implementation

	Node* getSuccessor(Node* curr)
	{
		curr = curr->right;

		while(curr!=NULL && curr->left!=NULL)
		{
			curr = curr->left;
		}

		return curr;
	}


	Node* deleteNode(Node* root, int x)
	{
		if(root == NULL)
		{
			return root;
		}

		if(root->key > x)
		{
			root->left = deleteNode(root->left, x);
		}
		else if(root->key < x)
		{
			root->right = deleteNode(root->right, x);
		}
		else
		{   
			if(root->left == NULL)
			{
				Node* temp = root->right;
				delete root;
				return temp;
			}
			else if(root->right == NULL)
			{
				Node* temp = root->left;
				delete root;
				return temp;
			}
			else
			{
				Node* succ = getSuccessor(root);
				root->key = succ->key;
				root->right = deleteNode(root->right, succ->key);	// Since the "successor" lies on right side therefore 
																		"root->right" is passed in recursive call
 			}
		}

		return root;
	}


	Time Complexity:	O(h)
	Space Complexity:	O(h)
































Floor in BST
--------------------------------------------------------------------------------------------------------------------------

-> We are given a "key", we need to find closest smaller or equal value to the given key in the BST 



1. My Solution

	Node* floorBST(Node* root, int key)
	{
	    if(root == NULL)
	    {
	        return NULL;
	    }
	    
	    Node* ans = NULL;
	    
	    while(root != NULL)
	    {
	        if(root->data == key)
	        {
	            return root;
	        }
	        else if(key < root->data)
	        {
	            root = root->left;
	        }
	        else
	        {
	            if(ans==NULL || ans->data < root->data)
	            {
	                ans = root;
	                root = root->right;
	            }
	        }
	    }
	    
	    return ans;
	}































Floor in BST in CPP
------------------------------------------------------------------------------------------------------------------------

1. Iterative Solution

	Node* floorInBST(Node* root, int x)
	{
		Node* res = NULL;
		while(root != NULL)
		{
			if(root->key == x)
			{
				return root;
			}
			else if(root->key > x)
			{
				root = root->left;
			}
			else
			{
				res = root;
				root = root->right;
			}
		}

		return res;
	}


	Time Complexity:	O(h)
	Space Complexity:	O(1)
































Ceil in BST
------------------------------------------------------------------------------------------------------------------------

-> We are given a "key", we need to find closest greater or equal value to the given key in the BST 


1. My Solution

	Node* ceilBST(Node* root, int key)
	{
	    Node* ans = NULL;
	    while(root != NULL)
	    {
	        if(root->data == key)
	        {
	            return root;
	        }
	        else if(root->data < key)
	        {
	            root = root->right;
	        }
	        else
	        {
	            ans = root;
	            root = root->left;
	        }
	    }
	    
	    return ans;
	}


	Time Complexity:	O(h)
	Space Complexity:	O(1)































Self Balancing BST
-----------------------------------------------------------------------------------------------------------------------

-> Idea: keep the height as O(logn)


-> Background: Same set of keys can make different height BSTs
	For Example:
		Order1: 7, 10, 11, 15, 30, 35, 40 (Right Skewed BST)
		Order2: 15, 10, 7, 11, 35, 30, 40 (Height balanced BST)


-> If we know the "keys" in advance, we can make a perfectly balanced BST.


-> How to keep it balanced when random insertions/deletions happening?
	-> The idea is to do some restructuring (or re-balancing) when doing insertions/deletions.

	-> We can perform "Rotation" either "Left Rotation" or "Right Rotation" to make sure that
		the height of the BST remains balanced

	-> The "Rotation" required for maintaing balance of a tree is O(1) operation



-> Two most popular examples of "Self Balancing BST" are
	1. AVL Tree 		(Strictly balanced)
	2. Red Black Tree  	(Loosely balanced)



-> In general, "Red Black Tree" is used more compared to "AVL Tree"
	1. In Java libraries like "TreeSet" and "TreeMap", they use "Red Black Tree"
	2. In C++ libraries "map" and "set", they also use "Red Black Tree"

































AVL Tree
----------------------------------------------------------------------------------------------------------------------

-> Imporatant Points on AVL Tree

	1. It is a BST (For every node, left subtree values are smaller and right subtree values are greater)

	2. It is balanced (For every node, difference between left and right subtree's heights does not exceed one)

	3. Balance Factor = | lh - rh |

	      Balance Factor <= 1



-> Search operation in an AVL tree is same as BST search operation

-> Insert and Delete operations are complex in AVL tree compared to BST


-> Insert Operation (Algorithm for Insertion in AVL Tree)

	1. Perform normal BST insert

	2. Traverse all ancestors of the newly inserted node from the node to root

	3. If find any "unbalanced node", check for any of the below cases

		a. Left Left
			-> Perform one Right Rotation (Single Rotation)
		b. Right Right
			-> Perform one Left Rotation (Single Rotation)

		c. Left Right
			-> Double Rotation
		d. Right Left
			-> Double Rotation



-> Time Complexity for Insertion in an AVL Tree: 	O(logn)


-> Height of AVL Tree

		height(h)  <  [C*log(n+2)] + b 

			where C  1.4405
				  b  -1.3277





























Red Black Tree
------------------------------------------------------------------------------------------------------------------

-> Important Points

	1. Every node is either "Red" or "Black"

	2. Root is always black

	3. No two consecutive Reds

	4. Number of black nodes from every node to all of its 
		descendent leaves should be same. 

	-> 4th point can also be stated as: 
		Black height of a node should be same through all descendent leaves



-> Insert and Delete operations are more complex as compared to Normal BST


-> Number of nodes on the path from a node to its farthest descendent leaf node, should not 
	be more than "twice" than the number of nodes on the path to closest descendent leaf.



-> In terms of Practical Applications, "Red Black Tree" is used a lot, This is the 
   data structure implemented by 

   	1. "set" and "map" libraries of C++ stl
   	2. "TreeMap" and "TreeSet" libraries of Java Collection






























Applications of BST
-----------------------------------------------------------------------------------------------------------------

-> Applications of BST (In particular "Self Balancing BST")
	
	1. To maintain sorted stream of data (or sorted set of data)

	2. To implement doubly ended priority queue
		-> Single ended priority queue can be implemented using "Heap" data structure
		-> If we always want to find maximum item, then we use "Max Heap"
		-> If we always want to find minimum item, then we use "Min Heap"

	3. To solve problem like: 
		a. Count smaller/greater in a stream
		b. Floor/Ceiling/Greater/Smaller in a stream



-> Note:
	If we have only "Search", "Insert" and "Delete" or a subset of these operations, It is recommended to 
	use "Hash Table" over "Self Balacing BST"


































Set in C++ STL
----------------------------------------------------------------------------------------------------------------------

-> "set" in C++, are used to store sorted data


-> Some important methods in "set"
	
	1. insert()

	2. begin()

	3. end()

	4. rbegin()

	5. rend()

	6. erase()
		-> It removes "an element" or "a group of elements" from a set

	7. clear()
		-> Remove all the elements from the container

	8. find()
		-> Returns iterator to the element, if the element is present in the set
			otherwise it returns an iterator pointing to set.end()

	9. size()
		-> Returns the size i.e., the number of elements in the container

	10. count()
			-> Returns count/occurrance of an element in the container
				Since "set" does not allow duplicate elements, hence it
				always return either "1" or "0".
			-> count() function can be used instead of find() function in a "set"





-> Example 1:

	#include <iostream>
	#include <set>

	using namespace std;

	int main() {
		set<int> s;
		s.insert(10);
		s.insert(5);
		s.insert(20);

		for(int x : s) {
			cout<<x<<" ";			// o/p: 5, 10, 20
		}

		return 0;
	}




-> Example 2: To store the data in a set in "reverse sorted" order

	#include <iostream>
	#include <set>

	using namespace std;

	int main() {
		set<int, greater<int>> s;
		s.insert(10);
		s.insert(5);
		s.insert(20);

		// Traversal method 1
		for(int x : s) {
			cout<<x<<" ";			// o/p: 20, 10, 5
		}

		// Traversal method 2
		for(auto it=s.begin(); it!=s.end(); it++)
		{
			cout<<(*it)<<" ";		// o/p: 20, 10, 5
		}

		// Traversal method 3
		set<int> :: iterator it = s.begin();
		while(it != s.end())
		{
			cout<<(*it)<<" ";		// o/p: 20, 10, 5
			it++;
		}

		// Traversal method 4
		for(auto it=s.rbegin(); it!=s.end(); it++)
		{
			cout<<(*it)<<" ";		// o/p: 5, 10, 20
		}

		return 0;
	}




-> Example 3:

	#include <iostream>
	#include <set>

	using namespace std;

	int main() {
		set<int> s;
		s.insert(10);
		s.insert(5);
		s.insert(20);
		s.insert(7);

		for(int x : s) {
			cout<<x<<" ";			// o/p: 5, 7, 10, 20
		}

		s.erase(7);
		for(int x : s) {
			cout<<x<<" ";			// o/p: 7, 10, 20
		}

		auto it = s.find(7);
		s.erase(it);	
		for(int x : s) {
			cout<<x<<" ";			// o/p: 10, 20
		}


		s.insert(25);
		s.insert(30);
		s.insert(35);
		for(int x : s) {
			cout<<x<<" ";			// o/p: 10, 20, 25, 30, 35
		}

		auto itr = s.find(25);
		s.erase(it, s.end());
		for(int x : s)
		{
			cout<<x<<" ";			// o/p: 10, 20
		}

		return 0;
	}




-> s.lower_bound() : It's a member function of "set"
		1. If the element is present, then it returns the iterator to that element
		2. If the element is not present, then it returns the iterator to next greater element
		3. If the element is greater than the maximum value inside the "set" then it returns the 
		   iterator to s.end()


-> s.upper_bound() : It's a member function of "set"
		1. If the element is present, then it returns the iterator to next of that element
		2. If the element is not present, then it returns the iterator to next greater element
		3. If the element is greater than the maximum value inside the "set" then it returns the 
		   iterator to s.end()




-> Example 4:

	int main() {
		set<int> s;
		s.insert(10);
		s.insert(5);
		s.insert(20);
		for(int x : s) {
			cout<<x<<" ";						// o/p: 5, 10, 20
		}

		auto it1 = s.lower_bound(5);			// Returns an iterator to 5
		if(it1 != s.end()) {
			cout<<(*it1)<<" ";					// o/p: 5
		} else {
			cout<<"Given element is greater than the largest"
		}
		

		auto it2 = s.upper_bound(5);			// Returns an iterator next to 5 i.e., 10
		if(it2 != s.end()) {
			cout<<(*it2)<<" ";					// o/p: 10
		} else {
			cout<<"Given element is greater than the largest"
		}

		it1 = s.lower_bound(7);
		if(it1 != s.end()) {
			cout<<(*it1)<<" ";					// o/p: 10
		} else {
			cout<<"Given element is greater than the largest"
		}

		it2 = s.upper_bound(7);
		if(it2 != s.end()) {
			cout<<(*it2)<<" ";					// o/p: 10
		} else {
			cout<<"Given element is greater than the largest"
		}

		it1 = s.lower_bound(40);				// Returns an iterator to s.end()
		if(it1 != s.end()) {
			cout<<(*it1)<<" ";
		} else {
			cout<<"Given element is greater than the largest"		// else block will execute
		}

		it2 = s.upper_bound(40);
		if(it2 != s.end()) {
			cout<<(*it2)<<" ";	
		} else {
			cout<<"Given element is greater than the largest"		// else block will execute
		}
	}






-> Internal working and Time Complexities

	1. "set" is built on top of "Self Balancing BST", in particular "Red Black Tree"

	2. O(1) operations in "set"
		-> begin()
		-> end()
		-> rbegin()
		-> rend()
		-> cbegin()
		-> cend()
		-> crbegin()
		-> crend()
		-> size()
		-> empty()

	3. O(logn) operations in "set"
		-> insert()
		-> find()
		-> count()
		-> lower_bound()
		-> upper_bound()
		-> erase(val)

	4. Amortized O(1) operations in "set"
		-> erase(it)




-> Using "set" with user defined data structure

	struct Test {
		int x;

		bool operator< (const Test&t) const
		{
			return (this->x < t.x);
		}
	}

	int main()
	{
		set<Test> s;
		s.insert({5});
		s.insert({20});
		s.insert({10});

		for(Test t : s)
		{
			cout<<t.x<<" ";			// o/p: 5 10 20
		}

		return 0;
	}




-> Applications of "set"

	1. Sorted stream of Data
	2. Doubly Ended Priority Queue


























Map in C++ STL
----------------------------------------------------------------------------------------------------------------------------

-> Similar to "set", "map" is also built on "Red Black Tree"


-> "set" is used to store keys only, whereas a "map" is used to store key-value pairs


-> Like "set", Items/Elements in the "map" are ordered, Items are ordered/sorted according to keys.
 	Default order is Increasing Order



-> Some important methods in the "map" container

	1. insert()

	2. operator[]

	3. size()

	4. empty()

	5. clear()

	6. begin()
		-> Returns an iterator to first element

	7. end()
		-> Returns an iterator, "next to / beyond the" last element





-> Example 1

	#include <iostream>
	#include <map>

	using namespace std;

	int main
	{
		map<int, int> m;

		m.insert({10, 200});
		m[5] = 100;
		m.insert({3, 300});
		for(auto &x : m)
		{
			cout<<{<<x.first<<", "<<x.second<<"}, ";				// o/p: {3, 300}, {5, 100}, {10, 200} 
		}

		m.insert({3, 400});		// This will not modify the map, since the key is already present
		for(auto &x : m)
		{
			cout<<{<<x.first<<", "<<x.second<<"}, ";				// o/p: {3, 300}, {5, 100}, {10, 200} 
		}

		return 0;
	}



-> If we try to access an item which is not present using square brackets[], then it is going to insert that 
	key with some default value



-> Example 2

	int main()
	{
		map<int, int> m;
		m.insert({10, 200});

		cout<<m.size()<<endl;			// o/p: 1
		cout<<m[20]<<endl;				// o/p: 0 (0 is the default value of an integer type key)
		cout<<m.size()<<endl;			// o/p: 2
	} 



-> Square brackets[], can also modify the values of the keys which are already present


-> There is one more operator m.at(key), which acts similar to "square operator", but the main difference 
   is that if we try to access any key which is not present in the map using "at()" operator, then it 
   throws "out of range" exception

-> at() method works only when the "key" is already present, otherwise it will throw exception




-> Some more Important Methods of "map" container
	
	1. find(key)

	2. count(key)
		-> Return type is "size_t"
		-> It returns either "1" or "0"
		-> It can be used as an alternative to "find()" method 

	3. lower_bound(key)
		-> If the "key" is present, then it returns iterator to that "key"
		-> If the "key" is not present, then it returns iterator to a Key which is just greater than the given "key"
		-> If there is no just greater Key than the given "key", then it returns iterator to "m.end()"

	4. upper_bound()
		-> If the "key" is present, then it returns an iterator pointing an element next to the given "key"
		-> If the "key" is not present, then it returns iterator to a Key which is just greater than the given "key"
		-> If there is no just greater Key than the given "key", then it returns iterator to "m.end()"

	5. erase()
		-> erase(key)
		-> erase(iterator)
		-> erase(iteratorStart, iteratorEnd)		// Removes the item from iteratorStart to iteratorEnd-1




-> Internal Working and Time Complexities
	
	1. O(1) operations/methods
		-> begin()
		-> end()
		-> rbegin()
		-> rend()
		-> size()
		-> empty()

		-> constant iterators
			a. crbegin()
			b. crend()
			c. cbegin()
			d. cend()


	2. O(logn) operations/methods
		-> count(key)
		-> find(key)
		-> erase(key)
		-> insert({key, value})
		-> []
		-> at(key)


	3. Amortized O(1) time
		-> erase(it)




-> Applications of "map"
	1. Sorted stream of data with (key, value) pairs
	2. Doubly ended Priority queue of items with (key, value) pairs




































TreeSet in Java
-----------------------------------------------------------------------------------------------------------------------

-> TreeSet is mainly an implementation of "Self Balancing BST"


-> Example 1

	import java.util.*;

	class Test {
		public static void main(String[] args) {
			TreeSet<String> s = new TreeSet<String>();		// default order of strings is "lexicographically increasing order"
			s.add("gfg");
			s.add("courses");
			s.add("ide");

			System.out.println(s);							// o/p: [courses, gfg, ide]

			System.out.println(s.contains("ide"));			// o/p: true

			Iterator<String> it = s.iterator();
			while(it.hasNext()) {
				System.out.print(it.next());				// o/p: courses, gfg, ide
			}

			s.remove("gfg");
			System.out.println(s);							// o/p: [courses, ide]


			TreeSet<Integer> ts1 = new TreeSet<Integer>();
			ts1.add(10);
			ts1.add(5);
			ts1.add(2);
			ts1.add(15);

			ts1.remove(5);

			for(Integer x : ts1) {
				System.out.print(x + " ");					// o/p: 2, 10, 15
			}

			ts1.add(5);

			System.out.println(ts1.lower(5));				// o/p: 2
				// Gives the largest value which is lower than the given value
				// Returns "null" if no smaller value exists

			System.out.println(ts1.higher(5));				// o/p: 10
				// Gives the smallest value which is higher than the given value
				// Return "null" if no higher value exists

			System.out.println(ts1.floor(5));				// o/p: 5
			System.out.println(ts1.floor(13));				// o/p: 10
				// Gives a value which is equal or smaller
				// Returns "null" if no equal or smaller value exists

			System.out.println(ts1.ceiling(5));				// o/p: 5
			System.out.println(ts1.ceiling(1));				// o/p: 2
				// Gives a value greater than or equal to given value
				// Returns "null" if no equal or greater value exists

		}
	}



-> Time Complexities of various methods of TreeSet

	1. O(logn) time complexity operations
		-> add()
		-> contains()
		-> remove()
		-> floor()
		-> ceiling()
		-> higher()
		-> lower()

	2. O(1) time complexity operations
		-> size()
		-> isEmpty()

































TreeMap in Java
-----------------------------------------------------------------------------------------------------------------------

-> Example 1

	import java.util.*

	class Test {
		public static void main(String[] args) {
			TreeMap<Integer, String> tm = new TreeMap<Integer, String>();
			tm.put(10, "geeks");
			tm.put(15, "ide");
			tm.put(5, "courses");

			System.out.println(tm);							// o/p: {5=courses, 10=geeks, 15=ide}
			System.out.println(tm.contains(10));			// o/p: true

			for(Map.Entry<Integer, String> e : tm.entrySet()) 
			{
				System.out.println(e.getKey() + " " + e.getValue());
			}

			tm.remove(10);
			System.out.println(tm);							// o/p: {5=courses, 15=ide}
		}
	}



-> Some useful methods in TreeMap
	1. remove(key)
		-> If the key is present then removes the key-value pair and returns the value corresponding to key.
		-> If the key is not present then it returns "null"

	2. higherKey(key)
		-> Returns the smallest key greater than the given key, if exists otherwise returns "null"

		2.1. higherEntry(key)
			-> Returns the key-value pair corresponding to "higherKey()"

	3. lowerKey(key)
		-> Returns the greatest key smaller than the given key, if exists otherwise return "null"

		3.1. lowerEntry(key)
			-> Returns the key-value pair corresponding to "lowerKey()"

	4. floorKey(key)
		-> Returns the greatest key smaller than or equal to given key

		4.1. floorEntry(key)
			-> Returns the key-value pair corresponding to "floorKey()"

	5. ceilingKey(key)
		-> Returns the smallest key greater than or equal to given key

		5.1. ceilingEntry(key)
			-> Returns the key-value pair corresponding to "ceilingKey()"



-> Time Complexities of Different operations

	1. O(logn) operations
		-> put()
		-> remove()
		-> containsKey()
		-> floorKey() and floorEntry()
		-> ceilingKey() and ceilingEntry()
		-> higherKey() and higherEntry()
		-> lowerKey() and lowerEntry()


	2. O(1) operations
		-> size()
		-> isEmpty()




































Ceiling on left side in an Array
-----------------------------------------------------------------------------------------------------------------------------

-> We are given an Array, for every element we need to find ceiling for this element on left side



1. My Solution

	vector<int> findCeiling(int arr[], int n)
	{
	    vector<int> res;
	    set<int> s;
	    
	    for(int i=0; i<n; i++)
	    {
	        auto it = s.lower_bound(arr[i]);
	        if(it != s.end())
	        {
	            res.push_back(*it);
	        }
	        else
	        {
	            res.push_back(-1);
	        }
	        
	        s.insert(arr[i]);
	    }
	    
	    return res;
	}




2. Naive Solution

	void printCeiling(int arr[], int n)
	{
		print(-1);

		for(int i=1; i<n; i++)
		{
			int diff = POS_INF;				// C++: int diff = INT_MAX, 	Java: int diff = Integer.MAX_VALUE

			for(int j=0; j<i; j++)
			{
				if(arr[j] >= arr[i])
				{
					diff = min(diff, arr[j]-arr[i]);
				}
			}

			if(diff == POS_INF)
			{
				print(-1);
			}
			else
			{
				print(arr[i]+diff);
			}
		}
	}



	Time Complexity:	O(n^2)
	Space Complexity:	O(1)





3. Efficient Solution

	void printCeiling(int arr[], int n)
	{
		print(-1);

		1. Create a self-balancing BST ("set" in C++ and "TreeSet" in Java). Let this be s

		2. Insert arr[0] into s

		3. 
			for(int i=1; i<n; i++)
			{
				if(s contains a ceiling of arr[i])
				{
					print the ceiling
				}
				else 
				{
					print -1
				}

				Insert arr[i] into s
			}
	}


	Time Complexity:	O(nlogn)
	Space Complexity:	O(n)




































Find Kth Smallest in BST
-----------------------------------------------------------------------------------------------------------------------------

-> Design a data structure that allows following operations efficiently
	1. Search 
	2. Insert 
	3. Delete
	4. K-th Smallest element



-> Algorithm for finding K-th Smallest element

	1. Naive Solution

		int count = 0;

		void printKth(root, k)
		{
			if(root is not null)
			{
				printKth(root.left, k)
				count++;
				if(coutn == k)
				{
					print(root.key, k)
				}
				printKth(root.right, k)
			}
		}


		Time Complexity:	O(n)


	2. Naive Solution (C++ Implementation)

		int count = 0;

		void printKth(Node* root, int k)
		{
			if(root != NULL)
			{
				printKth(root->left, k);

				count++;
				if(count == k)
				{
					cout<<root->data<<" "<<k<<endl;
				}

				printKth(root->right, k);
			}
		}


		Time Complexity:	O(n)


	3. Optimized Naive Solution (C++ Implementation)

		int count = 0;

		void printKth(Node* root, int k)
		{
			if(root != NULL)
			{
				printKth(root->left, k);

				count++;
				if(count == k)
				{
					cout<<root->data<<" "<<k<<endl;
					return;
				}

				printKth(root->right, k);
			}
		}


		Time Complexity:	O(h + k)



	4. Efficient Solution :  O(h) for K-th Smallest element

		-> We can modify the Node Structure of BST
		-> This is called "Augmented BST"

		-> Idea is to store count of Nodes in the left subtree of every Node


		4.1. C++ Implementation

			struct Node {
				int key;
				Node* left;
				Node* right;
				int lCount;				// count of Nodes, in the left subtree of the current Node

				Node(int x) 
				{
					key = x;
					left = right = NULL;
					lCount = 0;
				}
			};


		4.2. Java Implementation

			class Node {
				int key;
				Node left;
				Node right;
				int lCount;

				Node(int x) {
					key = x;
				}
			}



	5. Algorithm for Efficient Solution based on Modified Node Structure

		-> Compare (lCount + 1) with k

			1. If (lCount + 1) == k, then return root (the current node)

			2. If (lCount + 1) > k, then recursively call for left subtree with same value of k

			3. If (lCount + 1) < k, then recursively call for right subtree with "k = [k - (lCount + 1)] = [k - lCount - 1]"




 
-> How to maintain "lCount" during insertion/deletion

	1. When we are inserting a Node, we can always update "lCount" while we search the position where 
	   we are going to insert.

	    -> If the position is in the left subtree, we increment the "lCount" for the current Node
	    -> Otherwise, we do not modify the "lCount"

	2. We can perform similar procedure in case of deletion





































Check for BST
----------------------------------------------------------------------------------------------------------------------------

1. My Solution

	bool checkForBST(Node* root, int& lastElement)
	{
	    if(root == NULL)
	    {
	        return true;
	    }
	    
	    bool check1 = checkForBST(root->left, lastElement);
	    if(root->data < lastElement)
	    {
	        return false;
	    }
	    lastElement = root->data;
	    bool check2 = checkForBST(root->right, lastElement);
	    
	    return check1 && check2;
	}

	bool isBST(Node* root)
	{
	    int lastElement = INT32_MIN;
	    bool ans = checkForBST(root, lastElement);
	    return ans;
	}




2. A Simple but Wrong Solution
	
	-> Do any traversal. For every node, check if its left child is smaller and right child is greater



3. Correct but inefficient

	-> For every node

		a. Find maximum in left subtree
		b. Find minimum is right subtree
		c. Check if the current node is greater than the maximum and smaller than the minimum


	-> Time Complexity:		O(n^2)



4. Efficient Solution-1

	-> Pass a range of every node

	-> For root, range is - to +

	-> For left child of a node, in range, we change upper bound as the node's value

	-> For right child of a node, in range, we change lower bound as the node's value


	4.1. C++ Implementation

		bool isBST(Node* root, int min, int max)
		{
			if(root == NULL)
			{
				return true;
			}

			bool check1 = (root->data > min) && (root->data < max);
			bool check2 = isBST(root->left, min, root->data);
			bool check3 = isBST(root->right, root->data, max);

			return check1 && check2 && check3;
		}

		int main()
		{
			int min = INT_MIN;
			int max = INT_MAX;

			bool ans = isBST(root, min, max);
		}


		Time Complexity:	O(n)



	4.2. Optimized C++ Implementation 

		bool isBST(Node* root, int min, int max)
		{
			if(root == NULL)
			{
				return true;
			}

			return ( ((root->data > min) && (root->data < max)) 
						&& isBST(root->left, min, root->data) 
						&& isBST(root->right, root->data, max) );
		}




5. Efficient Solution-2 (Inorder Traversal)

	-> A binary tree is BST iff Inorder Traversal of the tree is in increasing order.


	5.1. C++ Implementation

		int prev = INT_MIN;

		bool isBST(Node* root)
		{
			if(root == NULL)
			{
				return true;
			}

			if(isBST(root->left) == false)
			{
				return false;
			}

			if(root->key <= prev)
			{
				return false;
			}

			prev = root->key;

			return isBST(root->right);
		}


		Time Complexity:	O(n)
		Space Complexity:	O(h)


































Fix BST with Two Nodes Swapped
---------------------------------------------------------------------------------------------------------------------

-> There are two cases
	1. When the swapped nodes are adjacent to each other (with reference to their sorted order)

	2. When the swapped nodes are not adjacent


1. Solving for Array (Psuedo code)

	prev = -, first = NIL, second = NIL

	for(i=0; i<n; i++)
	{
		if(arr[i] < prev)
		{
			if(first == NIL)
			{
				first = prev;
			}

			second = arr[i];
		}

		prev = arr[i];
	}



2. C++ Implementation

	Node* prev = NULL;
	Node* first = NULL;
	Node* second = NULL;

	void fixBST(Node* root)
	{
		if(root == NULL)
		{
			return;
		}

		fixBST(root->left);

		if(prev != NULL && root->key < prev->key)
		{
			if(first == NULL)
			{
				first = prev;
			}

			second = root;
		}
		prev = root;

		fixBST(root->right);
	}


	-> At the end of the function call Node* first and Node* second will point on the Nodes which
		needs to swapped.


	-> Time Complexity:		O(n)
	   Space Complexity:	O(h)






























Pair Sum with given BST
-----------------------------------------------------------------------------------------------------------------------

1. My Solution

	void findPairUtility(Node* root, vector<int>& arr)
	{
	    if(root == NULL)
	    {
	        return;
	    }
	    
	    findPairUtility(root->left, arr);
	    arr.push_back(root->data);
	    findPairUtility(root->right, arr);
	}

	//Function to check if any pair exists in BST whose sum is equal to given value.
	bool findPair(Node* root, int X) 
	{
	    // Your code here
	    vector<int> arr;
	    findPairUtility(root, arr);
	    
	    int sz = arr.size();
	    int i=0, j=sz-1;
	    while(i<j)
	    {
	        if(arr[i]+arr[j] == X)
	        {
	            return true;
	        }
	        else if(arr[i]+arr[j] < X)
	        {
	            i++;
	        }
	        else
	        {
	            j--;
	        }
	    }
	    
	    return false;
	}



2. Method-1 (Inorder Traversal)

	a. Do an Inorder Traversal of the given BST and Store it in an array
	b. Use Two Pointer approach to find if array has a pair with given sum


	Time Complexity:	O(n)		// More Acurately it's Theta(n)
	Space Complexity:	O(n)



3. Method-2 (Using Hashing)

	bool isPairSum(Node* root, int sum, unordered_set<int> &s)
	{
		if(root == NULL)
		{
			return false;
		}

		if(isPairSum(root->left, sum, s) == true)
		{
			return true;
		}		

		if(s.find(sum - root->key) != s.end())
		{
			return true;
		}
		else
		{
			s.insert(root->key);
		}

		return isPairBST(root->right, sum, s);  
	}


	Time Complexity:	O(n)				// BigO(n)
	Space Complexity:	O(n)



























Vertical Sum in a Binary Tree
-----------------------------------------------------------------------------------------------------------------------

-> Solution
	
	1. Create a map("map" in C++ / "TreeMap" in Java) that stores sum for a given horizontal distance

	2. Traverse the map and print values



1. C++ Implementation

	// hd is for "horizontal distance", At the time of calling it will passed as 0
	
	void verticalSumUtility(Node* root, int hd, map<int, int> &mp)				 
	{
		if(root == NULL)
		{
			return;
		}

		verticalSum(root->left, hd-1, mp);

		mp[hd] += root->data;

		verticalSum(root->right, hd+1, mp);
	}


	void verticalSum(Node* root)
	{
		map<int, int> mp;

		verticalSumUtility(root, 0, mp);

		for(auto p : mp)
		{
			cout<<(p.second)<<" ";
		}
	}



	Time Complexity:	O(nlog(hd))				// hd is total number of horizontal paths in binary tree






























Vertical Traversal of Binary Tree
-----------------------------------------------------------------------------------------------------------------------

1. My Solution
	
	// Helper function
	void inorderTraversal(Node* root, int hd, unordered_map<Node*, int> &um)
    {
        if(root == NULL)
        {
            return;
        }
        
        inorderTraversal(root->left, hd-1, um);
        um[root] = hd;
        inorderTraversal(root->right, hd+1, um);
    }
    
    //Function to find the vertical order traversal of Binary Tree.
    vector<int> verticalOrder(Node *root)
    {
        //Your code here
        vector<int> ans;
        if(root == NULL)
        {
            return ans;
        }
        
        unordered_map<Node*, int> um;
        inorderTraversal(root, 0, um);
        
        map<int, vector<int>> m;
        queue<Node*> q;
        q.push(root);
        
        while(!q.empty())
        {
            Node* temp = q.front();
            q.pop();
            int hd = um[temp];
            m[hd].push_back(temp->data);
            
            if(temp->left != NULL)
            {
                q.push(temp->left);
            }
            
            if(temp->right != NULL)
            {
                q.push(temp->right);
            }
        }
        
        for(auto it=m.begin(); it!=m.end(); it++)
        {
            vector<int> temp = (*it).second;
            for(int i=0; i<temp.size(); i++)
            {
                ans.push_back(temp[i]);
            }
        }
        
        return ans;
    }




2. Algorithm

	1. Create an empty map("map" in C++ and "TreeMap" in Java), "mp"

	2. Do level order traversal and put nodes into the "mp"

	3. Now, Traverse the map and print contents



3. C++ Implementation

	void verticalTraversal(Node* root)
	{
		map<int, vector<int>> mp;

		queue<pair<Node*, int>> q;

		q.push({root, 0});

		while(q.empty() == false)
		{
			auto p = q.front();
			Node* curr = p.first;
			int hd = p.second;
			mp[hd].push_back(curr->data);
			q.pop();

			if(curr->left != NULL)
			{
				q.push({curr->left, hd-1});
			}

			if(curr->right != NULL)
			{
				q.push({curr->right, hd+1});
			}
		}

		// Printing "map" contents line by line
		for(auto it=mp.begin(); it!=mp.end(); it++)
		{
			vector<int> temp = (*it).second;
			for(int i=0; i<temp.size(); i++)
			{
				cout<<temp[i]<<" ";
			}
			cout<<endl;
		}
	}



4. Java Implementation

	class Pair
	{
		Node node;
		int hd;

		Pair(Node n, int h)
		{
			node = n;
			hd = h;
		}
	}


	void verticalOrder(Node root)
	{
		Queue<Pair> q = new LinkedList<Pair>();

		Map<Integer, ArrayList<Integer>> mp = new TreeMap<>();

		q.add(new Pair(root, 0));

		while(!q.isEmpty())
		{
			Pair p = q.poll();
			Node curr = p.node;
			int hd = p.hd;

			if(mp.containsKey(hd))
			{
				mp.get(hd).add(curr.data);
			}
			else
			{
				ArrayList<Integer> al = new ArrayList<Integer>();
				al.add(curr.data);
				mp.put(hd, al);
			}

			if(curr.left != null)
			{
				q.add(new Pair(curr.left, hd-1));
			}

			if(curr.right != null)
			{
				q.add(new Pair(curr.right, hd+1));
			}
		}

		// Print "map" contents line by line
		for(Map.Entry<Integer, ArrayList<Integer>> p : mp.entrySet())
		{
			ArrayList<Integer> al = p.getValue();

			for(int x : al)
			{
				System.out.print(x + " ");
			}
			System.out.println();
		}
	}






























Top View of Binary Tree
-----------------------------------------------------------------------------------------------------------------------

1. My Solution

	//Function to return a list of nodes visible from the top view 
    //from left to right in Binary Tree.
    vector<int> topView(Node *root)
    {
        //Your code here
        vector<int> ans;
        if(root == NULL)
        {
            return ans;
        }
        
        map<int, int> mp;
        queue<pair<Node*, int>> q;
        q.push({root, 0});
        while(!q.empty())
        {
            pair<Node*, int> p = q.front();
            q.pop();
            int hd = p.second;
            
            if(mp.find(hd) == mp.end())
            {
                mp[hd] = (p.first)->data;
            }
            
            if((p.first)->left != NULL)
            {
                q.push({(p.first)->left, hd-1});
            }
            
            if((p.first)->right != NULL)
            {
                q.push({(p.first)->right, hd+1});
            }
        }
        
        for(auto p: mp)
        {
            ans.push_back(p.second);
        }
        
        return ans;
    }




2. Idea for Implementation

	1. Create a map "mp" using level order traversal

	2. Print the values in "mp"


































Bottom View of Binary Tree
-----------------------------------------------------------------------------------------------------------------------

1. My Solution
	
	// Incorrect Solution, please Modify
	vector <int> bottomView(Node *root) 
	{
        // Your Code Here
        vector<int> ans;
        if(root == NULL)
        {
            return ans;
        }
        unordered_map<Node*, pair<int, int>> um;
        queue<pair<Node*, int>> q;
        q.push({root, 0});
        int level = 0;
        
        while(!q.empty())
        {
            int count = q.size();
            for(int i=0; i<count; i++)
            {
                pair<Node*, int> p = q.front();
                q.pop();
                Node* curr = p.first;
                int hd = p.second;
                um[curr] = {hd, level};
                
                if(curr->left != NULL)
                {
                    q.push({curr->left, hd-1});
                }
                
                if(curr->right != NULL)
                {
                    q.push({curr->right, hd+1});
                }
            }
            
            level++;
        }
        
        map<int, Node*> mp;
        queue<Node*> que;
        que.push(root);
        while(!q.empty())
        {
            Node* curr = que.front();
            que.pop();
            
            int hd = um[curr].first;
            
            if(mp.find(hd) == mp.end())
            {
                mp[hd] = curr;
            }
            else
            {
                Node* existing = mp[hd];
                if(um[curr].second > um[existing].second)
                {
                    mp[hd] = curr;
                }
            }
            
            if(curr->left != NULL)
            {
                que.push(curr->left);
            }
            
            if(curr->right != NULL)
            {
                que.push(curr->right);
            }
        }
        
        for(auto p : mp)
        {
            Node* curr = p.second;
            ans.push_back(curr->data);
        }
        return ans;
    }


2. My Correct Solution

	vector <int> bottomView(Node *root) {
        // Your Code Here
        vector<int> ans;
        if(root == NULL)
        {
            return ans;
        }
        
        map<int, int> mp;
        queue<pair<Node*, int>> q;
        q.push({root, 0});
        while(!q.empty())
        {
            pair<Node*, int> p = q.front();
            q.pop();
            Node* curr = p.first;
            int hd = p.second;
            mp[hd] = curr->data;
            
            if(curr->left != NULL)
            {
                q.push({curr->left, hd-1});
            }
            
            if(curr->right != NULL)
            {
                q.push({curr->right, hd+1});
            }
        }
        
        for(auto p : mp)
        {
            ans.push_back(p.second);
        }
        
        return ans;
    }



3. Idea for Implementation

	-> Build a map "mp" that stores bottom node for every horizontal distance

	-> Traverse through the map and and print the contents
































































































































































#########################################################
17. Heap
#########################################################


Binary Heap Introduction
-----------------------------------------------------------------------------------------------------------------------

-> Some Important Points

	1. Used in "HeapSort"

	2. Used to implement Priority Queue

	3. Two Types

		a. Min Heap
			-> Highest Priority item is assigned lowest value

		b. Max Heap
			-> Highest Priority item is assigned highest value




-> Binary Heap is a "Complete Binary Tree" (Stored as an array)


-> Array Structure

	1. left(i)   =  2i + 1

	2. right(i)  =  2i + 2

	3. parent(i) =  floor((i-1)/2)




-> Advantage of a complete binary tree is we can store it in an Array and storing in Array provides benefits like
	
	1. Random Access
	2. Cache friendly
	3. Since it's a Complete Binary Tree, so height of tree is minimum possible



-> "Min Heap" data structure

	1. Complete Binary Tree

	2. Every node has value smaller than its descendants



-> "Min Heap" is internally represented as an Array



































Binary Heap Implementation
-----------------------------------------------------------------------------------------------------------------------

1. Our own "Heap" data structure Implementation

	class MinHeap
	{
		int arr[];
		int size;
		int capacity;

		MinHeap(int c)
		{
			arr = new int[c];
			size = 0;
			capacity = c;
		}

		int left(int i)
		{
			return (2*i + 1);
		}

		int right(int i)
		{
			return (2*i + 2);
		}

		int parent(int i)
		{
			return (i-1)/2;
		}
	}




































Binary Heap Insert
-----------------------------------------------------------------------------------------------------------------------


1. Implementation for a "Min Heap" Insert

	// This method will be written inside "MinHeap" class
	void insertMinHeap(int x)
	{
		if(size == capacity)
		{
			return;
		}

		size++;
		arr[size-1] = x;

		for(int i=size-1; i!=0 && arr[parent(i)] > arr[i]; i = parent(i))
		{
			swap(arr[i], arr[parent(i)]);
		}
	}


	Time Complexity:	O(h)			// h: height




































Binary Heap (Heapify and Extract)
-----------------------------------------------------------------------------------------------------------------------

-> Heapify operation is mainly used as a subroutine in many standard operations, like "Extract Minimum" and "Build Heap"


-> Min Heapify: Given a "Binary Heap" with one possible violation, fix the Heap



1. Implementation of "Min Heapify"

	int arr[];
	int size, capacity;

	void minHeapify(int i)
	{
		int lt = left(i);
		int rt = right(i);
		int smallest = i;

		if(lt<size && arr[lt]<arr[i])
		{
			smallest = lt;
		}

		if(rt<size && arr[rt]<arr[i])
		{
			smallest = rt;
		}

		if(smallest != i)
		{
			swap(arr[i], arr[smallest]);
			minHeapify(smallest);
		}
	}


	Time Complexity:	O(h)				// h = logn
	Space Complexity:	O(h)				// For recursive call stack 



-> Get Minimum
	
	1. It's a fuction that doesn't change the binary heap.

	2. It simply returns the minimum element




-> Extract Minimum: To remove the Minimum element in the priority queue

	-> Algorithm

		1. Swap the first element with last element
			-> swap(arr[0], arr[size-1]); 

		2. delete the last item
			-> size--;

		3. Call the function, "MinHeapify" on the first element i.e., root element
			-> MinHeapify(0);


	-> Implementation

		int extractMin()
		{
			if(size == 0)
			{
				return INF;			// C++: INT_MAX, 	Java: Integer.MAX_VALUE    
			}

			if(size == 1)
			{
				size--;
				return arr[0];
			}

			swap(arr[0], arr[size-1]);
			size--;
			minHeapify(0);
			return arr[size];
		}


		Time Complexity:	O(h) = O(logn)

































Binary Heap (Decrease Key, Delete and Build Heap)
-----------------------------------------------------------------------------------------------------------------------

1. Implementation of "Decreased Key" on a "Min Heap"

	int arr[];				// class member of "MinHeap" class
	int size, capacity:		// class member of "MinHeap" class

	void decreaseKey(int i, int x)
	{
		arr[i] = x;

		while((i != 0) && (arr[parent(i)] > arr[i]))
		{
			swap(arr[i], arr[parent(i)]);
			i = parent(i);
		}
	}


	Time Complexity:	O(logn)




2. Delete operation: To delete an item at given "index"

	-> Algorithm:

		1. Call the function "DecreaseKey(index, -)"

		2. Now call fuction "ExtractMin()"

		-> Time Complexity:	O(logn)




3. Build Heap:	Given a random array, rearrange its elements to form a "MinHeap"

	-> Algorithm

		1. We first call "minHeapify" on "Bottom most-Right most-Internal node", let's say it's at index i
			-> Note: Assumption of "minHeapify" function is, when we call "minHeapify" for an index i, 
					 it's left and right subtree should already be heapified

			-> Note: We don't need to start from external Node because for a single Node tree is already heapified

			-> "Bottom most-Right most-Internal node" is the parent of last Node and the index of last Node is i = "size - 1 ", 
				therefore it's parent index is "(i-1)/2" = "(size - 1 - 1)/2" = "(size - 2)/2"

			-> So, we can start calling "minHeapify" fuction from the index "(size - 2) / 2"
 
		2. Then we call "minHeapify" for index "i-1", then for "i-2" and so on till we reach index 0 
			(at the end we call "minHeapify" for index 0 also)


	-> Implementation

		void buildHeap()
		{
			int indexOfBottomMostRightMostInternalNode = (size - 2) / 2;

			int indexAlias = indexOfBottomMostRightMostInternalNode;

			for(int i = indexAlias; i >= 0; i--)
			{
				minHeapify(i);
			}
		}


	-> Time Complexity

		1. Simply by looking seems like it's Time Complexity = O(n*logn)

		2. But, Actual Time Complexity = "O(n)"


	-> Time Complexity calculation

		1. Maximum number of nodes at height "h"  =  ceil(n / 2^(h+1))

		2. For rest of the calculation watch video lecture































Heap Sort
-----------------------------------------------------------------------------------------------------------------------

-> The basic idea of "HeadSort" is based on "SelectionSort" Algorithm


-> Selection Sort
	1. In "SelectionSort" algorithm, we find out the maximum element and we swap it with the last element

	2. In "SelectionSort" we do the linear search to find out the maximum element

	3. Therefore time complexity becomes O(n^2)


-> Heap Sort
	1. "HeapSort" does an optimization over "SelectionSort"

	2. Uses the same idea, but for finding the maximum element, instead of doing linear search, 
		"HeapSort" uses "MaxHeap data structure"

	3. In "HeapSort", we are given an Array, we reorder the Array so that elements of the Array form a "MaxHeap"
		-> building a "MaxHeap" or a "MinHeap" from a random array takes O(n) time

	4. After building the "MaxHeap", we swap the last element with root element(first element of the Array)

	5. Then call the "maxHeapify" function on first element i.e., root element

	6. Repeat Step-4 and Step-5 till the array is sorted




-> Algorithm for "HeapSort"

	1. call the function "buildHeap()"

	2. Repeatedly swap root with last node, reduce heap size by one, and heapify(call heapify on first element)




-> Implementation

	void maxHeapify(int arr[], int n, int i)
	{
		int largest = i;
		int left = 2*i + 1;
		int right = 2*i + 2;

		if(left < n && arr[left] > arr[largest])
		{
			largest = left;
		}

		if(right < n && arr[right] > arr[largest])
		{
			largest = right;
		}

		if(largest != i)
		{
			swap(arr[i], arr[largest]);
			maxHeapify(arr, n, largest);
		}
	}


	void buildHeap(int arr[], int n)
	{
		for(int i = (n-2)/2; i >= 0; i--)
		{
			maxHeapify(arr, n, i);
		}
	}

	void heapSort(int arr[], int n)
	{
		buildHeap(arr, n);

		for(int i=n-1; i>=1; i--)
		{
			swap(arr[0], arr[i-1]);
			maxHeapify(arr, i, 0);
		}
	}


	Time Complexity:	O(n*log(n))



-> "HeapSort" can mainly be seen as an improvement of "SelectionSort"

-> Note:
	1. "MergeSort" takes "O(n*log(n))" time in "WorstCase"

	2. "QuickSort" takes "O(n*log(n))" time in "AverageCase"

	3. "HeapSort" takes "O(n*log(n))" time in "AllCases"

	4. The constants hidden in "HeapSort" are higher than "QuickSort" and "MergeSort"


































Priority Queue in C++
-----------------------------------------------------------------------------------------------------------------------

-> A "PriorityQueue" is always implemented using "Heap data-structure"

-> In C++ stl library the default priority queue is "MaxHeap"



1. Example-1

	#include <iostream>
	#include <queue>
	using namespace std;

	int main()
	{
		priority_queue<int> pq;				// By default it's a "MaxHeap" data structure
		pq.push(10);
		pq.push(15);
		pq.push(5);
		cout<<pq.size<<endl;				// o/p: 3
		cout<<pq.top()<<endl;				// o/p: 15 	// maximum element is at the top

		while(pq.empty() == false)
		{
			cout<<pq.top()<<" ";			// o/p: 15 10 5
			pq.pop();
		}

		return 0;
	}





2. To create a "MinHeap" using stl "priority_queue"

	int main()
	{
		priority_queue<int, vector<int, greater<int>> pq;		// Creates a "MinHeap" data structure
		pq.push(10);
		pq.push(15);
		pq.push(5);
		cout<<pq.size()<<endl;				// o/p: 3
		cout<<pq.top()<<endl;				// o/p: 5 	// minimum element is at the top

		while(pq.empty() == false)
		{
			cout<<pq.top()<<" ";			// o/p: 5 10 15
			pq.pop();
		}

		return 0;
	}



2.1. Workaround for creating a "MinHeap"

	int main()
	{
		int arr[] = {10, 5, 15};
		for(int i=0; i<3; i++)
		{
			arr[i] = -arr[i];
		}

		priority_queue<int> pq(arr, arr+3);

		while(pq.empty() == false)
		{
			cout<<-(pq.top())<<" ";			// o/p: 5 10 15
			pq.pop();
		}
	}




3. We can implement a "priority_queue" using an existing vector or an Array also.

	int main()
	{
		int arr[] = {10, 5, 15};
		priority_queue<int> pq(arr, arr+3);

		while(pq.empty() == false)
		{
			cout<<pq.top()<<" ";			// o/p: 15 10 5  
			pq.pop();	
		}
	}




4. Time Complexities of different functions

	1. O(1)
		-> pq.size()

		-> pq.empty()

		-> pq.top()

	2. O(log(n))
		-> pq.push(key)

		-> pq.pop()

	3. O(n)
		-> Intialization using an Array/Vector: 
			a. priority_queue<int> pq(arr, arr+size)
			b. priority_queue<int> pq(vec.begin(), vec.end())




5. To write "Custom Comparator" for user-defined data structure in case of Priority Queue

	struct Person
	{
		int age;
		float ht;

		Person(int a, int h)
		{
			age = a;
			ht = h;
		}
	};


	struct myCmp
	{
		bool operator() (Person const &p1, Person const &p2)
		{
			p1.ht < p2.ht;
		}
	};


	int main()
	{
		priority_queue<Person, vector<Person>, myCmp> pq;
	}




6. Applications of Priority Queue

	1. Dijkstra Algorithm

	2. Prim Algorithm

	3. Huffman Algorithm

	4. Heap Sort

	5. Any other place where Heap is used



-> Note: STL "priority_queue" does not support "decrese key" operation. However, we can implement most
		 of the Algorithms without "decrease key" by slightly modifying the Algorithm.




































PriorityQueue in Java
-----------------------------------------------------------------------------------------------------------------------

-> "PriorityQueue" in Java by defaults implements a "MinHeap" data structure


1. Example-1

	class Test
	{
		public static void main(String args[])
		{
			PriorityQueue<Integer> pq = new PriorityQueue<Integer>();
			pq.add(10);
			pq.add(20);
			pq.add(15);
			System.out.println(pq.peek());			// o/p: 10
			System.out.println(pq.poll());			// o/p: 10
			System.out.println(pq.peek());			// o/p: 15


			// To Implement "MaxHeap" data structure
			PriorityQueue<Integer> pqMax = new PriorityQueue<Integer>(Collections.reverseOrder());
			pqMax.add(13);
			pqMax.add(25);
			pqMax.add(17);
			System.out.println(pqMax.peek());			// o/p: 25
			System.out.println(pqMax.poll());			// o/p: 25
			System.out.println(pqMax.peek());			// o/p: 17

		}
	}




































Sort K-Sorted Array
-----------------------------------------------------------------------------------------------------------------------

-> Given Array is already "somewhat sorted"
	
-> An element at index "i", will be present between the indexes "i-k" to "i+k" in the sorted array



1. Naive Solution/Approach:
	
	-> Simply call the function "sort(arr, arr+sz)"

	-> Time Complexity:	O(n * log(n))





2. Efficient Solution (Time Complexity: O(n * log(k)))

	2.1. C++ Implementation

		void sortK(int arr[], int n, int k)
		{
			priority_queue<int, vector<int>, greater<int>> pq;

			for(int i=0; i<=k; i++)
			{
				pq.push(arr[i]);
			}

			int index = 0;
			for(int i=k+1; i<n; i++)
			{
				arr[index++] = pq.top();
				pq.pop();
				pq.push(arr[i]);
			}

			while(pq.empty() == false)
			{
				arr[index++] = pq.top();
				pq.pop();
			}
		}


	2.2. Java Implementation

		void sortK(int arr[], int k)
		{
			PriorityQueue<Integer> pq = new PriorityQueue<Integer>();

			for(int i=0; i<=k; i++)
			{
				pq.add(arr[i]);
			}

			int index = 0;
			for(int i=k+1; i<arr.size(); i++)
			{
				arr[index++] = pq.poll();
				pq.add(arr[i]);
			}

			while(pq.isEmpty() == false)
			{
				arr[index++] = pq.poll();
			}
		}


	-> Worst case time complexity:	O((n+k)*log(k))































Buy Maximum Items with Given Sum
-----------------------------------------------------------------------------------------------------------------------

1. Method-1: Sorting

	-> Time Complexity:	O(nlog(n))


2. Method-2: Heap based solution

	-> Algorithm
		1. build heap from the Array

		2. while(arr[0] > sum && index < arrSize)
		   {
		   		res++;
		   		sum -= arr[0];
		   		extractMinimum();
		   		heapify();
		   }


	-> Time Complexity:	O(n) + O(res * log(n)) == O(n*log(n))
			-> This solution performs better on Average as compared with Method-1



	-> Space Complexity
		1. O(1): If you are allowed to modify the array

		2. O(n): If not allowed to modify the array



































K Largest Elements
-----------------------------------------------------------------------------------------------------------------------

1. Naive Approach
	-> Use sorting

	-> Time Complexity:	O(n*log(n))



2. Better Solution

	-> Use "MaxHeap" data-structure


	-> Time Complexity
		1. O(n): To build the "MaxHeap"

		2. O(k*log(n)): To extract the "k" items

		3. Overall Time Complexity:	O(n + k*log(n))



3. Efficient Solution

	-> Algorithm

		1. Build a "MinHeap" of first "k" items
			-> Time Complexity:	O(k)

		2. Travers from (k+1)th element
			a. Compare current element with top of heap.
			  	If smaller than top, ignore it.

			b. Else, remove the top element and insert the current element in the "MinHeap"

				-> Time Complexity:	O((n-k)*log(k))


		3. Print contents of "MinHeap" 
			-> Time Complexity:	O(k)


		Note: In a nutshell, we are ignoring the smallest n-k elements of the Array, and in the last we will have
			  "k" largest elements in the "MinHeap"


	-> Time Complexity:	O(k + (n-k)*log(k))





































K Closest Elements
-----------------------------------------------------------------------------------------------------------------------

-> We are given an array and two number "x" and "k", we need to find out "k" closest numbers of x in the Array


1. Naive Solution

	void printKClosest(int arr[], int n, int k, int x)
	{
		bool visited[n] = {false};

		for(int i=0; i<k; i++)
		{
			int min_diff = INF;				// C++:	INT_MAX,	Java: Integer.MAX_VALUE
			int min_diff_idx;

			for(int j=0; j<n; j++)
			{
				if((visited[j] == false) && (abs(arr[j] - x) <= min_diff))
				{
					min_diff = abs(arr[j] - x);
					min_diff_idx = j;
				}
			}

			print(arr[min_diff_idx] + " ");
			visited[min_diff_idx] = true; 
		}
	}


	Time Complexity:	O(n*k)
	Space Complexity:	O(n)




2. Efficient Solution
	
	-> Idea is based on finding "k" smallest element in an Array

	-> Algorithm
		1. Create a "MaxHeap", pq(Priority Queue)

		2. for(int i=0; i<k; i++)
		   {
		   		pq.insert(abs(arr[i]-x), i);
		   }

		   		-> Time Complexity:	O(k*log(k))


		3. for(int i=k; i<n; i++)
		   {
		   		int diff = abs(arr[i]-x);
		   		if(pq.peek().diff > diff)
		   		{
		   			pq.pop();
		   			pq.add(diff, i);
		   		}
		   }

		   		-> Time Complexity:	O((n-k)*log(k))


		4. for(int i=0; i<k; i++)
		   {
		   		int idx = pq.pop().index
		   		print(arr[idx] + " ");
		   }


		   		-> Time Complexity:	O(k*log(k))



	-> Overall Time Complexity:	O(n*log(k))


































Merge K Sorted Arrays
-----------------------------------------------------------------------------------------------------------------------

1. Super Naive Solution

	-> Algorithm
		1. Put all elements in a res[]
		2. sort res[]

	
	-> Time Complexity:	O(nk * log(nk))
			// Where k is the number of input arrays
			// n is the number of elements in an array



2. Naive Solution

	-> Algorithm
		1. Copy first array to res[]
		2. Do following for remaining arrays starting from the second array,
			Merge current array into res[]


	-> Time Complexity = O(n + 2n + 3n + .... + kn) = O(n*(k^2))




3. Efficient Solution

	-> Algorithm
		1. Create a "MinHeap" of "objects", where every "object" has three fields
			-> Value
			-> Position of the Array in 2-D Array
			-> Position of the Element in the given Array

		2. "ExtractMin" and add an item of the same array in the "MinHeap"


	-> Time Complexity: O(nk * log(k))





4. C++ Implementation of the Efficient Solution

	struct Triplet {
		int val;
		int aPos;
		int vPos;

		Triplet(int v, int ap, int vp) {
			val = v;
			aPos = ap;
			vPos = vp;
		}
	}

	struct MyCmp {
		bool operator() (Triplet &t1, Triplet &t2) {
			return t1.val > t2.val;
		}
	}


	vector<int> mergeKSortedArray(vector<vector<int>> &arr) {
		vector<int> res;

		priority_queue<Triplet, vector<Triplet>, MyCmp> pq;

		for(int i=0; i<arr.size(); i++) {
			Triplet t(arr[i][0], i, 0);
			pq.push(t);
		}

		while(pq.empty() == false) {
			Triplet curr = pq.top();	pq.pop();
			res.push_back(curr.val);

			int ap = curr.aPos;
			int vp = curr.vPos;

			if(vp+1 < arr[ap].size()) {
				Triplet t(arr[ap][vp+1], ap, vp+1);
				pq.push(t);
			}
		}

		return res;
	}
	


5. Java Implementation of the Efficient Solution

	class Triplet implements Comparable<Triplet> {
		int val;
		int aPos;
		int vPos;

		Triplet(int v, int ap, int vp) {
			val = v;
			aPos = ap;
			vPos = vp;
		}

		public int compareTo(Triplet t) {
			if(val <= t.val) {
				return -1;
			} else {
				return 1;
			}
		}
	}


	List<Integer> mergeKSortedArray(List<List<Integer>> arr) {
		List<Integer> res = new ArrayList<Integer>();

		PriorityQueue<Triplet> pq = new PriorityQueue<Triplet>();

		for(int i=0; i<arr.size(); i++) {
			pq.add(new Triplet(arr.get(i).get(0), i, 0));
		}

		while(pq.isEmpty() == false) {
			Triplet curr = pq.poll();
			res.add(curr.val);
			int ap = curr.aPos;
			int vp = curr.vPos;

			if(vp+1 < arr.get(ap).size()) {
				pq.add(new Triplet(arr.get(ap).get(vp+1), ap, vp+1));
			}
		}

		return res;
	}





























Median of a Stream
-----------------------------------------------------------------------------------------------------------------------

-> Popular Interview Question


-> We are given an Array/Stream, we need to find Median of the the given Array/Stream "at every point"


1. Naive Solution (Maintain Sorted Array)

	-> Create an empty array
	-> Insert the elements one by one and after each insertion sort the Array

	-> To find the median after each insertion

		if(size%2 != 0)
		{
			return temp[size/2];
		}		
		else
		{
			return (temp[size/2] + temp[(size-1)/2])/2;
		}


	-> Time Complexity:	O(n^2)




2. Better Solution (Augmented BST)

	-> Time Complexity:	O(n*h)			// h: height of BST


	-> Algorithm

		1. We will use "Kth smallest element" in BST as a subroutine

		2. We augment the BST data structure

		3. With every node, we also maintain a value which indicates that how many elements 
			are smaller than the current/particular Node i.e., Number of elements in left subtree of 
			the current Node




3. Efficient Solution

	-> Always "n*log(n)"
	-> Cache friendly

	-> Idea for the efficient solution
		1. We maintain two containers
		2. The first container contains smaller half elements
		3. The second container contains greater half elements
		4. In out implementation, if there are odd elements then we keep
			one extra in the first container

		5. If total elements is odd, then Median is "Greatest element of first container"

		6. If total elements is even, then Median is average of 
				a. "Greatest element of first container"
				b. "Smallest element of second container" 

		7. We use "MaxHeap" for the first container and "MinHeap" for the second container





3.1. C++ Implementation of Efficient Solution

	void printMedians(int arr[], int n)
	{
		priority_queue<int> smaller;											// MaxHeap
		priority_queue<int, vector<int>, greater<int>> greater;					// MinHeap

		smaller.push(arr[0]);
		cout<<arr[0]<<endl;

		for(int i=1; i<n; i++)
		{
			int x = arr[i];

			if(smaller.size() > greater.size())
			{
				if(smaller.top() > x)
				{
					greater.push(smaller.top());
					smaller.pop();
					smaller.push(x);
				}
				else
				{
					greater.push(x);
				}

				cout<<(smaller.top() + greater.top())/2.0;
			}
			else
			{
				if(x <= smaller.top())
				{
					smaller.push(x);
				}
				else
				{
					greater.push(x);
					smaller.push(greater.top());
					greater.pop();

				}

				cout<<smaller.top();
			}
		}
	}


	Time Complexity:	O(n*log(n))



3.2. Java Implementation of Efficient Solution

	void printMedians(int arr[])
	{
		PriorityQueue<Integer> great = new PriorityQueue<Integer>();
		PriorityQueue<Integer> small = new PriorityQueue<Integer>(Collections.ReverseOrder);

		s.add(arr[0]);
		System.out.println(arr[0]);

		for(int i=1; i<arr.length; i++)
		{
			int x = arr[i];

			if(small.size() > great.size())
			{
				if(small.peek() > x)
				{
					great.add(small.poll());
					small.add(x);
				}
				else
				{
					great.add(x);
				}

				System.out.println((double) (small.peek() + great.peek()) / 2);
			}
			else
			{
				if(x <= small.peek())
				{
					small.add(x);
				}
				else
				{
					great.add(x);
					small.add(great.poll());
				}

				System.out.println(s.peek());
			}
		} 
	}

































































































































































#########################################################
18. Graph
#########################################################


Introduction to Graph
-----------------------------------------------------------------------------------------------------------------------

-> Tree data-structure is mainly used to represent hierarchy


-> A "Graph" data-structure is represented by a pair of sets
	1. The first set in the pair is set of "vertices"
	2. The second set in the pair is the set of "edges"

	3. Example:

		G = (V, E)

			V = {v1, v2, v3, v4, v5}
			E = {(v1, v2), (v1, v3), (v2, v4), (v3, v4), (v3, v5)}



Graphs
	1. Directed Graphs
		-> Contains "ordered-pair"
		-> One of the examples of "Directed Graph" is "World Wide Web", where a webpage has a link to other page
		-> "Directed" graphs are also used by "Crawlers" to crawl the web

	2. Undirected Graphs 
		-> contains "unordered-pair"
		-> Example: Friends on a social network




-> Undirected Graph (Important terms)

	1. Degree of node is number of edges going through this node.
					-> degree(V) = number of Edges passing through it

	2. Sum of degrees = 2 * |E|

	3. Maximum number of Edges = (|V| * (|V| - 1)) / 2
		-> We are not considering the possibility of self loops



-> Directed Graph (Important terms)

	1. Indegree: Number of edges coming to it

	2. Outdegree: Number of edges coming out of it

	3. Sum of Indegrees  = |E|								// |E| is total number of edges

	4. Sum of Outdegrees = |E|

	5. Maximum number of Edges = |V| * (|V| - 1)			// |V| is total number of vertices/nodes

		-> When the graph is completely connected, every
			vertex will have "V-1" edges, here we are 
			not considering the possibility of self-loops

		-> Such a graph is called "Complete graph"





-> Some more useful terms

	1. Walk: a sequence of vertices that we get by following edges on the graph

	2. Path: It's a special "Walk" with no repetition of vertices allowed

	3. Note:
		-> In some textbooks, Walk is defined as Path and Path is defined as Simple Path
			Walk ----> Path
			Path ----> Simple Path

	4. Cyclic: A graph is called cyclic if there exists a "Walk" that begins and ends with same vertex

	5. Acyclic: A graph is called Acyclic if it doesn't contain a cycle
		-> Directed Acyclic Graph(DAG) have huge number of Applications
		-> We use an Algorithm called "Topological Sorting" which is used especially for DAG's
		   and it's used for "Job Scheduling"





-> There is one classification of Graphs
	
	1. Weighted Graphs
		-> weights are assigned to edges
		-> It can be "Directed" or "Undirected"
		-> Example:
			a. A graph of Road Networks
			b. Computer Network(Routers are connected to each other in the form of a graph)

	2. Unweighted Graphs



































Graph Representation (Adjacency Matrix)
-----------------------------------------------------------------------------------------------------------------------

-> Graph Representation (Two most popular representations)
	
	1. Adjacency Matrix

	2. Adjacency List




-> Adjacency Matrix

	1. We create a Matrix of size = |V| x |V|, where V is number of vertices in graph

	2. Values at Mat[i][j] are following

		a. Mat[i][j] = 1, if there is an edge from vertex i to j

		b. Mat[i][j] = 0, otherwise


	3. For an "Undirected Graph", the "Adjacency Matrix" is a symmetric Matrix

	4. For an "Directed Graph", 
		a. Mat[i][j] = 1, if there is an outgoing edge from vertex i to j
		b. 0, otherwise


	5. To handle vertices with Arbitrary names we can have the vertices names stored in an Array,
	   where Array indexes can be used for the vertices names.

	6. For efficient implementation, one "Hash Table", h would also be required to do reverse Mapping




-> Example of Adjacency Matrix:
	1. Array Mapping
		0 	ABC
		1 	BCD
		2 	CDE
		3 	EFG		 

	2. hash table mapping
		h{ABC} = 0
		h{BCD} = 1
		h{CDE} = 2
		h{EFG} = 3

	3. Adjacency Matrix Representation

			  '0'  '1'  '2'  '3'

	     '0'   0    1    1    0

	     '1'   1    0    1    0

	     '2'   1    1    0    1

         '3'   0    0    1    0






-> Properties of Adjacency Matrix Representation

	1. Space Required = (V x V)

	2. Operation:

		a. Check if "u" and "v" are adjecent:  		(1)

		b. Find all vertices adject to "u":			(V)

		c. Find degree of "u":						(V)

		d. Add/Remove an Edge:						(1)

		e. Add/Remove a Vertex:						(V^2)



























Graphh Representation (Adjacency List)
-----------------------------------------------------------------------------------------------------------------------

-> An array of lists where, lists are most popularly represented as 
	1. Dynamic sized Arrays
	2. Linked List


-> Properties of Adjacency List Representation

	1. Space Required = (V + E)
		a. Undirected Graph: Space Required = V + 2*E
		b. Directed Graph: Space Required = V + E

	2. Operation:

		a. Check if there is an edge from "u" to "v":  		(V)

		b. Find all vertices adject to "u":					(degree(u))

		c. Find degree of "u":								(1)

		d. Add an Edge:										(1)

		e. Remove an Edge:									(V)

































Adjacency List Implementation in CPP
-----------------------------------------------------------------------------------------------------------------------

-> Example-1
	
	// Function to add Edge in an "Undirected Graph"
	void addEdge(vector<int> adj[], int u, int v)
	{
		adj[u].push_back(v);
		adj[v].push_back(u);
	}


	// Function to print adjacencies of all vertices
	void printGraph(vector<int> adj[], int V)
	{
		for(int i=0; i<V; i++)
		{
			for(int x: adj[i])
			{
				cout<<x<<" ";
			}
			cout<<"\n";
		}
	}

	int main()
	{
		int V = 4;				// number of vertices
		vector<int> adj[V];		// Array of vector

		addEdge(adj, 0, 1);
		addEdge(adj, 0, 2);
		addEdge(adj, 1, 2);
		addEdge(adj, 1, 3);

		printGraph(adj, V);

		return 0; 
	}




-> In practical scenarios, we can read "V" from the console and then
   we can run a loop for every edge and we can call "addEdge" function 
   for each edge.































Adjacency List Implementation in Java
-----------------------------------------------------------------------------------------------------------------------

-> Example-1

	class Graph {
		static void addEdge(ArrayList<ArrayList<Integer>> adj, int u, int v) {
			adj.get(u).add(v);
			adj.get(v).add(u);
		}

		static void printGraph(ArrayList<ArrayList<Integer>> adj) {
			for(int i=0; i<adj.size(); i++)
			{
				for(int j=0; j<adj.get(i).size(); j++) {
					System.out.print(adj.get(i).get(j) + " ");
				}
				System.out.println();
			}
		}

		public static void main(String[] args) {
			int V = 5;
			ArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>(5);

			for(int i=0; i<V; i++)
			{
				adj.add(new ArrayList<Integer>());
			}

			addEdge(adj, 0, 1);
			addEdge(adj, 0, 2);
			addEdge(adj, 1, 2);
			addEdge(adj, 1, 3);

			printGraph(adj);
		}
	}






























Adjacency Matrix and List Comparison
-----------------------------------------------------------------------------------------------------------------------


								List 							 Matrix
-------------------------------------------------------------------------------------

Memory						  (V + E)							(V * V)


Check if there is an 
edge from u to v 				O(V)							  (1)


Find all adjacent of u 		 (degree(u)) 					      (V)


Add an Edge 					(1)							  (1)


Remove an Edge 					O(V)							  (1)





-> Number of edges for 

	1. Undirected Graph:	0 <= E <= (V * (V-1))/2

	2. Directed Graph:		0 <= E <= (V * (V-1))



-> A "Graph" where connectivity is high is called is called "Dense Graph"

-> A "Graph" where connectivity is low is called is called "Sparse Graph"




































Breadth First Search (BFS)
-----------------------------------------------------------------------------------------------------------------------

-> BFS is one of the Graph traversal mechanism


-> First Version: 
	Given an "Undirected Graph" and a source vertex "s", print BFS from the given source


	1. My Solution

		void printBFS(vector<vector<int>> adj, int s)
		{
		    unordered_set<int> uset;
		    queue<int> q;
		    q.push(s);
		    while(!q.empty())
		    {
		        int s = q.front();  q.pop();
		        if(uset.find(s) == uset.end())
		        {
		            cout<<s<<" ";
		            uset.insert(s);
		        }
		        
		        for(int j=0; j<adj[s].size(); j++)
		        {
		            if(uset.find(adj[s][j]) == uset.end())
		            {
		                cout<<adj[s][j]<<" ";
		                q.push(adj[s][j]);
		                uset.insert(adj[s][j]);
		            }
		        }
		    }
		}



	2. C++ Implementation

		void BFS(vector<int> adj[], int V, int s)
		{
			bool visited[V+1];
			for(int i=0; i<V; i++)
			{
				visited[i] = false;
			}

			queue<int> q;
			visited[s] = true;
			q.push(s);

			while(q.empty() == false)
			{
				int u = q.front();
				q.pop();
				cout<<u<<" ";

				for(int v: adj[u])
				{
					if(visited[v] == false)
					{
						visited[v] = true;
						q.push(v);
					}
				}
			}
		}



	3. Java Implementation

		void BFS(ArrayList<ArrayList<Integer>> adj, int V, int s)
		{
			boolean visited[] = new boolean[V+1];

			Queue<Integer> q = new LinkedList<Integer>();

			visited[s] = true;

			q.add(s);

			while(q.isEmpty() == false)
			{
				int u = q.poll();
				System.out.print(u + " ");

				for(int v: adj.get(u))
				{
					if(visited[v] == false)
					{
						visited[v] = true;
						q.add(v);
					}
				}
			}
		}






-> Second Version:
	No Source given and graph may be disconnected



	1. My Solution

		void printBFS(vector<vector<int>> adj)
		{
		    unordered_set<int> set;
		    queue<int> q;

		    for(int v=0; v<adj.size(); v++)
		    {
		        if(set.find(v) == set.end())
		        {
		            q.push(v);
		            while(!q.empty())
		            {
		                int u = q.front();    q.pop();
		                cout<<u<<" ";
		                set.insert(u);
		                
		                for(int x: adj[u])
		                {
		                    if(set.find(x) == set.end())
		                    {
		                        q.push(x);
		                        set.insert(x);
		                    }
		                }
		            }
		        }
		    }
		}



	2. C++ Implementation

		void BFS(vector<int> adj, int s, bool visited[])
		{
			queue<int> q;
			visited[s] = true;
			q.push(s);
			while(q.empty() == false)
			{
				int u = q.front();
				q.pop();
				cout<<u<<" ";

				for(int v : adj[u]) 
				{
					if(visited[v] == false)
					{
						visited[v] = true;
						q.push(v);
					}
				}
			}
		}


		void BFSDisconnected(vector<int> adj[], int V)
		{
			bool visited[V+1];
			for(int i=0; i<V; i++)
			{
				visited[i] = false;
			}

			for(int i=0; i<V; i++)
			{
				if(visited[i] == false)
				{
					BFS(adj, i, visited);
				}
			}
		}


		Time Complexity:	O(V+E)





-> BFS problem varition
	1. Given an "Undirected Graph", which may possibly be disconnected. We need to count connected components
		in this Undirected Graph.

	2. This problem is also asked as "Number of Islands in the Graph"

	Note: A Component is called "connected", if every vertex is reachable from every other vertex.


	1. My Solution

		int countConnectedComponents(vector<vector<int>> adj)
		{
		    unordered_set<int> set;
		    queue<int> q;
		    int ans = 0;

		    for(int v=0; v<adj.size(); v++)
		    {
		        if(set.find(v) == set.end())
		        {
		            ans++;
		            q.push(v);
		            while(!q.empty())
		            {
		                int u = q.front();    q.pop();
		                set.insert(u);
		                
		                for(int x: adj[u])
		                {
		                    if(set.find(x) == set.end())
		                    {
		                        q.push(x);
		                        set.insert(x);
		                    }
		                }
		            }
		        }
		    }
		    
		    return ans;
		}



	2. C++ Implementation

		void BFS(vector<int> adj, int s, bool visited[])
		{
			queue<int> q;
			visited[s] = true;
			q.push(s);
			while(q.empty() == false)
			{
				int u = q.front();
				q.pop();
				cout<<u<<" ";

				for(int v : adj[u]) 
				{
					if(visited[v] == false)
					{
						visited[v] = true;
						q.push(v);
					}
				}
			}
		}


		int BFSDisconnected(vector<int> adj[], int V)
		{
			int count = 0;
			bool visited[V+1];
			for(int i=0; i<V; i++)
			{
				visited[i] = false;
			}

			for(int i=0; i<V; i++)
			{
				if(visited[i] == false)
				{
					BFS(adj, i, visited);
					count++;
				}
			}

			return count;
		}


		Time Complexity:	O(V+E)


























Applications of BFS
-----------------------------------------------------------------------------------------------------------------------

-> BFS applications are 

	1. Shortest Path in an "Unweighted Graph"
		-> BFS is used for "Weighted Graphs" as well but instead of Normal queue, PriorityQueue is used.

	2. Crawler in Search Engine

	3. Peer to Peer Networks

	4. Social Networking Search

	5. In Garbage Collection (Cheney's Algorithm)

	6. Cycle detection
		-> Cycle detection can be done by either BFS or DFS

	7. Ford Fulkerson Algorithm
		-> It's a maximum flow Algorithm
		-> It can use either BFS or DFS, but BFS provides better time complexity

	8. Broadcasting





































Depth First Search (DFS)
-----------------------------------------------------------------------------------------------------------------------

-> First Version of DFS (Simple version)
	1. We are given an Undirected and Connected Graph
	2. We are also given a Source vertex
	3. We need to print the DFS of the Graph, starting from the given source.


	-> DFS is mainly "Recursive" in Nature



	1. My Solution

		void printDFSRecursive(vector<vector<int>> adj, int s, unordered_set<int> &hashSet)
		{
		    hashSet.insert(s);
		    cout<<s<<" ";
		    for(int i=0; i<adj[s].size(); i++)
		    {
		        if(hashSet.find(adj[s][i]) == hashSet.end())
		        {
		            printDFSRecursive(adj, adj[s][i], hashSet);
		        }
		    }
		    return;			// This return statement is not required, it won't effect the program output
		}


		void printDFS(vector<vector<int>> adj, int s)
		{
		    unordered_set<int> hashSet;
		    printDFSRecursive(adj, s, hashSet);
		}




	2. C++ Implementation

		void DFSRec(vector<int> adj[], int s, bool visited[])
		{
			visited[s] = true;
			cout<<s<<" ";

			for(int u: adj[s])
			{
				if(visited[u] == false)
				{
					DFSRec(adj, u, visited);
				}
			}
		}


		void DFS(vector<int> adj[], int V, int s)
		{
			bool visited[V];							// V is the number of vertices in the Graph

			for(int i=0; i<V; i++)
			{
				visited[i] = false;
			}

			DFSRec(adj, s);
		}







-> Second Version of DFS
	1. Graph may be disconnected
	2. We are not given the source vertex



	1. My Solution

		void printDFSRecursive(vector<vector<int>> adj, int s, unordered_set<int> &hashSet)
		{
		    hashSet.insert(s);
		    cout<<s<<" ";
		    for(int i=0; i<adj[s].size(); i++)
		    {
		        if(hashSet.find(adj[s][i]) == hashSet.end())
		        {
		            printDFSRecursive(adj, adj[s][i], hashSet);
		        }
		    }
		}


		void printDFS(vector<vector<int>> adj)
		{
		    unordered_set<int> hashSet;
		    for(int s=0; s<adj.size(); s++)
		    {
		        if(hashSet.find(s) == hashSet.end())
		        {
		            printDFSRecursive(adj, s, hashSet);
		        }
		    }
		    
		}



	2. C++ Implementation

		void DFSRec(vector<int> adj[], int s, bool visited[])
		{
			visited[s] = tree;
			cout<<s<<" ";

			for(int u: adj[s])
			{
				if(visited[u] == false)
				{
					DFSRec(adj, u, visited);
				}
			}
		}


		void DFS(vector<int> adj[], int V)
		{
			bool visited[V];

			for(int i=0; i<V; i++)
			{
				if(visited[i] == false)
				{
					DFSRec(adj, i, visited);
				}
			}
		}











-> DFS problem varition
	1. Given an "Undirected Graph", which may possibly be disconnected. We need to count connected components
		in this Undirected Graph.

	2. This problem is also asked as "Number of Islands in the Graph"

	Note: A Component is called "connected", if every vertex is reachable from every other vertex.



	1. My Solution

		void countConnectedNodesDFS(vector<vector<int>> adj, int s, unordered_set<int> &hashSet)
		{
		    hashSet.insert(s);
		    for(int i=0; i<adj[s].size(); i++)
		    {
		        if(hashSet.find(adj[s][i]) == hashSet.end())
		        {
		            countConnectedNodesDFS(adj, adj[s][i], hashSet);
		        }
		    }
		}


		int countConnectedNodes(vector<vector<int>> adj)
		{
		    int count = 0;
		    unordered_set<int> hashSet;
		    for(int s=0; s<adj.size(); s++)
		    {
		        if(hashSet.find(s) == hashSet.end())
		        {
		            count++;
		            countConnectedNodesDFS(adj, s, hashSet);
		        }
		    }
		    
		    return count;
		}



	2. C++ Implementation

		void DFSRec(vector<int> adj[], int s, bool visited[])
		{
			visited[s] = tree;

			for(int u: adj[s])
			{
				if(visited[u] == false)
				{
					DFSRec(adj, u, visited);
				}
			}
		}


		int DFS(vector<int> adj[], int V)
		{
			bool visited[V];
			int count = 0;

			for(int i=0; i<V; i++)
			{
				if(visited[i] == false)
				{
					DFSRec(adj, i, visited);
					count++;
				}
			}

			return count;
		}


		Time Complexity:	O(V+E)




























Applications of DFS
-----------------------------------------------------------------------------------------------------------------------

-> Applications of DFS(Depth First Search)

	1. Cycle Detection

	2. Topological Sorting
		-> Topological sorting is particularly useful for dependency graphs.

	3. Strongly Connected Components
		-> Strongly connected components problem has two popular Algorithms
			a. Kosaraju Algorithm
			b. Tarjan's Algorithm

	4. Solving Maze and Similar Puzzles
		-> DFS is always preferred over BFS to solve problems like Maze
		-> Backtracking Algorithms that we study, they are all based on DFS

	5. Path Finding


































Shortest Path in an Unweighted Graph
-----------------------------------------------------------------------------------------------------------------------

-> Problem Statement
	1. Given an Unweighted "Graph"

	2. The "graph" can be "Directed" or "Undirected"

	3. We are also given a source vertex

	4. We need to find out the shortest distance from the given source to every other vertex


-> Since there is no weight to edges, so the shortest distance means that number of edges should be minimum




1. My Solution

	int findShortestPath(vector<vector<int>> adj, int s, int d, unordered_set<int> hashSet, priority_queue<int, vector<int>, greater<int>> pq)
	{
	    if(s == d)
	    {
	        pq.push(0);
	        return pq.top();
	    }

	    for(int i=0; i<adj[s].size(); i++)
	    {
	        if(hashSet.find(adj[s][i]) == hashSet.end())
	        {
	            hashSet.insert(adj[s][i]);
	            int temp = findShortestPath(adj, adj[s][i], d, hashSet, pq);
	            pq.push(temp);
	        }
	    }
	    
	    return 1 + pq.top();
	}


	void shortestPath(vector<vector<int>> adj, int s)
	{
	    /*vector<int> output;*/
	    
	    priority_queue<int, vector<int>, greater<int>> pq;
	    unordered_set<int> hashSet;
	    
	    for(int d=0; d<adj.size(); d++)
	    {
	        int minDistance = findShortestPath(adj, s, d, hashSet, pq);
	        cout<<minDistance<<" ";
	    }
	    
	    /*return output;*/
	}



2. BFS(Breadth-First-Search) based Algorithm

	-> Idea
		1. Initialize: dist[V] = {INF, INF, ...., INF}

		2. dist[s] = 0;

		3. Create a queue, q

		4. Initialize: visited[V] = {false, false, ..., false}

		5. q.push(s), visited[s] = true

		6. Repeating part

			while(q is not empty)
			{
				u = q.pop();

				for every adjacent v of u
				{
					if(visited[v] == false)
					{
						dist[v] = dist[u]+1;
						visited[v] = true;
						q.push(v);
					}
				}
			} 

		7. Print dist[]


	-> Time Complexity:	O(V+E)





3. C++ Implementation of BFS based Algorithm

	vector<int> shortestPath(vector<vector<int>> adj, int s)
	{
	    vector<int> output(adj.size());
	    output[s] = 0;
	    unordered_set<int> hashSet;
	    queue<int> q;
	    q.push(s);
	    hashSet.insert(s);
	    while(!q.empty())
	    {
	        int v = q.front();  q.pop();
	        
	        for(int i=0; i<adj[v].size(); i++)
	        {
	            if(hashSet.find(adj[v][i]) == hashSet.end())
	            {
	                output[adj[v][i]] = 1 + output[v];
	                q.push(adj[v][i]);
	                hashSet.insert(adj[v][i]);
	            }
	        }
	    }
	    
	    return output;
	}





























Detect Cycle in Undirected Graph
-----------------------------------------------------------------------------------------------------------------------

-> Given an "Undirected Graph", we need to check if contains cycle or not

-> Detecting cycle in an "Undirected Graph" is much simpler problem that detecting cycle in a "Directed Graph"

-> We can detect cycle in "Undirected Graph" by both BFS and DFS



1. My Solution (BFS based Solution)

	bool detectCycle(vector<vector<int>> adj, int s, unordered_set<int> &hashSet)
	{
	    queue<int> q;
	    q.push(s);
	    
	    while(!q.empty())
	    {
	        int v = q.front();  q.pop();
	        if(hashSet.find(v) != hashSet.end())
	        {
	            return true;
	        }
	        else
	        {
	            hashSet.insert(v);
	        }
	        
	        for(int i=0; i<adj[v].size(); i++)
	        {
	            if(hashSet.find(adj[v][i]) == hashSet.end())
	            {
	                q.push(adj[v][i]);
	            }
	        }
	    }
	    
	    return false;
	}


	bool containsCycle(vector<vector<int>> adj)
	{
	    unordered_set<int> hashSet;
	    
	    for(int i=0; i<adj.size(); i++)
	    {
	        if(hashSet.find(i) == hashSet.end())
	        {
	            bool temp = detectCycle(adj, i, hashSet);
	            if(temp == true)
	            {
	                return true;
	            }
	        }
	    }
	    
	    return false;
	}



2. Psuedo Code (DFS based Solution)
	
	-> Note:
		-> If a vertex is visited, and it's not the parent of current vertex, they only we say that "there is a cycle"

	DFSRec(adj, s, visited, parent)
	{
		visited[s] = true;

		for(every adjecent u of s)
		{
			if(visited[u] == false)
			{
				if(DFSRec(adj, u, visited, s) == true)
				{
					return true;
				}
			}
			else if(u != parent)
			{
				return true;
			}
		}

		return false;
	}


	DFS(adj, V)
	{
		visited[V] = {false, false, ...., false};

		for(int i=0; i<V; i++)
		{
			if(visited[i] == false)
			{
				if(DFSRec(adj, i, visited, -1) == true)
				{
					return true;
				}
			}
		} 

		return false;
	}


	Time Complexity:	O(V+E)




3. Psuedo Code (BFS based Solution)

	-> We can maintain an Array of Parents

	-> H.W : 	Please try to write a BFS based solution to detect cycle based on above logic




























Detect Cycle in a Directed Graph(Part 1)
-----------------------------------------------------------------------------------------------------------------------

-> Detect Cycle in a Directed Graph using "DFS"
	
	1. In the recursion call tree of a DFS traversal, if you see an edge from one of the descendent to 
	   one of the ancestors, which is currently active in the recursion, then we can say there is a cycle.

	2. Such edges are called "Back Edge"


-> So the simple principle is While doing "DFS Traversal", if there is a "Back edge", then there is a cycle  


1. DFS implementation of Cycle Detection

	DFSRec(adj, s, visited[], recSt[])
	{
		visited[s] = true;
		recSt[s] = true;

		for(every adjacent 'u' of 's')
		{
			if(visited[u] == false && DFSRec(adj, u, visited, recSt))
			{
				return true;
			}
			else if(recSt[u] == true)
			{
				return true;
			}
		}

		recSt[s] = false;		// At returning time we are resetting the recSt[s]

		return false;
	}


	DFS(adj, V)
	{
		visited[V] = {false, false, ...., false};
		recSt[V] = {false, false, ...., false};

		for(int i=0; i<V; i++)
		{
			if(visited[i] == false)
			{
				if(DFSRec(adj, i, visited, recSt) == true)
				{
					return true;
				}
			}
		}

		return false;
	}


	Time Complexity:	O(V+E)






































Topological Sorting (Kahn's BFS based Algorithm)
-----------------------------------------------------------------------------------------------------------------------

-> Problem Statement
	
	1. We are given a "Directed Acyclic Graph (DAG)", we need to find topological sorting of it

	2. In "topological sorting", we consider the Vertices or Nodes as "Jobs" and directed Edges as "Dependencies" 



-> Idea for the BFS based solution
	
	1. We need to print "Zero Indegree Vertices"  first
		-> Zero Indegree Vertices: Vertices which have not any incoming vertices




-> Algorithm for Topological Sorting (BFS based Solution)

	1. Store indegree of every vertex
	2. Create a Queue, q
	3. Add all 0 indegree vertices to the q
	4. 
		while(q is not empty)
		{
			u = q.pop();
			print(u);

			for(every adjacent v of u)
			{
				-> Reduce indegree of v by 1
				-> If indegree of v becomes 0, add v to the q
			}
		}


	-> Time Complexity:	O(V+E)





























Detect Cycle in a Directed Graph (Part 2)
-----------------------------------------------------------------------------------------------------------------------

-> BFS based Algorithm

-> Cycle Detection in Directed Graph using Kahn's Algorithm


-> When we have a cycle in Directed Graph, there will not be any vertex with indegree = 0, at certain 
	point, because there is a cycle and all vertices are dependent on each other so the minimum 
	indegree of any vertex in the cycle will be '1' only



-> Algorithm

	1. Store indegree of every vertex
	2. Create a Queue, q
	3. Add all 0 indegree vertices to the q

	4. count = 0;

	5. 
		while(q is not empty)
		{
			u = q.pop();
			count++;

			for(every adjacent v of u)
			{
				-> Reduce indegree of v by 1
				-> If indegree of v becomes 0, add v to the q
			}
		}

	6. return (count != V);				// If there is a cycle then 'count' will be less than 'V'


	-> Time Complexity:	O(V+E)































Topological Sorting (DFS based Algorithm)
-----------------------------------------------------------------------------------------------------------------------

-> Problem Statement
	1. We are given a "Directed Acyclic Graph (DAG)", where Vertices represents Job and Edges represents Dependencies

	2. We need to print finishing order of Jobs so the dependencies are followed

	3. There can be a multiple topological sorts of a graph, we jush need to print any one of them



1. DFS based Algorithm for Topological Sorting

	DFSRecModified(adj[], u, st)
	{
		1. Mark 'u' as visited

		2. 
			for(every adjacent 'v' of 'u')
			{
				if(v is not visited)
				{
					DFSRecModified(v, st);
				}
			}

		3. Push 'u' to st 			// Modification to standard DFS
	}


	topologicalSorting(adj[])
	{
		1. Create an empty stack, st

		2. 
			for(every vertex u, do following)
			{
				if(u is not visited)
				{
					DFS(u, st);
				}
			}

		3. 
			while(st is not empty)
			{
				pop an item from 'st' and print it
			}
	}


	Time Complexity:	O(V+E)





































Shortest Path in DAG
-----------------------------------------------------------------------------------------------------------------------

-> Shortest Path in "Directed Acyclic Graph"

-> Problem Statement:

	1. We are given a DAG and a source vertex

	2. Edges are given with a "weight"

	3. We need to find out shortest distance from the given source vertex to every other vertex 
		considering the weights of edges

	4. If any vertex is not reachable from given source then consider distance b/w them as "INF"



-> Idea is to use topological sorting


-> Algorithm to find "Shortest Path in DAG", based on topological sort

	1. Initialize dist[V] = {INF, INF, ...., INF}

	2. dist[s] = 0

	3. Find a topological sort of the graph

	4. 
		for(every vertex 'u' in the topological sort)
		{
			for(every adjacent 'v' of 'u')
			{
				if(dist[v] > dist[u]+weight(u, v))
				{
					dist[v] = dist[u] + weight(u, v);
				}
			}
		}


	-> Time Complexity:		O(V+E)
































Prim's Algorithm / Minimum Spanning Tree
-----------------------------------------------------------------------------------------------------------------------

-> Given a "weighted" and "connected", Undirected Graph, we have to find "Minimum Spanning Tree" of this graph

-> If there are 'V' vertices, then the minimum spanning tree will contain (V - E) number of edges


1. Naive Solution / Brute Force Algorithm
	-> Consider all possible Spanning Trees and find the spanning tree with minimum weight among all of them



2. Prim's Algorithm
	-> Prim's Algorithm is a "Greedy Algorithm" to find the spanning tree

	-> Idea of Prim's Algorithm is, We maintain two sets, one set containing vertices which are there in the "MST", 
		and the other set containing those vertices which are yet to be included in "MST"























Implementation of Prim's Algorithm C++
-----------------------------------------------------------------------------------------------------------------------

1. C++ Implementation of Prim's Algorithm for MST

	int primMST(vector<int> graph[], int V)
	{
		int res = 0;

		int key[V];
		fill(key, key+V, INT_MAX);
		key[0] = 0;

		bool mSet[V] = {false};

		for(int count = 0; count < V; count++)
		{
			int u = -1;
			for(int i=0; i<V; i++)		// Loop to find "minimum value key" from the key[]
			{
				if(!mSet[i] && (u == -1 || key[i] < key[u]))
				{
					u = i;
				}
			}

			mSet[u] = true;
			res = res + key[u];

			for(int v=0; v<V; v++)
			{
				if(graph[u][v] != 0 && !mSet[v])
				{
					key[v] = min(key[v], graph[u][v]);
				}
			}
		}

		return res;
	}


	Time Complexity:	O(V^2)



-> The above implementation can be optimized by using an "adjacency list representation" and using 
	a "minHeap" data-structure for storing the keys and finding the minimum key.
	Time Complexity:	O((V+E)logV)

































Dijkstra's Shortest Path Algorithm
-----------------------------------------------------------------------------------------------------------------------

-> Problem Statement
	-> Given a weighted graph and a source, find shortest distances from source to all other vertices.



-> Algorithm:
	
	1. Idea of Djikstra's Algorithm is similar to Prim's Algorithm

	2. We begin with source vertex and initialize the source distance as 0

	3. We initialize the distance of every other vertex as ''

	4. At every movement we pick a vertex and finalize a distance.
		-> We pick that vertex which has minimum distance

		4.1. After picking a vertex and finalizing a distance, we go through all "adjacent" vertices of it
		4.2. When we go through all adjacent of the vertex we perform "Relax(u, v)" operation
			-> In "Relax(u, v)" operation, 'u' is the vertex which we finalized and 'v' is an adjacent of 'u'
			-> In Relax operation what we try to find if we get a shorter path through 'u' to 'v'

				// Snippet of "Relax(u, v)" operation
				for(int v=0, v<adj[u].size(); v++)
				{
					if(dist[v] > dist[u] + wt(u, v))
					{
						dist[v] = dist[u] + wt(u, v);
					}
				}

	5. So, we basically maintain two sets, one set of vertices for which distance has yet to be finalize
		and the other set for which distance is finalized.




-> Some Interesting Facts/Questions on Dijkstra's Algorithm

	1. Does not work for negative weight edges

	Q2. Does the shortest path change if we add a weight to all the edges of the original graph?
		Ans. Yes, it may change. The reason is that there can be different number of edges from a source vertex
			 to desired vertex.

	Q3. Does the shortest path changes if we multiply a weight to all the edges of the original graph?
		Ans. No, it remains same



-> Psuedo Code / Algorithm for Implementation

	Dijkstra(s)
	{
		1. Create an empty Priority Queue(or Min Heap), pq

		2. dist[v] = {, , , ...., }

		3. dist[s] = 0

		4. Insert all distance in 'pq'							// O(V)

		5. 
			while(pq.empty() == false)							// O(V)	
			{
				u = pq.extractMin();							// C++: u = pq.pop()		    // O(logV)	

				Relax all adjacent of u that are not in pq 		// decrease key operation 	 	// O(logV)
			}
	}


	Time Complexity:	O(V*logV) + O(E*logV)					// Similar to Prim's Algorithm




-> Note: 
	Library function in C++ and Java does not support "decrease key" operation, so we have to implement some tricky operation 
	to achieve the same




























Implementation of Dijkstra's Algorithm C++
-----------------------------------------------------------------------------------------------------------------------

-> We are going to implement for "Adjacency Matrix Representation" of an Undirected Graph


1. C++ Implementation (Simple implementation of Dijkstra's Algorithm)

	vector<int> dijkstra(vector<int> graph[], int V, int src)
	{
		vector<int> dist(V, INT_MAX);
		dist[src] = 0;

		vector<boo> fin(V, false);				// Array to maintain "Finalized" vertices

		// We need to run the loop only "V-1" times, because once we have finalized "V-1" vertices, the distance last 
			// vertex must have been finalized (because after finalizing each vertex we relax all it's adjacent vertices)
		for(int count=0, count < V-1, count++)
		{
			int u = -1;
			for(int i=0; i<V; i++)			// Loop to find minimum edge vertex which are yet to be "finalized"
			{
				if(!fin[i] && (u == -1 || dist[i] < dist[u]))
				{
					u = i;
				}
			}

			fin[u] = true;					// vertex 'u' is finalized

			// Loop to perform "Relax(u, v)" operation
			for(int v=0, v<V, v++)
			{
				if(graph[u][v] != 0 && fin[v] == false)
				{
					dist[v] = min(dist[v], dist[u]+graph[u][v]);
				}
			}
		}

		return dist;
	}


	Time Complexity:	O(V^2)



-> Optimizations for the above Algorithm
	
	1. We can use "adjacency list" representation instead of "adjacency graph" representation

	2. We can use "minHeap" data-structure to find the minimum vertex in O(logV) time

		-> Optimized Time Complexity: 	O((V+E)*logV)





























Kosaraju's Algorithm (Part 1)
-----------------------------------------------------------------------------------------------------------------------

-> Kosaraju's Algorithm is used to solve the strongly connected component problem.


-> Problem Statement:
	
	1. Given a directed Graph

	2. We need to find all the strongly connected components in it and we need to print these 
		strongly connected components separated by new lines


-> Strongly Connected Component
	If a set of vertices form connections in such a way that every pair is reachable from each other, then 
	this set of vertices called a strongly connected component.



-> Kosaraju's Algorithm is based on "Depth First Search"

-> If we begin from "sink component" toward the "source component", then we will get the strongly connected compoonent


-> Algorithm

	1. Order the vertices in decreasing order of finish times in DFS
		-> To implement this step, we may think in terms of topological sort
		-> The only difference is, in topological sort we don't have any cycles, but here we have

	2. Reverse all edges 		// This gives the transpose of the given graph 

	3. Do "DFS" of the reversed graph in the order obtained in step-1.
		For every vertex, print all reachable vertices as one "Strongly Connected Component" 
















Kosaraju's Algorithm (Part 2)
-----------------------------------------------------------------------------------------------------------------------

-> Implementation of Kosaraju's Algorithm

	1. Step-1 Implementation

		1. Create an empty stack, st

		2.
			for(every vertex 'u')
			{
				if(u is not visited)
				{
					DFSRec(u, st);
				}
			}

		3. 
			while(st is not empty)
			{
				pop an item and add to result
			}




		DFSRec(u, st)
		{
			a) Mark 'u' as visited

			b) 
				for(every adjacent v)
				{
					if(v is not visited)
					{
						DFSRec(v, st)
					}
				}

			c) st.push(u)
		}



	-> Time Complexity: 	O(V+E)





-> Note:
	1. Kosaraju's Algorithm is not the based Algorthim for finding Strongly Component Component.
	2. There exist a better Algorithm called "Tarzan Algorithm", that finds Strongly Connected
		Components in only one DFS traversal



































Bellman Ford Shortest Path Algorithm
-----------------------------------------------------------------------------------------------------------------------

-> Problem Statement
	
	1. Given a graph and a Source vertex

	2. We need to find shortest distant from the source vertex to every other vertex



-> Bellman Ford is a shortest path finding Algorithm



-> Shortest Path Problem
	
	1. If the Graph is "Unweighted" and "Undirected", then "Shortest Path Problem" can be solved using BFS

	2. Given a "Weighted, Directed and Acyclic Graph (DAG)", then we can solve "Shortest Path Problem" using "Topological Sort"

	3. Dijktra's Algorithm work for both "Directed" and "Undirected" Graph and the Graph may contain "Cycles"
		-> Dijkstra's Algorithm has a limitation that it doesn't work if the edge has "Negative Weight"

	4. Bellman Ford is shortest path finding Algorithm, which does not have limitations of Dijkstra's Algorithm
		-> Bellman Ford is a "Dynamic Programming Algorithm", so we build the solution is bottom-up manner

		-> We use the solutions of edge lenghts 'i-1' to find the shortest paths of edge lenghts 'i'

		-> In Bellman Ford Algorithm, we can process the "edges" in any order




-> Idea behind Bellman Ford Algorithm
	We find shortest paths that are of one edge length (containing only one edge) from source, then 
	shortest path that are of two edge length (containing only two edges) from source and so on.


-> Algorithm
	We relax all edges 'V-1' times




-> Psuedo Code for Bellman Ford Algorithm

	d[v] = {INF, INF, INF, ..., INF};

	d[s] = 0;

	for(count=0; count < (V-1); count++)
	{
		// Relax operation
		for(every edge (u, v))
		{
			if(d[v] > d[u] + weight(u, v))
			{
				d[v] = d[u] + weight(u, v);
			}
		}
	}


	Time Complexity:	O(VE)			// For a complete graph, E = O(V^2)





-> Modified Bellman Ford Algorithm to detect "Negative Weight Cycle"

	d[v] = {INF, INF, INF, ..., INF};

	d[s] = 0;

	for(count=0; count < (V-1); count++)
	{
		// Relax operation
		for(every edge(u, v))
		{
			if(d[v] > d[u] + weight(u, v))
			{
				d[v] = d[u] + weight(u, v);
			}
		}
	}


	// Loop to detect "Negative Weight Cycle"
	for(every edge(u, v))
	{
		if(d[v] > d[u]+weight(u, v))
		{
			print("Negative Weight Cycle Found");
		}
	} 









































Articulation Point
-----------------------------------------------------------------------------------------------------------------------
#Repeat
#Revise

-> Articulation Point or Cut Vertices
	
	1. Articulation Points are the points, removal of which and their associated edges 
		increases the number of connected Components to more than one.


-> Problem Statement
	
	1. Given a "Connected" and "Undirected" Graph

	2. We need to find Articulation Points in it



-> Idea of Implementation to find out Articulation Points is based on DFS


-> There are two Rules about Articulation Point
	
	1. If your point of beginning of traversal has two or more than two children, then it is an Articulation Point
		-> i.e., If the "root" of the DFS Tree has two or more than two children then root is an Articulation Point

	2. If a non-root Node has a child whose Low Value is greater than or equal to Discovery Time of this Node.
		-> i.e., If there is a edge from 'u' to 'v', and LowValue[v] >= DiscoveryTime[u],
			 	 then vertex/node 'u' is an Articulation Point.

		-> This rule means that, if a vertex has a child through which you can't reach any of the Ancestors, then
			if you remove this particular vertex then this child and the subtree of this child becomes disconnected




-> Concept of "Discovery Time" and "Low Value"
	
	1. Discovery Time:
		-> Time taken for a vertex to be visited

	2. Low Values:
		-> Low Value is lowest Discovery Time Vertex reachable from this node/vertex, through 
		"Back Edges" or "Tree Edges"



-> Note: Implementation is due




































Bridges in Graph
-----------------------------------------------------------------------------------------------------------------------
#Repeat

-> Problem Statement

	1. We are given an "Undirected" and "Connected" Graph

	2. We need to find "Bridges" in this Graph



-> Bridge: A "Bridge" is an edge, if you remove this edge, then number of Connected Component in a Graph increases.


-> This problem is similar to "Articulation Point" problem


-> An edge "u - v" is called a "Bridge", if lowValue of 'v' is greater than discoveryTime of 'u'

	i.e., lowValue[v] > discoveryTime[u]	=> 	Edge u-v is a Bridge






-> Note: Implementation is due








































Tarjans Algorithm
-----------------------------------------------------------------------------------------------------------------------

-> Tarjans Algorithm is used to find "Strongly Connected Component" in a "Directed Graph"


-> Kosaraju's Algorithm required two traversal of a "Directed Graph" to find the 
	"Strongly Connected Component"



-> A component is called "Strongly Connected Component", if every verex is reachable from every other vertex


-> The idea of this Tarjans Algorithm is based on "lowValue" and "discoveryTime"


-> Tarjans Algorithm is better than Kosaraju's Algorithm, since it required only one traversal








































Kruskal's Algorithm
-----------------------------------------------------------------------------------------------------------------------
#Repeat

-> Kruskal's Algorithm for "Minimum Spannig Tree"


-> Problem Statement

	1. Given a "Connect", "Weighted" and "Undirected" Graph

	2. We need to find "Minimum Spanning Tree" for this Graph
		-> Spanning Tree of a Graph is a tree which connects all the vertices

		-> In the Spannig Tree, there should still be path from each vertex to every other vertex  

		-> It should be a tree, which means there should not be any cycle

		-> Spannig Tree of a Graph with 'V' number of Vertices always has 'V-1' Edges. 



-> Kruskal's Algorithm is a simple "Greedy Algorithm" and the idea is we first sort all the edges 
	in increasing order of their weights.




-> Algorithm

	1. Sort all edges in increasing order

	2. Initialize: 
		-> MST = []

		-> res = 0

	3. Do following for everty edge 'e' 

		for(every edge 'e')
		{
			while(MST size doesn't become 'V-1')
			{
				if(adding 'e' to MST does not cause a cycle)
				{
					MST = MST U {e}				// We add edge 'e' to MST

					res = res + weight(e)
				}
			}
		}

	4. Return res






-> In Kruskal's Algorithm, we need to represent Graph as a Collection of Edges



1. C++ Implementation for "Edge" representation of the Graph

	struct Edge
	{
		int src;			// source
		int dest;			// destination
		int wt;				// weight of edge

		Edge(int s, int d, int w)
		{
			src = s;
			dest = d;
			wt = w;
		}
	}


	bool myCmp(Edge e1, Edge e2)
	{
		return e1.wt < e2.wt;
	}








2. Java Implementation for "Edge" representation of the Graph

	class Edge implements Comparable<Edge>
	{
	 	int src;
	 	int dest;
	 	int wt;

	 	Edge(int s, int d, int w)
	 	{
	 		src = s;
	 		dest = d;
	 		wt = w;
	 	}

	 	public int compareTo(Edge e)
	 	{
	 		return this.wt - e.wt;
	 	}
	}





3. Efficient Implementation of the Kruskal's Algorithm

	-> The idea is to use "Disjoint Set" data-structure

	int parent[V];
	int rank[V];							// rank array is to optimize the disjoint-set implementation

	int kruskal(Edge arr[])
	{
		sort(arr);							// C++: sort(arr, arr+E, myCmp);

		// Initialization
		for(int i=0; i<V; i++)
		{
			parent[i] = i;
			rank[i] = 0;
		}

		int res = 0;


		for(int i=0, s=0; s < V-1; i++)
		{
			Edge e = arr[i];
			int x = find(e.src);
			int y = find(e.dest);

			if(x != y)
			{
				res += e.wt;
				Union(x, y);
				s++;
			}
		}
	}


	-> Note

		i: Index of next edge

		s: current size of MST

		V: Total number of Vertices

		E: Total number of Edges

		-> find() and union() have standard implementations.

		-> find() operation helps in detection the cycle

		-> union() operation helps in adding the edge to MST

		-> "rank" represents, heights of individual trees in the disjoint set data-structure 



































































































































































#########################################################
19. Greedy
#########################################################


Introduction to Greedy Algorithms
-----------------------------------------------------------------------------------------------------------------------

-> Greedy Algorithms are mainly useful for "Optimization Problems".

-> Optimization Problem is maximizing or minimizing something



1. Minimum Coin Problem

	Problem:

		a. Consider infinite supply of the following value coins: 10, 5, 2, 1

		b. If someone asks for an amount, how will you give this amount using minimum number of coins


	Solution:

		int minCoins(int coins[], int n, int amount)
		{
			1. Sort coins[] in decreasing order

			2. int res = 0;

			3.
				for(int i=0; i<n; i++)
				{
					if(coins[i] <= amount)
					{
						int c = floor(amount/coin[i]);
						res = res+c;
						amount = amount - (c * coin[i]);
					}

					if(amount == 0)
					{
						break;
					}
				}

				return res;
		}






-> General structure of Greedy Algorithm

	getOptimal(Item arr[], int n)
	{
		1. Initialize: res = 0

		2.
			while(All items are not considered)
			{
				i = selectAnItem()

				if(feasible(i))
				{
					res = res+i;
				}
			}

		3. Return res
	}




-> Greedy Algorithms may not work always

	1. Example-1:

		-> Consider the following: coins[] = {18, 1, 10}, amount = 20

		-> Greedy Algorithm will give the answer as One coin of value 18, and Two coins of value 1
			which makes total number of coins as 3

		-> But the optimal solution is to give the amount using Two coins of value 10



-> Applications of Greedy Algorithms

	1. Finding Optimal Solutions

		-> Activity Selection

		-> Fractional Knapsack

		-> Job Sequencing

		-> Prim's Algorithm

		-> Kruskal's Algorithm

		-> Dijkstra's Algorithm

		-> Huffman Coding 				// An optimal lossless compression technique

	2. Finding close to Optimal Solutions for "NP Hard Problems" like "Travelling Salesman Problem"












































Activity Selection Problem
-----------------------------------------------------------------------------------------------------------------------

1. Naive Solution

	-> Naive Solution will take exponential time

	-> We can optimize the Naive Solution using "Dynamic Programming"



2. Efficient Solution: O(n * log(n))

	-> Use Greedy Approach

	-> Hint: Sort the array of pairs based on finishing time of Activities

	2.1. Greedy Algorithm 

		1. Sort the Activities based on their finishing time

		2. Initialize Solution an final activity

		3. Do the following for remaining Activities:

			a. If current activity overlaps with the last picked activity in the solution
				then ignore the current Activity

			b. Else, add the current Activity to the solution


























Activity Selection Solution in C++
-----------------------------------------------------------------------------------------------------------------------

1. C++ Implementation of Greedy Approach for Activity Selection Problem

	bool myCmp(pair<int, int) p1, pair<int, int> p2)
	{
		return (p1.second < p2.second);
	}

	int maxActivities(pair<int, int> arr[], int n)
	{
		sort(arr, arr+n, myCmp);

		int prev = 0;
		int res = 1;

		for(int curr=1; curr<n; curr++)
		{
			if(arr[curr].first >= arr[prev].second)
			{
				res++;
				prev = curr;
			}
		}

		return res;
	}


	Time Complexity:	O(n * log(n))































Activity Selection Solution in Java
-----------------------------------------------------------------------------------------------------------------------

1. Java Implementation of Greedy Approach for Activity Selection Problem
	
	class Activity
	{
		int start;
		int finish;

		Activity(int s, int f)
		{
			start = s;
			finish = f;
		}
	}

	class MyCmp implements Comparator<Activity>
	{
		public int compare(Activity a1, Activity a2)
		{
			return a1.finish - a2.finish;
		}
	}

	class Test
	{
		public static void main(String[] args)
		{
			Activity arr[] = {
								new Activity(12, 25), 
								new Activity(10, 20), 
								new Activity(20, 30)
							 };

			System.out.println(maxActivity(arr));
		}


		static int maxActivity(Activity[] arr)
		{
			Arrays.sort(arr, MyCmp);

			int res = 1;

			int prev = 0;

			for(int curr=1; curr < arr.length; curr++)
			{
				if(arr[curr].start >= arr[prev].finish)
				{
					res++;
					prev = curr;
				}
			}

			return res;
		}
	}


	Time Complexity:	O(n * log(n))














































Fractional Knapsack
-----------------------------------------------------------------------------------------------------------------------

-> Algorithms for Fractional Knapsack Problem

	1. Calculate ratio(value/weight) for every item

	2. Sort all item in decreasing order of the ratio

	3. Initialize: 
		-> res = 0;
		-> curr_cap = given_cap;

	4. 
		for(every item 'I' in sorted order)
		{
			if(I.weight <= curr_cap)
			{
				curr_cap = curr_cap - I.weight;
				res = res + I.value;
			}
			else
			{
				res = res + (I.value)*(curr_cap/I.weight);
				return res;
			}
		}

		return res;



-> Time Complexity:	O(n * log(n))
























Fractional Knapsack in C++
-----------------------------------------------------------------------------------------------------------------------

1. C++ Implementation of Fractional Knapsack Problem using Greedy Approach

	bool myCmp(pair<int, int> a, pair<int, int> b)
	{
		double r1 = (double) a.first/a.second;				// Value/Weight ratio

		double r2 = (double) b.first/b.second;				// Value/Weight ratio

		return r1 > r2;
	}


	double fKnapSack(int W, pair<int, int> arr[], int n)
	{
		sort(arr, arr+n, myCmp);

		double res = 0.0;

		for(int i=0; i<n; i++)
		{
			if(arr[i].second <= W)
			{
				res += arr[i].first;						// adding the value to 'res'
				W -= arr[i].second;							// reducing the current capacity
			}
			else
			{
				res += arr[i].first * ((double) W / arr[i].second);
				break;
			}
		}

		return res;
	}


	Time Complexity:	O(n * log(n))




























Fractional Knapsack in Java
-----------------------------------------------------------------------------------------------------------------------

1. Java Implementation of Fractional Knapsack Problem using Greedy Approach

	class Item implements Comparable<Item>
	{
		int wt;
		int val;

		public Item(int w, int v)
		{
			wt = w;
			val = v;
		}

		public int compareTo(Item i)
		{
			return (wt)*(i.val) - (val)*(i.wt);
		}
	}


	public class Test
	{
		public static void main(String[] args)
		{
			Item arr[] = {
							new Item(10, 60);
							new Item(40, 40);
							new Item(20, 100);
							new Item(30, 120);
						};

			int W = 50;

			System.out.println(fracKnapSack(arr, W));
		}

		static double fracKnapSack(Item[] arr, int W)
		{
			Array.sort(arr);

			double res = 0.0;

			for(int i=0; i<arr.length; i++)
			{
				if(arr[i].wt <= W)
				{
					res = res + arr[i].val;
					W = W - arr[i].wt;
				}
				else
				{
					res = res + arr[i].val * ((double)W / (double)arr[i].wt);
					break;
				}
			}

			return res;
		}

	}


	Time Complexity:	O(n * log(n))





































Job Sequencing Problem
-----------------------------------------------------------------------------------------------------------------------

-> Problem Statement

	1. We are given 'n' jobs

	2. Every Job has a deadline and associated profit with it

	3. Some others Rules which needs to be followed
		-> One unit by every Job i.e., Every Job takes one unit of time

		-> Only one Job can be assigned at a time

		-> Time starts with 0

	3. Target is to maximize the Profit





-> Greedy Algorithm for Job Sequencing Problem

	1. Sort jobs in decreasing order of profit

	2. Initialize the result as first job in the sorted list.
		Assign the "latest possible slot"

	3. Do following for the remaining 'n-1' jobs

		a. If this job can not be added, ignore it

		b. Else, add it to the "latest possible slot"














































Huffman Coding (Introduction)
-----------------------------------------------------------------------------------------------------------------------

-> Some Important Point about Huffman Coding

	1. Huffman Coding is a popular "Lossless Compression Technique"

	2. Used for lossless compression

	3. Variable Length Coding
		-> Variable Length Coding means every character which is encoded is not going 
			to have the same encoding




-> Variable Length Huffman Coding

	1. Greedy Idea:
		-> The most frequent character has smallest code

	2. Prefix requirement for Decompression
		-> No code should be prefix of any other























Huffman Algorithm
-----------------------------------------------------------------------------------------------------------------------

-> The codes generated by Huffman Algorithm are prefix free code

-> High Level view of the Algorithm

	1. Build a Binary Tree: This binary tree is also called Huffman Tree
		-> Every input character is a leaf

		-> Every left child edge is labelled as 0 and right as 1

		-> Every root to leaf path represents Huffman code of the leaf

	2. Traverse the Binary Tree and print the codes 





















































































































#########################################################
20. Backtracking
#########################################################






























































































































































#########################################################
21. Dynamic Programming
#########################################################






























































































































































#########################################################
22. Trie
#########################################################






























































































































































#########################################################
23. Segment and Binary Indexed Trees
#########################################################






























































































































































#########################################################
24. Disjoint Set
#########################################################





























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































